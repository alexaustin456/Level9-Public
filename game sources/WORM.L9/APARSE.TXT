; Standard Adventure Asource
;
; M.J.Austin 13/9/85
;
; Parser
;

var
 alreadyprintedscenery

BEGIN
.CANCELINPUT
; something of great importance has happened - remove
; rest of input from line
 GOSUB @CLEARINPUT
.GETCOMMAND
 GOSUB @TICKCLOCK
.GC0
 STACK
.GC1
; before printing What now?, check if any more commands waiting
 IF NOMOREINPUT=FALSE THEN GC3 ; still something left on line
 NOMOREINPUT=FALSE ; disable flag which is set on getting 0 from input
 IF SOMETHINGPROCESSED=FALSE THEN GC3 ; prevent CR producing 'WHAT NOW'
 MESSAGE 17 ; WHAT NOW ?%
 alreadyprintedscenery=false ;>>mike 25/10/86

 RANDOM X1 ; kick random number generator
 SOMETHINGPROCESSED=FALSE
.GC3
 GOSUB @PARSEINPUT
 IF VERB<>0 THEN GC4
 GOTO GC0

.GC4
 GOSUB PRESENTMULTIPLE ; HANDLE MULTIPLE OBJECTS, CALLING VERB REPEATEDLY
 GOTO @POSTCOMMAND
;---
.PRESENTMULTIPLE
; GIVEN VERB,PREP,NOUN2 AND OBJECTTABLE,
; CALL VERB ONCE FOR EACH OBJECT SPECIFIED BY OBJECTTABLE
; EVERYTHING, IT ETC. ARE HANDLED HERE
; Work down from top so static objects, containers come first
 DIR=0 ;  prevent some SPECIALMOVES being triggered
 GOSUB @CONVERTVERB
 AGAINVERB=VERB
 GOSUB @SELECTOBJECTPOS
 IF EVERYTHING=TRUE THEN PMEVERYTHING
; handle individual objects
 CURRENTOBJECT=1 ; pointer into OBJECTTABLE
.PMSINGLE1
 OBJECT=OBJECTTABLE(CURRENTOBJECT)
 IF OBJECT=0 THEN PMSINGLEEND

 GOSUB @CHECKIFACCESSIBLE
 IF RESULT=TRUE THEN PMSINGLE2
 GOSUB @OBJECTNOTHERE
 HAVECALLEDVERB=TRUE
 GOTO PMSINGLENEXT
.PMSINGLE2
 NOUN1=OBJECT
 HAVECALLEDVERB=TRUE
 GOSUB CALLVERB
.PMSINGLENEXT
 ADD CURRENTOBJECT,C1
 GOTO PMSINGLE1

.PMSINGLEEND
 IF HAVECALLEDVERB=TRUE THEN PMSINGLERET
 NOUN1=NULLOBJECT
 GOSUB CALLVERB

.PMSINGLERET
 RETURN
;---
.PMEVERYTHING
 CURRENTOBJECT=139 ; ??? MAXOBJECT
 NOUN1=NULLOBJECT
.PMEV1
;
; check if object if forbidden
;
 OBJECT=CURRENTOBJECT

 GOSUB @CHECKIFACCESSIBLE
 IF RESULT=FALSE THEN PMEV3

 SEARCHDEPTH=1
 GOSUB @CHECKIFOBVIOUS
 IF OBVIOUS=FALSE THEN PMEV3

 GOSUB @CHECKIFFORBIDDEN
 IF RESULT=TRUE THEN PMEV3

 NOUN1=CURRENTOBJECT
 HAVECALLEDVERB=TRUE
 GOSUB CALLVERB
.PMEV3
 SUB CURRENTOBJECT,C1
 IF CURRENTOBJECT<30000 THEN PMEV1
 IF HAVECALLEDVERB=TRUE THEN PMRET
 GOSUB CALLVERB

.PMRET
 RETURN

;---
.CALLVERB
; GIVEN VERB,PREP,NOUN1,NOUN2,
; DO THE JUMP-TABLE INDEXING ON THE VERB
 MESSAGE CR
 SAVEHISEARCHPOS=HISEARCHPOS

 IF NOUN1=NULLOBJECT THEN CALLVERB1
 IF EVERYTHING=TRUE THEN CALLVERBDESC
 IF VERBSTOCALL<2 THEN CALLVERB1
.CALLVERBDESC
 X1=NOUN1
 GOSUB @DESCOBJX1A
 MESSAGE COLON

.CALLVERB1
 GOSUB ABSCALLVERB

 HISEARCHPOS=SAVEHISEARCHPOS
 RETURN
;---
.ABSCALLVERB

; Come here to call verb without printing desc first
 LASTVERBVALID=TRUE
 OBJECT=NOUN1
 HISEARCHPOS=NONSPECIFIC
 RESULT=TRUE
 GOSUB @FUNNIES
 IF RESULT=TRUE THEN @CVRET
 OBJECT=NOUN2 ; ** NEW CODE 6/11/85
 GOSUB @OBJECTTRIGGER ; ** NEW CODE 6/11/85
 IF RESULT=TRUE THEN @CVRET ; ** NEW CODE 6/11/85
 OBJECT=NOUN1 ; ** NEW CODE 6/11/85
 GOSUB @OBJECTTRIGGER ; TRIGGERS FOR ANY VERB ON OBJECT
 IF RESULT=TRUE THEN @CVRET ; FLAG NOT RESET, SO COMMAND PROCESSED

; Do jump-table type indexing
; Flow will return to PRESENTMULTIPLE when the verb has finished

 IF VERB=ICLIMB THEN @CLIMB
 IF VERB=IJUMP THEN @JUMP
 IF VERB<16 THEN @MOVE
 IF VERB=22 THEN @INVENTORY
 IF VERB=IRESTORE THEN @RESTORE
 IF VERB=ISAVE THEN @SAVE
 IF VERB=IQUIT THEN @QUIT
 IF VERB=ILOOK THEN @DESCRIBEROOM
; IF VERB=ILISTEN THEN @HEAR
; IF VERB=ISMELL THEN @SMELL
 IF VERB=IWAIT THEN @WAIT
 IF VERB=ISLEEP THEN @SLEEP

 IF VERB=IPICTURE THEN @PICTURE
 IF VERB=IWORDS THEN @WORDS
 IF VERB=ISTAND THEN @STAND
 IF VERB=ILIE THEN @LIE
 IF VERB=ISIT THEN @SIT
 IF VERB=ISCORE THEN @SCORE

 IF VERB=IGETME THEN @GETME ; ******
 IF VERB=IGOTO THEN @GOTO ; ******
;
 IF VERB=36 THEN @RAMCOMMAND ;>>MIKE 18/8/86
 IF VERB=37 THEN @OOPS ;>>MIKE 18/8/86
 IF VERB=38 THEN @AUTHORS ;>> MIKE 18/8/86
 IF VERB=39 THEN @HELP ;>> MIKE 18/8/86
 IF NOUN1<>NULLOBJECT THEN CVGOTNOUN
 if everything=true then everythingmessage ;>>mike 8/9/86
 M1=1033 ; must supply an object group
 GOTO @VARYMESSAGE

.everythingmessage
 message 1037 ; there doesn't seem to be anything around
 return

.CVGOTNOUN
 IF VERB<41 THEN TOOCOMPLEX
 IF VERB=IOPEN THEN @OPEN
 IF VERB=ITAKE THEN @TAKE
 IF VERB=IPICK THEN @TAKE
 IF VERB=IWEAR THEN @WEAR
 IF VERB=IDROP THEN @DROP
 IF VERB=IPUT THEN @PUT
 if verb=iinsert then @put ;>>mike 19/01/86
 IF VERB=IEXAMINE THEN @EXAMINE
 IF VERB=IATTACK THEN @ATTACK
 IF VERB=IREMOVE THEN @REMOVE
 IF VERB=ITHROW THEN @THROW
 IF VERB=IEAT THEN @EAT
 IF VERB=IPUSH THEN @PUSH
 IF VERB=IPULL THEN @PULL
 IF VERB=IGIVE THEN @GIVE
 IF VERB=IWAKE THEN @WAKE
 IF VERB=ISQUEEZE THEN @SQUEEZE
 IF VERB=IFASTEN THEN @FASTEN
 MESSAGE 1036 ; don't understand verb
.CVRET
 RETURN
;---
.TOOCOMPLEX
 MESSAGE 1039 ; sentence is too complex
 RETURN
;---
.CHECKIFACCESSIBLE
; return RESULT=TRUE if OBJECT is accessible to VERB
; objects must be present in way HISEARCHPOS
 IF VERB=IGETME THEN @RETURNTRUE
 IF OBJECT<NUMBEROFFSET THEN CIANOTNUMBER
 IF OBJECT>HINUMBEROFFSET THEN CIANOTNUMBER
 X1=NUMBEROFFSET
 INUMBER=OBJECT
 SUB INUMBER,X1
 ITNUMBER=INUMBER
 OBJECT=BUTTONS

.CIANOTNUMBER
 IF OBJECT>MAXOBJECT THEN @CIASCENERY
 IF HISEARCHPOS<>NONSPECIFIC THEN CIANOTNS
 POS=ROOM
 HIPOS=0
 GOSUB @CHECKOBJECTPOS
 IF RESULT=TRUE THEN CIAHAVECHECKED
 POS=PLAYER
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
 GOTO CIAHAVECHECKED

.CIANOTNS
 IF HISEARCHPOS<>NOUNCARRIED THEN CIANOTCARRIED
 POS=PLAYER
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
 GOTO CIAHAVECHECKED

.CIANOTCARRIED
 POS=PLAYER
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS ; looking on ground only. if carried, can't be
 X1=RESULT
 RESULT=FALSE
 IF X1=TRUE THEN CIAHAVECHECKED
 POS=ROOM
 HIPOS=0
 GOSUB @CHECKOBJECTPOS

.CIAHAVECHECKED
 RETURN
;---
.PRINTINPUTWORD
 MESSAGE QUOTE
 PRINTINPUT
 MESSAGE QUOTE
 RETURN
;---
.PARSETOOMUCH ; TOO MUCH ENTERED
 MESSAGE 1001
 GOTO PARSEERROR
;---
.PARSENOOBJECT
 MESSAGE 1002
 GOTO PARSEERROR
;---
;.PARSENOTKNOWN ; WORD NOT RECOGNIZED
; MESSAGE 1000
; GOSUB PRINTINPUTWORD
; GOTO PARSEERROR
;---
.PARSENOTKNOWN ; WORD NOT RECOGNIZED
.SECONDPREP
.PARSENOVERB
.CANTUSEHERE
 MESSAGE 1003
 GOSUB PRINTINPUTWORD
 MESSAGE 1004
 GOTO PARSEERROR
;---
.NOTCLEAR
; User has referred to a piece of scenery which is not nearby
 OBJECT=0
 HAVECALLEDVERB=TRUE
 ADD VERBSTOCALL,C1
;>>mike 8/9/86
 message 1130 ; I can find no reference to "
 PRINTINPUT
; MESSAGE COLON
 MESSAGE 1135 ; "here
 RETURN
;---
.DONTUNDERSTAND
; general error message when the parsing has borken
; down for some reason
 MESSAGE 1010
; drop through to PARSEERROR
;

.PARSEERROR
 MESSAGE DOTCR
 GOSUB @CLEARINPUT
 GOTO @PRECOMMAND
;---
.OBJECTNOTHERE
; THE OBJECT IS NOT AVAILBALE TO THE COMMAND
; THIS ERROR RETURNS AS IT IS USED IN PRESENTMULTIPLE
 IF OBJECT=0 THEN ONTRET
 IF HISEARCHPOS=NOUNONGROUND THEN ONT1
 IF HISEARCHPOS=NONSPECIFIC THEN CANTSEEIT
 MESSAGE 1012 ; don't have..
.ONTERROR
 MESSAGE 21 ; THE
.onterror2
 X1=OBJECT
 GOSUB @DESCOBJX1A
 MESSAGE DOT
.ONTRET
 RETURN

.ONT1
 POS=PLAYER
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
 IF RESULT=TRUE THEN ONT2
.CANTSEEIT
 POS=PLAYER
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
 IF RESULT=TRUE THEN ONT2
 MESSAGE 1011 ; Can't see any ..
 x1=object
 GOSUB @descobjx1a ;>>mike 8/9/96
 message 1005 ; here.
 return

.ONT2
 IF VERB=ISTAND THEN ONTDROPFIRST
 MESSAGE 1013 ; Already have ..
 GOTO ONTERROR

.ONTDROPFIRST
 MESSAGE 1126 ; have to drop it first
 RETURN
;---
.PARSEINPUT
; CONVERT INPUT TO VERB, PREP, OBJECT FORM FOR
; EASY UNDERSTANDING BY THE REST OF THE PROGRAM
 HAVECALLEDVERB=FALSE
 GOSUB @GETNEXTWORD
 VERB=0
 IF EOL=TRUE THEN @PIRET; NOTHING ENTERED !
 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 IF VALUE<>0 THEN PI0

 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPE
 IF VALUE>IGARBAGE THEN PARSEINPUT ; CONJUNCTION ENTERED, SO TRY AGAIN
 GOTO @PARSENOVERB ; Wrong type of word found
.PI0
 IF VALUE<>IAGAIN THEN PI0A
 VERB=AGAINVERB
 IF LASTVERBVALID=TRUE THEN @PIRET
 M1=1050 ; last verb not valid
 GOSUB @VARYMESSAGE
 GOTO @CANCELINPUT

.PI0A
 VERB=VALUE
 AGAINVERB=VERB

.VERBPLUS
 OBJECTTABLE(C0)=C0
 OBJECTTABLE(C1)=C0
 EVERYTHING=FALSE ; EVERYTHING NOT DETECTED YET
 EXCEPT=FALSE ; EXCEPT NOT DETECTED YET
 PREP=0
 NOUN1=NULLOBJECT ; NEEDED ?
 NOUN2=NULLOBJECT
 INUMBER=NULLNUMBER
 VERBSTOCALL=0
 LASTVERBVALID=FALSE

 IF VERB<ICROSS THEN PIRET

; VERB MAY BE FOLLOWED BY SOMETHING ELSE
 GOSUB @CONVERTVERB
 GOSUB @SELECTOBJECTPOS

.PINEXT
.PIANOTHERNOUN
 GOSUB @GETNEXTWORD

 IF SEPARATOR=TRUE THEN PINEXT
 IF EOL=TRUE THEN PIRET
.PINEXT1

 IF VERB=ISAY THEN @SAY

 IF VERB=IDROP THEN PINOTPREP ; DROP BENCH AND ON
 SEARCHTYPE=PREPTYPE
 GOSUB @CHECKTYPE
 IF VALUE<>0 THEN PIPREP

.PINOTPREP
 GOSUB @CHECKNOUN
 IF OBJECT<>0 THEN PIEXAMINENOUN
 IF PROCESSED=TRUE THEN PINEXT

 SEARCHTYPE=ASCITYPE
 GOSUB @CHECKTYPE
 IF VALUE=ICOMMA THEN PINEXT
 IF VALUE<>0 THEN PINEXT ; **** CHANGED 04/11/85 21:40 - WAS PIRET

 SEARCHTYPE=NUMBTYPE
 GOSUB @CHECKTYPE
 IF VALUE=0 THEN PINOTNUMBER
 INUMBER=VALUE
 ITNUMBER=INUMBER
 OBJECT=BUTTONS
 ADD VERBSTOCALL,C1
 GOTO PINEXT

.PINOTNUMBER
; ANYTHING ELSE (CONJ, VERBS ETC.) TERMINATE THIS SENTENCE
 GOSUB @GOBACK ; STORE (VERB?) FOR FUTURE ANALYSIS
.PIRET
 RETURN
 
.PIPREP
 IF PREP<>0 THEN @SECONDPREP ; GOT A SECOND PREP
 PREP=VALUE
 GOSUB @CONVERTVERB
 GOSUB @SELECTOBJECTPOS
 GOTO PINEXT

.PIEXAMINENOUN
 IF OBJECT<>IIT THEN PINOTIT
 OBJECT=ITWORD
 INUMBER=ITNUMBER

.PINOTIT
 IF PREP<>0 THEN @PINOUN2
 IF OBJECT=IEVERYTHING THEN PIEVERYTHING
 IF OBJECT=IEXCEPT THEN @PIEXCEPT
; GOT AN ORDINARY NOUN SPECIFIED
 ITWORD=OBJECT
 ITNUMBER=NULLNUMBER
 IF OBJECT<NUMBEROFFSET THEN PION0
 IF OBJECT>HINUMBEROFFSET THEN PION0
 GOTO @PINEXT
;
.PION0
 X1=NOUNFORBIDDEN ; mark noun as forbidden
 IF EXCEPT=TRUE THEN PIMARK ; DON'T CHECK IT'S HERE (YET)
; mark ordinary noun
 X1=NOUNSPECIFIED
.PIMARK
 GOSUB MARKOBJECT ; MARK NOUN AS SPECIFICALLY REQUESTED
 GOTO @PINEXT
;
.PIEVERYTHING
 EVERYTHING=TRUE
 GOTO @PINEXT

;---
.STRIPX1
; STRIP OFF TOP TWO BITS OF X1.
 IF X1<64 THEN STRIPX1RET
 X2=64
 SUB X1,X2
 GOTO STRIPX1
.STRIPX1RET
 RETURN
;---
.CIASCENERY
; OBJECT IS>MAXOBJECT, SO IF IT IS IN A ROOM DESCRIPTION,
; SEE IF IT IS THE RIGHT ROOM
 X1=NOUNOFFSET
 ADD X1,OBJECT
 IF X1>999 THEN RETURNTRUE ; >1000, so a random output message
 X2=ROOMDESCS
 SUB X1,X2
 IF X1<>ROOM THEN RETURNFALSE
; drop through to return TRUE
.RETURNTRUE
 RESULT=TRUE
 RETURN
.RETURNFALSE
 RESULT=FALSE
 RETURN
;---
.MARKOBJECT
; mark object as X1
 if object>170 then markobjret ;>>mike 27/10/86
 X2=OBJECTTABLE(C0)
 IF X2=0 THEN MARKOBJ1
 IF X1<>X2 THEN @DONTUNDERSTAND ; have had both mark and prevent types
.MARKOBJ1
 X2=1
.MARKOBJ2
 X3=OBJECTTABLE(X2)
 IF X3=OBJECT THEN MARKOBJRET ; already marked
 IF X3=0 THEN MARKOBJ3
 ADD X2,C1
 GOTO MARKOBJ2

.MARKOBJ3
 IF X2>15 THEN @DONTUNDERSTAND  ; OBJECTTABLE OVERFLOW
 ADD VERBSTOCALL,C1
 OBJECTTABLE(C0)=X1
 OBJECTTABLE(X2)=OBJECT
 ADD X2,C1
 OBJECTTABLE(X2)=C0
.MARKOBJRET
 RETURN
;---
.CHECKIFFORBIDDEN
 RESULT=FALSE
 X1=OBJECTTABLE(C0)
 IF X1<>NOUNFORBIDDEN THEN CIFRET
 X2=1
.CIF1
 X1=OBJECTTABLE(X2)
 ADD X2,C1
 IF X1=0 THEN CIFRET
 IF X1<>OBJECT THEN CIF1
 RESULT=TRUE
.CIFRET
 RETURN
;---
.SCENERY
; Have got a noun which is in a room description or similar,
; so it is just scenery. Print an appropriate message.
 HAVECALLEDVERB=TRUE
; x1=objecttable(0) ;>>mike 25/10/86
; if x1<>0 then zeroobjectsceneryend ;>>mike 25/10/86 - already got
;; a valid object

;>>mike 8/9/86 PRINTINPUT
;>>mike 8/9/86 MESSAGE COLON

; printinput ;*********8
; message colon ;********88
 if alreadyprintedscenery=true then sceneryend ;>>mike 25/10/86
 alreadyprintedscenery=true ;>>mike 25/10/86

 GOSUB @FUNNIES ; Print out any special messages
 IF RESULT=TRUE THEN zeroobjectSCENERYEND

 M1=1030 ; just scenery group
 GOSUB @VARYMESSAGE
.zeroobjectsceneryend
 object=0 ;>>mike 25/10/86
.SCENERYEND
.SCENERYRET
 RETURN
;---

.PIEXCEPT
 EXCEPT=TRUE
 GOTO @PINEXT

.PINOUN2
; another noun in input, not part of any multiple noun
 IF NOUN2<>NULLOBJECT THEN @DONTUNDERSTAND
;
; ?? May want to change HISEARCHPOS so
; ?? as to give required position to the object
;
 NOUN2=OBJECT
 GOTO @PINEXT
;---

.CHECKTYPE
; SEE IF THERE IS A WORD OF WORDTYPE 'SEARCHTYPE' IN CURRENT WORD
; IF NOT, RETURN VALUE=0
; IF THERE IS RETURN ITS WORD NUMBER IN VALUE
 INDEX=0
.CHECKTYPEMORE
 GOSUB @READINPUTLIST
 IF WORDTYPE<>NUMBTYPE THEN CTNOTNUMBER
 ADD INDEX,C2 ; numbers are 4 byte values

.CTNOTNUMBER
 ADD INDEX,C2
 IF VALUE=0 THEN CHECKTYPERET
 SOMETHINGPROCESSED=TRUE
 IF WORDTYPE<>SEARCHTYPE THEN CHECKTYPEMORE
 IF WORDTYPE<>NOUNTYPE THEN CHECKTYPERET
 IF VALUE<470 THEN CHECKTYPERET
 IF VALUE>699 THEN CHECKTYPERET
; an examine message
 X1=470
 SUB VALUE,X1

.CHECKTYPERET
 RETURN
;---
.CHECKNOUN
; check if noun 'OBJECT' is present
; finding possible alternatives if it isn't. Return RESULT=TRUE if found
 PROCESSED=TRUE
 SEARCHTYPE=NOUNTYPE
 INDEX=0
 GOSUB CHECKTYPE
 OBJECT=0
.CHECKNOUN0
 IF VALUE>IGARBAGE THEN CNGARBAGE
 IF VALUE>3600 THEN CNNOTCLEAR ; a saying or garbage word
 OBJECT=VALUE
 GOSUB @CHECKIFACCESSIBLE
 IF RESULT=TRUE THEN CHECKNOUNEND ; if present, accept as is
 GOSUB CHECKTYPEMORE
 IF VALUE<>0 THEN CHECKNOUN0

.CNNOTCLEAR
 IF OBJECT>MAXOBJECT THEN CNNOTCLEAR1
 IF OBJECT=0 THEN CHECKNNORMAL ; not a noun
 GOSUB @OBJECTNOTHERE
 HAVECALLEDVERB=TRUE
.CNGARBAGE
 RESULT=FALSE
 OBJECT=0
 RETURN

.CNNOTCLEAR1
; OBJECT>MAXOBJECT, see if it is valid
 IF OBJECT=IEVERYTHING THEN CHECKNNORMAL
 IF OBJECT=IIT THEN CHECKNNORMAL
 IF OBJECT=IEXCEPT THEN CHECKNNORMAL
 GOTO @NOTCLEAR

.CHECKNOUNEND
 IF OBJECT>MAXOBJECT THEN @SCENERY
.CHECKNNORMAL
 PROCESSED=FALSE
 RETURN
;---
.CLEARINPUT
; called after any errors - remove rest of input from line
 INDEX=0
 GOSUB @READINPUTLIST
 IF VALUE=0 THEN CLEARINPEND
 if nomoreinput=true then clearinpend
 SUPRESSCHECKING=TRUE ; don't check words for validity
 GOSUB GETNEXTWORD
 GOTO CLEARINPUT
.CLEARINPEND
 SUPRESSCHECKING=FALSE
 RETURN
;---
.GETNEXTWORD
; GET NEXT WORD IN LINPUT
; set EOL=TRUE if get ".", eol, etc.
; Set SEPARATOR=TRUE if get "." ","
 IF NOMOREINPUT=TRUE THEN GNWEND
 IF WORDNOTPROCESSED=TRUE THEN GNWEND ; HAVE USED GOBACK TO RETRIEVE
 INPUT X1 X1 X1 X1
 SEARCHTYPE=ASCITYPE ;** NEW CODE 5/11/85
 GOSUB @CHECKTYPE ; ** NEW CODE 5/11/85
 IF VALUE<33 THEN GNW1
 IF VALUE<38 THEN GETNEXTWORD ;** NEW CODE 5/11/85
.GNW1
 GOSUB CHECKEOL ; CHECK FOR "." "THEN" etc.
.GNWEND
 WORDNOTPROCESSED=FALSE
.CIGRET
 RETURN
;---
.CHECKEOL
 INDEX=0
 GOSUB READINPUTLIST
 SEPARATOR=FALSE
 EOL=FALSE
 IF VALUE=0 THEN SETNOTHINGMORE
 SEARCHTYPE=CONJTYPE
 GOSUB @CHECKTYPE
 IF VALUE=ITHEN THEN SETEOL
 SEARCHTYPE=ASCITYPE
 GOSUB @CHECKTYPE
 IF SUPRESSCHECKING=TRUE THEN CHECKEOL1
 IF VALUE=128 THEN @PARSENOTKNOWN ; WORD NOT UNDERSTOOD
.CHECKEOL1
 IF VALUE=ICOMMA THEN SETSEPARATOR
 IF VALUE=IDOT THEN SETEOL
 RETURN
.SETSEPARATOR
 SEPARATOR=TRUE
 GOTO SETEOL

.SETNOTHINGMORE
; There is no more input to come on this line
 NOMOREINPUT=TRUE
.SETEOL
 EOL=TRUE
 RETURN
;---
.GOBACK
; MARK CURRENT WORD AS UNPROCESSED, SO A SUBSEQUENT INPUT ROUTINE
; CAN GET A CHANCE AT READING IT
 INDEX=0
 GOSUB READINPUTLIST
 IF VALUE=0 THEN GOBACKRET
 WORDNOTPROCESSED=TRUE
.GOBACKRET
 RETURN
;---
.READINPUTLIST
 ; VALUE:=@INPUT(INDEX) 16 BIT. X1,X2 corrupted
 VALUE=LINPUT(INDEX)
 IF VALUE<>1 THEN RILNOTNUMBER
 WORDTYPE=NUMBTYPE
 X1=INDEX
 ADD X1,C1
 VALUE=LINPUT(X1) ; returns low order of number
 RETURN

.RILNOTNUMBER
 WORDTYPE=VALUE
; STRIP OFF TOP THREE ( WORDTYPE ) BITS
 X1=32
.RIL1
 IF VALUE<32 THEN RIL2
 SUB VALUE,X1
 GOTO RIL1
.RIL2
 GOSUB VALUETIMES255
 X1=1
 ADD X1,INDEX
 X2=LINPUT(X1)
 ADD VALUE,X2
; Separate out WORDTYPE = top three bits
 X2=WORDTYPE
 WORDTYPE=ASCITYPE
 X1=ASCIOFFSET
 IF X2<32 THEN RILRET
 WORDTYPE=VERBTYPE
 X1=VERBOFFSET
 IF X2<64 THEN RILRET
 WORDTYPE=CONJTYPE
 X1=CONJOFFSET
 IF X2<96 THEN RILRET
 WORDTYPE=PREPTYPE
 X1=PREPOFFSET
 IF X2<128 THEN RILRET
 WORDTYPE=NOUNTYPE
 X1=NOUNOFFSET
 IF X2<160 THEN RILRET
 WORDTYPE=ADJETYPE
 X1=ADJEOFFSET
 IF X2<192 THEN RILRET
 WORDTYPE=matchTYPE
 X1=matchOFFSET
 IF X2<224 THEN RILRET
 WORDTYPE=7
 X1=0
.RILRET
 SUB VALUE,X1 ; SUBTRACT OFFSET
 IF VALUE>60000 THEN RILRET1
 RETURN
.RILRET1
 VALUE=0
 RETURN
;---
.VALUETIMES255
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 RETURN
;---
.CHECKIFLIGHT
 RESULT=TRUE
 RETURN
;---
.CHECKOBJECTPOS
; Return RESULT=TRUE if 'OBJECT' is
; at 'HIPOS', 'POS'
; if POS=0, it is treated as NONSPECIFIC
; likewise, HIPOS=NONSPECIFIC is handled
; return X4=lo position of object (or object if on ground)
 X4=OBJECT
.COP1
 IF POS=0 THEN COPHI
 X1=CURRENTPOS(X4)
 IF X1<>POS THEN COPNOTYET
.COPHI
; lo address is same, now check hi address
 X1=HICURRENTPOS(X4)
 IF X1=0 THEN COPHI1
 IF HIPOS=NONSPECIFIC THEN COPFOUND ; provided object is contained
.COPHI1
 IF X1<>HIPOS THEN COPNOTYET
.COPFOUND
 RESULT=TRUE
 RETURN
.COPNOTFOUND
 RESULT=FALSE
 RETURN
;
.COPNOTYET
 X1=HICURRENTPOS(X4)
 IF X1=0 THEN COPNOTFOUND
 X4=CURRENTPOS(X4)
 GOTO COP1
;---
;----------------------------------------------------------------
;----------------------------------------------------------
