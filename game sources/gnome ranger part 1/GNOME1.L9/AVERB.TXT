; Gnome Ranger source, copyright (C) 1987 Level 9 Computing.
;
; AVERB.TXT, fairly standard code to handle ordinary verbs (there 
; is no point in writing code to handle movement; get/drop; examine
; etc. etc. afresh for each game.) You will need to make some changes, 
; adding new verbs and those special cases which can't go elsewhere, 
; and possibly removing verbs, e.g the combat routines if your game 
; is non-violent.
;
BEGIN
;
; Start of game, transferred here directly from APARSE. 
;
.normalSTARTGAME
;.INITALL
; Because adventures typically consist of several programs, which can 
; load each other by means of the 'chain' driver call, we can't just 
; start by initialising everything in sight. If nothing else, this 
; would destroy all the evidence as to whether the game had just been 
; started, or whether the player had merely returned to this part in 
; order to complete a puzzle. However, we must do some neccessary 
; initialisation. Coping with this situation is very tricky indeed, 
; and we advise you to keep your hands off. 
; if thisgame<>GnomeRanger then notchained
; if parttochain<>constantpartnum then notchained
; if thispart=1 then notchained
;; must have loaded a saved pos which caused
;; this part to be chained in.
; thispart=parttochain
; message space
; message cr
; goto @afterrestore
;
;.notchained
; CLEAR ; clears all variables
; x1=0
 c1=1
.clearall
; some of the table cleared here is also cleared by initnpc
 currentpos(x1)=c0 ; must be done else OBJECTTRIGGER fails for OBJECT=0
 add x1,c1
 if x1<npctablesizetozero then clearall
 MESSAGE 2100 ; welcome to game
; initialise some variables which retain their values throughout
; the game
 thisgame=GnomeRanger
 thispart=constantpartnum
 C1=1
 C2=2
 C3=3
 c6=6
 c8=8
 C10=10
;
 ITWORD=NULLOBJECT ; first object seen
 ITNUMBER=NULLNUMBER
 NOMOREINPUT=TRUE ; have come to end of input line
; CARRYCAPACITY=NORMALCAPACITY
 GOSUB @INITOBJECTS
;>>> gosub randomizetreasure
 gosub @initnpcs
 HOUR=10
 day=1
 minute=20
 SOMETHINGPROCESSED=TRUE ; force printing of WHAT NEXT ?
 NORMALDESCRIPTIONMODE=IVERBOSE
 OOPSPOS=1
 vandalptr=vandalbase
;
 gosub @initlocations

; now set up variables as pointers to starts
; within segmented lists
 value=list5(0)
 gosub @valuetimes256
 x1=list5(1)
 add value,x1
 startfloorpointers=value

 value=list5(2)
 gosub @valuetimes256
 x1=list5(3)
 add value,x1
 startracetracks=value

 value=list5(4)
 gosub @valuetimes256
 x1=list5(5)
 add value,x1
 startreversaltable=value
; set up initial racetrack commands for npcs
; which have them
 actor=1
.initracetrack1
; now find pointer to initial racetrack for actor:
 add actor,c1
 x1=actor ; number of racetrack to activate
 gosub @initracetrackx1
 if actor<maxnpcplus1 then initracetrack1

 actor=user
 gosub @setuproom
 message BlankLine
 gosub @PrintRoom
;; initialscene=1
 GOTO @CANCELINPUT
;---
.unfasten
.unfastentake
 verb=itake

.GET
.TAKE
; Check for prepositions e.g. GET ON, GET OFF
 IF PREP<>0 THEN TAKEFROM
.TAKEIT
 POS=ACTOR
 HIPOS=CARRIED
 GOTO @MOVEOBJECT
;
.TAKEFROM
; got a preposition e.g. TAKE noun FROM ; or TAKE noun IN etc.
 OBJECT=NOUN1
 POS=NOUN2
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
; OBJECT=NOUN1 here
 IF RESULT=FALSE THEN @ITSNOTTHERE
 GOTO TAKEIT
;---

.STAND
 lastpossibleverb=0 ; prevent prep being parsed as a verb
 nextverb=0
 IF PREP=ON THEN STANDON
 IF PREP=OFF THEN STANDOFF
 IF PREP=UP THEN STANDUP
 IF PREP=IPIN THEN STANDIN
 IF PREP=IPOUT THEN STANDOUT
 GOTO @DONTUNDERSTAND
;---
.STANDOFF
.STANDOUT ; get out (e.g. of boat)
.STANDUP
 X1=HICURRENTPOS(ACTOR)
 IF X1=0 THEN @SILLY
 currentpos(actor)=ROOM
 hicurrentpos(actor)=c0
 goto @done
;
.BOARD ; e.g. boat
; PREP=ON

.STANDON
.STANDIN
; HIDEST=PREP ; ON, IN ETC.
; GOTO silly
;---
.LIE
; HIDEST=LIEON
; GOTO silly
;---
.SIT
; HIDEST=SITON
 goto @silly
;---
.STANDOK
 gosub @printACTORactiondot
 PROCESSED=TRUE
 HIDEST=PREP
 DEST=OBJECT
 GOTO @NEWLOCATION
;---
.attackpreventm1dot
 goto @smpreventm1dot
;---
.ATTACK
 commandfinished=true ; always terminates immediately in gnome
 if noun1=iroom then @vandal

 if noun1=shopdoor then @knock
 if noun1=knocker then @knock

 m1=2698 ; the windows were barred
 if noun1=window then attackpreventm1Dot

 m1=2517 ; shutters barred
 if noun1=shutters then attackpreventm1dot

 m1=2514 ; attack, but centaur fends off Ingrid's blows
 if noun1=centaur then attackpreventm1dot

 m1=2678 ; the gate was unbbject=eagle
 goto @makeobjectobedient

.AttackNotChicks
 if noun1<>witch then AttackNotWitch
 m1=2715 ; the witch seemed unconcerned by 
 gosub @printm1dot
 gosub @printActor
 m1=2716 ; 's blows
 goto @printm1dot

.AttackNotWitch
 if noun1<>wand then AttackNotWand
 if actor=leprecaun then LeprecaunBreaksWand
 gosub @printactor
 m1=2761 ; touched the wand and turnedtostone
 gosub @printm1dot
 goto @actordeath

.LeprecaunBreaksWand
 forceprinting=1
 gosub @printactor ; has to be after forbject=eagle
 goto @makeobjectobedient

.AttackNotChicks
 if noun1<>witch then AttackNotWitch
 m1=2715 ; the witch seemed unconcerned by 
 gosub @printm1dot
 gosub @printActor
 m1=2716 ; 's blows
 goto @printm1dot

.AttackNotWitch
 if noun1<>wand then AttackNotWand
 if actor=leprecaun then LeprecaunBreaksWand
 gosub @printactor
 m1=2761 ; touched the wand and turnedtostone
 gosub @printm1dot
 goto @actordeath

.LeprecaunBreaksWand
 forceprinting=1
 gosub @printactor ; has to be after forceprinting statement
 wandBroken=80
 m1=2717 ; win
 gosub @printM1 ; not dot!!!
 goto @win

.AttackNotWand
 if noun1<>generaldoor then AttackNotDoor
 if room=3 then cantbreakDoor
 if room<>7 then CantBreakDoor
; unicorn CAN break back door
.AttackBackDoor
 if actor<>unicorn then CantBreakDoor

;** object=witch
;** x6=18 ; summon witch to back door
;** gosub NewRaceTrackForObject
;** actor=unicorn

 BackDoorBroken=true
 gosub @printActor
 doorOpen=true
 m1=2699 ; broke down the back door
 goto @printm1dot

.cantBreakDoor
 m1=2711 ; the door was too strong for
 gosub @printm1 ; no dot
 gosub @printActor
 m1=2712 ; to break
 gosub @printM1Dot
 goto @smprevent ; called from SPecialMoves as well as ATTACK

.AttackNotDoor
;; target=noun1
;; if noun1>maxnpc then atnpc ; assumes nullobject=255
;; if noun2<minweapon then @silly
;; if noun2=nullobject then attackchoose
;; if noun2>maxweapon then @silly
;; weapon=noun2
;; goto @generalblow
;;;
;;.attackchoose
;; GOSUB @CHOOSEBESTWEAPON
;; GOTO @GENERALBLOW
;;;
;;.ATNPC
 if noun1<minsceneryobj then atnsceneryobject
 if noun1<maxsceneryobjplus1 then @vandal
;
.atnsceneryobject
.collect
.become
.WAKE
.WASTEOFTIME
 IF ACTOR<>USER THEN @NPCNOTUNDERSTOOD
 M1=3160 ; don't bother group
 GOTO @VARYMESSAGEDOT
;---
.PUT
 IF NOUN1=NULLOBJECT THEN @CANTSEEWHAT
 IF NOUN2=NULLOBJECT THEN @CANTSEEWHERE
 OBJECT=NOUN1

 IF PREP=ON THEN PUTON
 IF PREP=UNDER THEN PUTUNDER
 IF PREP=IN THEN PUTIN
 if prep=through then putin

.CANTPUTTHERE
;; if actor<>user then cptret
 gosub @actorcantverbnoun1 ; can't put that
 m1=2124              ; there
 goto @printM1dot
;---
.PUTON
; CHECK IF DESTINATION CAN HAVE things put on top of it
 goto cantputthere
;
.PUTOK
 OBJECT=NOUN1
 GOTO MOVEOBJECTPrepNoun2

.PUTIN
 if noun2=backpack then putok
 if object<>letter then pinotenvelope
 if noun2=envelope then moveobjectPrepNoun2

.pinotenvelope
.objectwontfit
 GOTO CANTPUTTHERE

.putunder
 if noun2<>rock then cantputthere
 if actorHoldingRock=false then cantputthere
 if ActorHoldingRock=actor then @StRockStupidity ; have to drop rock
 goto moveobjectPrepNoun2
;---
.ISOBJECTMOVEABLE
; return RESULT=TRUE if OBJECT can be moved
 if object>maxmoveable then @returnfalse
 if object<maxNpcPlus1 then @returnfalse
 result=TRUE
.IOMRET
.cptret
 RETURN
;---
.MoveObjectPrepNoun2

; Super routine for moving objects about. E.g, putting something inside 
; a bag. Or removing it. It differs from "NEWLOCATION", which is concerned 
; with walking-about-type-movement, primarily in the way that the action 
; is reported. MOVEOBJECT validates the movement before carrying it out.
.MOVEOBJECT
; Move 'OBJECT' to 'POS', 'HIPOS'
; Return RESULT=TRUE if move was successful
 GOSUB ISOBJECTMOVEABLE
 IF RESULT=FALSE THEN @IMMOVABLE
; is the contents already contained by the container (or V-V) ?
 GOSUB @CHECKIFCONTAINED
;
 IF HIPOS=0 THEN MONOTACTOR
; ACTOR to gain this object, check if is able to carry it
; actually this code is now used whenever an object
; goes to a position not on the ground. This
; is to catch people trying to avoid SPECIALTAKES
 IF HIPOS<>WORN THEN MOVEOBJ1
; is it wearable ?
 IF OBJECT<minclothes THEN @cantwear
 if object>maxclothes then @cantwear

.MOVEOBJ1
; Now check if the ACTOR is standing on it or some similar problem
 OBJECTSAVE=OBJECT
 DEST=POS ; save value
 HIDEST=HIPOS ; save it
;
 POS=OBJECT
 HIPOS=NONSPECIFIC
 OBJECT=ACTOR
 GOSUB @CHECKOBJECTPOS
;
 OBJECT=OBJECTSAVE
 POS=DEST ; restore value
 HIPOS=HIDEST ; restore value
 IF RESULT=TRUE THEN @MOVEOBJFAIL
 GOSUB @SPECIALTAKES ; game-specific take messages
 IF RESULT=FALSE THEN @MOVEOBJRET
;
.MONOTACTOR
 X1=CURRENTPOS(OBJECT)
 IF X1<>ACTOR THEN MMNOTLOSE
 X1=HICURRENTPOS(OBJECT)
 IF X1=0 THEN MMNOTLOSE
; ACTOR is to lose object
 IF X1<>WORN THEN MMLOSENOTWORN
; ACTOR is wearing object, if it was specified using EVERYTHING,
; then don't drop it as this could cause embarrasment
 IF noun1isgd=FALSE THEN MMLOSENOTWORNPOS>MAXNPC THEN MONTONPC
; code here is to avoid NPCs having things put on them etc.
; or the statue / bloodworm / bat being given things
; no special cases for giving to NPC, so make it carry it
 IF HIPOS=WORN THEN MONTONPC ; unless it is going to wear it
 HIPOS=CARRIED

.MONTONPC

 FROM=CURRENTPOS(OBJECT)
 HIFROM=HICURRENTPOS(OBJECT)
 CURRENTPOS(OBJECT)=POS
 HICURRENTPOS(OBJECT)=HIPOS
;
; now decribe the move
;
; show ACTOR doing something
; verb is set up
 if verb=ithrow then monodesc
POS>MAXNPC THEN MONTONPC
; code here is to avoid NPCs having things put on them etc.
; or the statue / bloodworm / bat being given things
; no special cases for giving to NPC, so make it carry it
 IF HIPOS=WORN THEN MONTONPC ; unless it is going to wear it
 HIPOS=CARRIED

.MONTONPC

 FROM=CURRENTPOS(OBJECT)
 HIFROM=HICURRENTPOS(OBJECT)
 CURRENTPOS(OBJECT)=POS
 HICURRENTPOS(OBJECT)=HIPOS
;
; now decribe the move
;
; show ACTOR doing something
; verb is set up
 if verb=ithrow then monodesc
 objectsave=object
 gosub @printACTORactiondot
 object=objectsave

.monodesc
 gosub @specialaftermoveobj
 goto @returnTRUE ; move went just fine!

.MOVEOBJFAIL
 M1=2131 ;  you're on it
 gosub @errorm1

.MOPREVENT
 RESULT=FALSE
.moveobjret
 RETURN
;---
.SCORE
 MESSAGE 2240 ; you score
 
.PRINTSCORE
 X4=0
 add x4,dogSwarmObedient
 add x4,EagleObedient
 add x4,LeprecaunObedient
 add x4,NymphObedient
 add x4,UnicornObedient

 add x4,WandBroken
 add x4,EnvelopeOpened
 IF X4<30000 THEN SCORE1 ; failsafe test to prevent negative score
 X4=0
.SCORE1
 part1score=x4
 PRINT X4 ; score
 M1=2249 ; message below lowest rating
 X1=100 ; size of score categories (max score, 1000, has unique rating)
.SCORE2
 SUB X4,X1
 ADD M1,C1
 IF X4<NEGATIVE THEN SCORE2
 MESSAGE 2242 ; out of 1000 and are a 
 goto @printM1dot ; rating
;---
.POSITIONSHADOWS
; Make objects follow the ACTOR around where applicable. e.g. DOORS.
; and other objects which are in several places at once. 
 RETURN
;---
.FASTEN
; NOUN1 TO NOUN2
 GOTO @actorcantverbnoun1dot
;---
;.untiefirst
; m1=2158 ; must untie it first
; goto @printM1dot
;---
; Move something/someone to a new location in the game, reporting the 
; movement with messages such as 'X enters from the north'.
.NEWLOCATION
; Given FROM=old location, HI,DEST=new location
; and DIR=direction,
; print any messages which appear on moving through doors etc.
; GOSUB SETUPROOM
 FROM=ROOM
 GOSUB @SPECIALMOVES
 blockedbysm=TRUE
 IF RESULT=FALSE THEN NLRET
 if actor<>user then newmoveNotUser
 gosub @SaveOops

.newmoveNotUser
 blockedbysm=FALSE
;
.ABSNEWLOCATION
; as for newlocation, but don't do any checking for special
; case code. Use this routine where the move is forced, so
; don't want to trip any movement traps
 FROM=ROOM
; describe door closing (if there is one)
 IF HIDEST<>0 THEN ANL2 ; skip checks for moving into container
 GOSUB @CHECKEXIT
 gosub printleaving
;
.ANL2
 LASTROOM=ROOM
 CURRENTPOS(ACTOR)=DEST
 HICURRENTPOS(ACTOR)=HIDEST
 gosub @closedoor
 roomsave=ROOM
 gosub @setuproom
 gosub printarrival
; no messages printed between printarrival and printroom please
.NLEND
 IF ACTOR<>user THEN @AFTERMOVE ; npc doesn't want description
 timeinroom=0
 GOSUB @printROOM
 GOTO @AFTERMOVE
;---
.printLEAVING
 if descriptionmode=inone then dlret
 verb=istruggle
 if dir=iclimb then dl1
 verb=58 ; go
.dl1
 gosub @isactorflying
 if result=false then dl2
 verb=163 ; flew

.dl2
 gosub @printACTORverb ; the npc goes
.printdirectionanddoor
 m1=verboffset ; north-1
 add m1,dir
 gosub @printM1 ; direction
 gosub printdoor
 if actor<>user then @printDOT ; print a dot and terminate
 wanttoprintand=user ; followed immediately by description
.desclret
.nlret
 return
;---
.printdoor
 IF DOOR=FALSE THEN DESCLret
 M1=2115 ; through the door
 goto @printM1
;---
.printARRIVAL
; first print description of object
 if descriptionmode=inone then desclret
 IF actor=user then DESCLRET ; for startup
 verb=iENTER 

 gosub @isactorFlying
 if result=false then pa2
 verb=163 ; flew

.pa2
 object=actor
 gosub @printANobjectVERB ; the npc enters...
 m1=584
 add m1,dir
 gosub @printM1
 gosub printdoor
 goto @printdot
;---
.ANLRET
.dlret
 RETURN
;---
.TICKCLOCK
; add on time a minute at a time
.TCADDMINUTES
 GOSUB @TIMEDEPENDENTCODE
 add timeinroom,c1
.TCRET
.waitret
.OPENDOORRET
.SAYRET
.OPENRET
.throwret
.abnret
 RETURN
;---
.PULL
.PUSH
 if noun1=bridle then @take
 GOTO @IMMOVABLE
;---
.OPEN
 m1=2685 ; inside, so can't
 if object=144 then @printm1dot ; gate inside witch's garden
 m1=2679 ; if you really want to go in, just say so
 if object=gate then @printm1dot

.OpenNotGate
 if object=shutters then openshop
 if object<>shopdoor then opennotshop
.openshop
 if actor<>centaur then openshopnotcentaur
 ShopOpen=true
 if currentuserroom<>116 then openret ; check user is around to see.
 m1=2518 ; centaur opens shop from inside
; if room=9 then openshopm1
; m1=2519 ; centaur ope windows were barred
 if object=window then @printM1Dot

 if object<>kennel then openNotKennel
 x1=currentpos(peg)
 if x1<>kennel then AlreadyOpen
 verb=itake
 object=peg
 noun1=peg
 goto @take

.openNotKennel
 IF OBJECT<>GENERALDOOR THEN @actorcantverbnoun1dot

.OPEN1
 if room=7 then cantopendoor ; back door of cottage
 if room=3 then cantopendoor ; front door of cottage

 IF DOOROPEN=TRUE THEN ALREADYOPEN
.opendoor
 DOOROPEN=TRUE
 goto @printACTORactiondot


.cantopendoor
 gosub @ windows were barred
 if object=window then @printM1Dot

 if object<>kennel then openNotKennel
 x1=currentpos(peg)
 if x1<>kennel then AlreadyOpen
 verb=itake
 object=peg
 noun1=peg
 goto @take

.openNotKennel
 IF OBJECT<>GENERALDOOR THEN @actorcantverbnoun1dot

.OPEN1
 if room=7 then cantopendoor ; back door of cottage
 if room=3 then cantopendoor ; front door of cottage

 IF DOOROPEN=TRUE THEN ALREADYOPEN
.opendoor
 DOOROPEN=TRUE
 goto @printACTORactiondot


.cantopendoor
 gosub @printactor
 m1=2710 ; door bolted from inside
 goto @printm1dot
;---
.DONTNEEDTODOTHAT
 m1=2148 ; you don't need to do that
 goto @errorM1dot
;---
.ALREADYOPEN
 M1=2117 ; already open
 GOTO @errorM1dot
;---
.GIVE
 pos=room
 hipos=0
 if noun2=centaur then @moveobject

 HIPOS=CARRIED
 IF NOUN2=USER THEN GIVENPC
 IF NOUN2<minnpc THEN NOBODYWANTSIT
 IF NOUN2<maxnpcplus1 THEN GIVENPC
 goto nobodywantsit
; IF NOUN2<>NULLOBJECT THEN NOBODYWANTSIT
; GOSUB @ANYBODYHERE
; IF OBJECT=NULLOBJECT THEN NOBODYWANTSIT
; NOUN2=OBJECT
; GOTO GIVENPC
;---
.NOBODYWANTSIT
 M1=2172 ; nobody wants it
 GOTO @ERRORM1dot
;---
.GIVENPC
; giving NOUN1 to NPC NOUN2
 IF NOUN2=NULLOBJECT THEN NOBODYWANTSIT
 OBJECT=NOUN1
 pos=noun2
 GOSUB @MOVEOBJECT
 goto @specialaftergive
;---
.THROW
 if noun2=nullobject then @drop
; drop the object...
 pos=room ;** could probably do 'VERB=IDROP, GOTO DROP'
 hipos=0
 gosub @moveobject
 if result=FALSE then @throwret ; not possible
;; if noun2<minnpc then thrownotnpc
;; if noun2>maxnpc then thrownotnpc
;; throw something at someone - so treat as aggressive
;; object=noun1 here
;; gosub ithits ; print what happens
;; blowstrength=1
;; target=noun2
;; gosub makeenemies
;; goto dodamage
;;
;;.thrownotnpc
;; drop through to ithits
.ithits
 verb=ihit
;; object=noun1
 gosub @printOBJECTverb ; prints 'the object hits'
 object=noun2
 gosub @printTHEobject2 ; print out him etc.
 goto @printdot
;---
.CHECKIFLIGHT
; Return RESULT=TRUE if room is illuminated
; (either naturally or by objects etc.)
 goto @returntrue
;---
.BRIEF
.VERBOSE
 NORMALDESCRIPTIONMODE=VERB
 GOTO @DONE
;---
.immovable
 if actor<>user then @actorcantverbnoun1dot
 gosub @printTheObject
 m1=3150 ; won't move
 goto @varyERRORM1dot
;
.cut
.squeeze
.badobject
.cantwear
 goto @actorcantverbnoun1dot
;---
.initlocations
; go through and place the special locations in
; appropriate pseudo-random locations..
.drret
 return
;-----------------------------
.shortdesc ; print the short description for ROOM
 if room<minsynthroomminus1 then descstaticroom
 gosub @convertroom ; is there a special feature here?
 if x1=0 then drsynthesised
; x1 is room number in special rooms i.e. 1..24
 picturetodraw=x1
 x2=startsynthshortdescs
 add x2,x1
 message x2 ; print location object long desc
; drop through to print tree/terrain combination at this location
;
.drsynthesised
 x1=room
 gosub @getTerrainType
 x3=2688 ; 2800-minsynthroomminus1(112)
 add x3,x1
 message x3
;>>special to gnome - print short descs as well return
;---
.descstaticroom
 picturetodraw=room
 x1=shortroomdescs
 add x1,room
 message x1
 return
;---
.printROOM
 picturetodraw=0
 LASTWORDPRINTED=0 ; prevent printing of 'it'
 GOSUB @POSITIONSHADOWS
 if room=DestToDescribeExitsIn then dr1
 if descriptionmode=inone then drret
;
.dr1
 if actor<>user then drret ; never any description for npcs
 GOSUB @CHECKIFLIGHT
 IF RESULT=TRUE THEN DESCROOM1
 if wanttoprintand=FALSE then dr2
 wanttoprintand=FALSE
 message dot ; not linked to previous message
;
.dr2
 MESSAGE 2108 ; It's dark
 LASTPICTURE=0
 CLS G ; clear graphics window
 RETURN
;---
.DESCROOM1
 GOSUB @SPECIALactor ; print 'You are..'
 GOSUB @SETUPROOM
;
.ABSDESCROOM
 gosub shortdesc
;
.descroomremainder
 IF DESCRIPTIONMODE<>IBRIEF THEN DESCROOM3A
 if room=DestToDescribeExitsIn then descroom3a ; full desc of destinat
 MESSAGE DOT
 if normaldescriptionMode<>ibrief then descroom3e
 GOTO DESCROOM3C
;
.DESCROOM3A
 X1=LONGROOMDESCS
 ADD X1,ROOM
 MESSAGE X1
.DESCROOM3
 MESSAGE DOT
 gosub @specialdescbeforeexits
 if room=10 then descroom3c
 if AutoExits=ivoff then descroom3c
 GOSUB @PRINTEXITS
;
.DESCROOM3C
 gosub showpicture ; start selected picture drawing.

.descroom3e
 SEARCHPOS=ROOM
 HISEARCHPOS=0
 GOSUB @PRINTOBJECTS
 GOSUB @DESCactor
 GOTO @SPECIALDESC
;---
.showpicture
; displaypicture for room PICTURETODRAW
; this is either a static room number 2..25
; or a scenery object number 180..200
; or 2l store
 if room=9 then sdrawpicturex1
 x1=14 ; waterfall+rainbow
 if room=118 then sdrawpicturex1
 if room=119 then sdrawpicturex1
 x1=13 ; eagle's nest
 if room=10 then sdrawpicturex1

 x1=1 ; road
 if x2<117 then notRoad
 if x2<121 then sDrawpicturex1
.notRoad
 x1=2 ; grassy plain
 if x2=112 then sdrawpicturex1
; x1=3??
 x1=4 ; hilly upland
 if x2=123 then sdrawpicturex1
 x1=6 ; stream bank
 if x2=121 then sdrawpicturex1
; x1=7 ; lake shore
 x1=8 ; marshland
 if x2=116 then sdrawpictl store
 if room=9 then sdrawpicturex1
 x1=14 ; waterfall+rainbow
 if room=118 then sdrawpicturex1
 if room=119 then sdrawpicturex1
 x1=13 ; eagle's nest
 if room=10 then sdrawpicturex1

 x1=1 ; road
 if x2<117 then notRoad
 if x2<121 then sDrawpicturex1
.notRoad
 x1=2 ; grassy plain
 if x2=112 then sdrawpicturex1
; x1=3??
 x1=4 ; hilly upland
 if x2=123 then sdrawpicturex1
 x1=6 ; stream bank
 if x2=121 then sdrawpicturex1
; x1=7 ; lake shore
 x1=8 ; marshland
 if x2=116 then sdrawpicturex1
; x1=9 ; dry stone wall
 x1=21 ; plume of cloud
 if x2=113 then sdrawpicturex1 ; beside pinnacle
 if room=10 then sdrawpicturex1 ; nest 
 return
;---
.sdrawpicturex1
 goto @drawpicturex1
;---
;.drawpicturex1
;.dp3
; return ; disable pictures.
;
;; display picture X1
; if x1=lastpicture then dpret
; lastpicture=x1
;;
;.waitpic
; gosub @savelist9
;
;.waitpic1
;; make sure picture 1 has finished loading before doing any other pics
; x2=34 ; is picture still being drawn?
; list9(0)=x2
; list9(2)=c0 ; fix latent bug
; driver
; x2=list9(2)
; if x2=1 then waitpic1
; if x1=1 then drawing1
; picture1displayed=true ; picture 1 is ALWAYS the first pic to be shown.
;; BUT we can only be certain it is finished when we draw the next one.
;
;.drawing1
; xcoord=0
; ycoord=0
; if x1=1 then dp4
; xcoord=48
; ycoord=10
;;
;.dp4
; x2=32
; list9(0)=x2
; list9(1)=c0
; list9(2)=x1 ; picture number to draw
; if cheatmode=false then picturenotcheat
; prs "[Asking for picture " ;*
; print x1 ;*
; prs "]. " ; *
;;
;.picturenotcheat
; list9(3)=c0
; list9(4)=xcoord
; list9(5)=c0
; list9(6)=ycoord
; driver
; goto @restorelist9
;---
;.drawpicturex1
;; display picture for room X1
; if x1=lastpicture then dpret
; lastpicture=x1
; gosub @savelist9
; x2=32
; list9(0)=x2
; list9(1)=c0
; list9(2)=x1 ; picture number to draw
; x1=0 ; x co-ord
; list9(3)=c0
; list9(4)=x1
; list9(5)=c0
; list9(6)=c0 ; y co-ord
; driver
; goto @restorelist9
;---
.CHECKEXIT
 ceroomsave=room
 room=from
 GOSUB ABSCHECKEXIT
 room=ceroomsave
 GOTO @SPECIALEXITS ; Exits conditional on game
;---
.ABSCHECKEXIT
; EXIT ( From FROM diection DIR )
; return DEST, DOOR, EXITVISIBLE
 door=FALSE
 dest=0
 exitvisible=FALSE
 if room<minsynthroomminus1 then fixedexit
;
; is there a fixed exit here? if so, it will override
; any synthesised exits that might otherwise operate
 gosub @convertroom
; now x1=1..25 if any scenery object is here
 if x1=0 then acesynthesised
 x2=minsceneryobjminus1
 add x1,x2
 EXIT x1 DIR STATUS DEST
 if dest>1 then checkexitstatus ; do rest of fixed exit code
; room 1 gives modifiers for synth rooms.
;
.acesynthesised
; ++++ please note: must have done gosub getXY BEFORE calling
 if dir=8 then acenorth
 if dir>2 then acenotnorth
.acenorth
 if y=ymax then acenoexit
.acenotnorth
 if dir=2 then aceeast
 if dir=3 then aceeast
 if dir<>5 then acenoteast
.aceeast
 if x=xmax then acenoexit
.acenoteast
 if dir=6 then acesouth
 if dir=5 then acesouth
 if dir<>4 then acenotsouth
.acesouth
 if y=0 then acenoexit
.acenotsouth
 if dir<6 then acenotwest
 if dir>8 then acenotwest
 if x=0 then acenoexit
.acenotwest
; look at the exit from room 1 to get the destination modifier
 x1=1
 exit x1 dir status dest
 if dest=0 then acenoexit
 add dest,from
 x1=dest
 x2=256
 gosub @x1modx2
 dest=x1
 exitvisible=TRUE
 return
;
.acenoexit
 dest=0
 return
;
.fixedexit ; See if there any fixed exits from here.
 DOOR=FALSE
 EXITVISIBLE=FALSE
 EXIT ROOM DIR STATUS DEST
 if dest=1 then ceret ; room 1 is used to give
; move modifiers for synthesised rooms.
 IF DEST=0 THEN CERET
 if dest<minsceneryobj then checkexitstatus
; find room which scenery object DEST is in - becomes destination room
 dest=currentpos(dest)
.CHECKEXITSTATUS
 X1=STATUS
 IF X1<4 THEN CE2
 DOOR=TRUE
 X2=4
 SUB X1,X2 ; subtract 4
.CE2
 IF X1>1 THEN CERET
 EXITVISIBLE=TRUE
.CERET
.kissret
 RETURN
;---
.close
 if noun1<>generaldoor then closenotdoor
 gosub @printACTORactiondot
.close1
 dooropen=FALSE
 return
;---
.closenotdoor
 goto @dontneedtodothat
;---
.closedoor
; subrouting called whenever door is to be closed
; (e.g. moving though it)
 if actor<>user then closedoorret
 dooropen=FALSE
;
.closedoorret
 return
;---
.parserun
; verb=isetuprun here
 againverb=isetuprun
 goto parsego1
;
.parsego
 againverb=isetupgo
; verb=isetupgo here
.parsego1
; return noun1 as room number of destination
 noun1=nullobject
 treetype=0
 terraintype=0
.gad1omoreinput=TRUE then gadret
 gosub @getnextword
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then gadend
 gosub @goback ; retrieve verb for later parsing
.gadret
 againnoun1=noun1
 noun2=nullobject
 return
;---
.parsefindvalue
; user entered 'go moveable object'
; treat as find
 if actor<>user then ParseFindNotUser
 if value<>unicorn then ParseFindNotUser
 m1=2660 ; can't find unicorn
 gosub @PrintM1Dot
 goto @cancelinput

.ParseFindNotUser
 if verb<>isetuprun then pfv1
 omoreinput=TRUE then gadret
 gosub @getnextword
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then gadend
 gosub @goback ; retrieve verb for later parsing
.gadret
 againnoun1=noun1
 noun2=nullobject
 return
;---
.parsefindvalue
; user entered 'go moveable object'
; treat as find
 if actor<>user then ParseFindNotUser
 if value<>unicorn then ParseFindNotUser
 m1=2660 ; can't find unicorn
 gosub @PrintM1Dot
 goto @cancelinput

.ParseFindNotUser
 if verb<>isetuprun then pfv1
 descriptionmode=inone
;
.pfv1
 verb=isetupfind
 noun1=value
 noun2=nullobject
 prep=0
 return
;---
.baddestination ; a parser error
 gosub @stop
 noun1=nullobject
 verb=0
 goto @cantseewhere
;---
.getparterror
 gperror=TRUE
 return
;---
.getpart
; return noun1 as destination room,
; or verb=direction to move in
; or treetype/terraintype
 gperror=FALSE
 gosub @getnextword
 if eol=TRUE then getparterror
; just possibly, could be a direction
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then getpart1
 if value=ivto then getpart ; go to ...
 if value>maxdirection then getpart1 ; strange verb
 verb=value
 return
;
.getpart1
 searchtype=adjetype
 gosub @checktype
 if value=nullvalue then getpart2
 adjective1=value
 gosub @checktypemore
 if value=nullvalue then getpart2
 adjective2=value
;
.getpart2
 index=0
.goloop
 searchtype=nountype
 gosub @checktypemore


 if value<>250 then findnotyak
 m1=2550 ; Ingrid started to look for it,
 gosub @printm1 ; not dot
 m1=2750 ; but the hair didn't look quite right.
.noFindHorse
 gosub @varymessagedot
 goto @cancelinput

.findnotyak
 if value<>246 then findNotHorse
 m1=2550 ; Ingrid started to look for it,
 gosub @printm1 ; not dot
 m1=2740 ; but the footprints didn't look quite right.
 goto nofindHorse

.findNotHorse
 if value=nullvalue then getpart ; ignore garbage words here.
 if value>mingarbage then getpart
 if adjective1=nullobject then goloopnoadjective
 if value=adjective1 then goloopnoadjective ; could be right dest
 if adjective2=nullobject then goloopnoadjective
 if value>adjective2 then goloopnoadjective
 if value<>adjective2 then goloop ; can't be right destination
;
.goloopnoadjective
 if value>maxsceneryobj then goloopnotlocationobject
;
.golooptreatasfind
; does object exist in game?
 x1=currentpos(value)
 if x1=0 then goloop
 treatasfind=TRUE
 return
;
.goloopnotlocationobject
; maybe 'go static location'
; if so, extract room number
 if value<700 then goloop ; shortroomdescs-nounoffset
 x1=700 ; shortroomdescs-nounoffset
 noun1=value
 if value<1000 then goloopshortdescs ; longroomdescs-nounoffset
 x1=1000 ; longroomdescs-nounoffset
.goloopshortdescs
 sub noun1,x1
 return
;---
.gdgoxy
 if y<noun2 then gdgonorth
 if y>noun2 then gdgosouth
; y=y1; so just go east or west
 if x=noun1 then @followfinished ; have arrived at destination, terminate command
 dir=3 ; east
 if x<noun1 then gdgotdir
 dir=7
 goto gdgotdir
;
.gdgosouth
 dir=4 ; south
 if x=noun1 then gdgotdir
 dir=5 ;se
 if x<noun1 then gdgotdir
 dir=6 ;sw
 goto gdgotdir
;
.gdgonorth
 dir=1 ; north
 if x=noun1 then gdgotdir
 dir=2 ;ne
 if x<noun1 then gdgotdir
 dir=8
; fall through to gdgotdir
.gdgotdir
 intendeddirection=dir
 anglefromintended=0
 gdroomsave=room
.gdtrydir
 from=room
 dir=intendeddirection
 gosub adddir
;
 gosub @checkexit
 if exitvisible=FALSE then tryanotherdirection
 if dest<minsynthroomminus1 then tryanotherdirection
 hidest=0
 verb=dir
 commandfinished=FALSE
 gosub @move ; move the npc, describing as appropriate
;
; if a specialmoves trap was activated, we have to abort the
; find. (Because a message will have been printed, so continuing
; would just confuse the player. A better tracking algorithm
; in future games MIGHT be able to get round this)
 if blockedbysm=TRUE then @followjustfinished ; something badly wrong.
 if room=gdroomsave then tryanotherdirection ; something went wrong
 if room=destnoun1 then @followjustfinished
 return ; all went well.
;---
.tryanotherdirection
; have reached an obstruction in a goaldirected movement
 if anglefromintended>negative then tad2 ; am wheeling to left
 if anglefromintended<>0 then tad1 ; am wheeling to right
 anglefromintended=1
 goto gdtrydir
;---
.tad1
; was not going in intended direction when the obstruction
; was reached
; try wheeling round to right (clockwise)
 if anglefromintended=2 then tad2a
 add anglefromintended,c1 ; try +1, +2
 goto gdtrydir
;---
.tad2a
 anglefromintdir
 add dir,anglefromintended
 gosub makedirwithinbounds
; fall through to swapdir ; and swap back again
;
.swapdir
; swap round south, southeast
 if dir<>4 then swapdirnotsouth
 dir=5
 return
;---
.swapdirnotsouth
 if dir<>5 then swapdirret
 dir=4

.swapdirret
 return
;---
.makedirwithinbounds
 if dir<9 then mdwb1
 dir=1
 return
;---
.mdwb1
 if dir>0 then mdwb2
 dir=8
.mdwb2
.diwtret
.mmdret
.teleportret
.ringret
 return
;---
.teleport
 cif AllowCheat
; we came here stradir
 add dir,anglefromintended
 gosub makedirwithinbounds
; fall through to swapdir ; and swap back again
;
.swapdir
; swap round south, southeast
 if dir<>4 then swapdirnotsouth
 dir=5
 return
;---
.swapdirnotsouth
 if dir<>5 then swapdirret
 dir=4

.swapdirret
 return
;---
.makedirwithinbounds
 if dir<9 then mdwb1
 dir=1
 return
;---
.mdwb1
 if dir>0 then mdwb2
 dir=8
.mdwb2
.diwtret
.mmdret
.teleportret
.ringret
 return
;---
.teleport
 cif AllowCheat
; we came here straight from the parser, so set up verb...
 if cheatmode=0 then @nicetry
 verb=iteleport
.allowteleport
 gosub @parsego
 if noun1=nullobject then teleportret
 if verb<>isetupfind then teleporttonoun1
 object=noun1
 gosub @getobjectposx2
 noun1=x2
;
.teleporttonoun1
 dest=noun1
;
.magicmove
 hidest=0
;
.magicmovedest
 if dest=0 then mmnomove
 if dest<2 then @cantseewhere
 currentpos(actor)=dest
 hicurrentpos(actor)=hidest
.mmaftermove
 gosub @setuproom
 gosub @getxy
 if actor<>user then mmdret
 currentuserroom=room
 gosub @printroom
 GOTO @CANCELINPUT
;---
 cend
.mmnomove
 m1=2995 ; you end up where you were
 gosub @printM1dot
 goto @CancelInput ; goto mmaftermove
;---
.noexit
 if room<minsynthroom then noexit5
 m1=2764 ; not going to leave just yet
 if x<>0 then noexit2
 if dir=7 then noExitPrint

.noexit2
 if x<>6 then noexit3
 if dir=3 then noExitPrint

.noexit3
 if y<>6 then noexit4
 if dir=1 then noExitPrint

.noexit4
 if y<>0 then noexit5
 if dir=4 then noExitPrint

.noexit5
 m1=2114 ; no exit!

.noexitPrint
 goto @errorm1dot
;---
.dig
 object=shovel
 gosub @checkifaccessible
 if result=true then digWithShovel
 gosub @printactor
 m1=2595 ; no shovel
 goto @printm1dot

.digWithShovel
 m1=2594 ; ground was too hard
 if room<>119 then @printm1dot
; dig near waterfall...
 add forceprinting,c1
  gosub @printactor
 sub forceprinting,c1

 m1=2593 ; dug for a while, but found nothing
 x1=currentpos(crockofgold)
 if x1<>0 then forcem1dot ; gold already found
 if currentuserroom<>118 then forcem1dot ; ingrid not watching rainbow
 currentpos(leprecaun)=room
 currentpos(crockofgold)=room
 m1=2592 ; uneathed a crock of gold
.forcem1dot
 message m1
 message dot
.snapret
 return
;---
.ring ; ring/play
 if object<>bell then ringNotBell
 m1=2649 ; ding/dong
 gosub @printm1dot
 x1=currentpos(eagle)
 if x1=1 then ringNotBell ; dead!
 x1=currentpos(eagle)
 if x1=currentuserroom then @ringret
; cause eagle to come towards Ingrid.
 x6=14 ; eagle to Ingrid racetrack
 object=eagle
 goto @newracetrackforObject


.ringNotBell
 if object<>pipes then ringNotPipes
 x1=currentpos(unicorn)
 if x1=1 then ringNotPipes ; dead!
 m1=2720 ; unicorn canters up group
 gosub @varymessagedot
 currentpos(unicorn)=room
 x6=17 ; unicorn waiting for Ingrid racetrack
 object=unicorn
 goto @NewRaceTrackForObject

.ringNotPipes
 if object<>whistle then ringNotWhistle
 x1=currentpos(dogswarm)
 if x1=1 then ringNotWhistle ; dead!
 currentpos(dogswarm)=room
 hicurrentpos(dogswarm)=c0
 actorsave=actor
 actor=dogswarm
 gosub @stop
 actor=actorsave
 m1=2762 ; dog swarm appears
 goto @printm1dot

.ringNotWhistle
 m1=282 ; no!
 goto @printm1dot
;---
.snap
; snap fingers
 if object<>fingers then @ActorCantVerbNoun1
 m1=2602 ; ingrid snapped her fingers
 if LeprecaunFriendly=false then @printm1dot
 x1=currentpos(leprecaun)
 if x1=1 then @printm1dot ; dead!
 gosub @printm1 ; no dot!
 LeprecaunTime=0
 currentpos(leprecaun)=room
 m1=2610 ; .. and leprecaun appeared group
 goto @varymessagedot
;---
