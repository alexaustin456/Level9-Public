; Lancelot 1 source, copyright (C) 1988 Level 9 Computing.
;
; AVERB.TXT, fairly standard code to handle ordinary verbs (there 
; is no point in writing code to handle movement; get/drop; examine
; etc. etc. afresh for each game.) You will need to make some changes, 
; adding new verbs and those special cases which can't go elsewhere, 
; and possibly removing verbs, e.g the combat routines if your game 
; is non-violent.
;
BEGIN
;
; Start of game, transferred here directly from APARSE. 
;
.normalSTARTGAME
; clear entire table area...
 x1=0
 c1=1
.clearall
; some of the table cleared here is also cleared by initnpc
 currentpos(x1)=c0 ; must be done else OBJECTTRIGGER fails for OBJECT=0
 add x1,c1
 if x1<npctablesizetozero then clearall
 MESSAGE 2100 ; welcome to game
; initialise some variables which retain their values throughout
; the game
 thisgame=StandardAdventure
 thispart=constantpartnum
 C1=1
 C2=2
 C3=3
 C4=4
;; c6=6
;; c8=8
 C10=10
;
 ITWORD=NULLOBJECT ; first object seen
 ITNUMBER=NULLNUMBER
 NOMOREINPUT=TRUE ; have come to end of input line
; CARRYCAPACITY=NORMALCAPACITY
 GOSUB @INITOBJECTS
;>>> gosub randomizetreasure
 gosub @initnpcs
 SOMETHINGPROCESSED=TRUE ; force printing of WHAT NEXT ?
 NORMALDESCRIPTIONMODE=IVERBOSE
 AutoExits=ivoff ; default to exits off
 OOPSPOS=1
; vandalptr=vandalbase
;
 gosub @initlocations

; now set up variables as pointers to starts
; within segmented lists
 value=list5(0)
 gosub @valuetimes256
 x1=list5(1)
 add value,x1
 startfloorpointers=value

 value=list5(2)
 gosub @valuetimes256
 x1=list5(3)
 add value,x1
 startracetracks=value

 value=list5(4)
 gosub @valuetimes256
 x1=list5(5)
 add value,x1
 startreversaltable=value

;*****
 value=list5(6)
 gosub @valuetimes256
 x1=list5(7)
 add value,x1
 StartPictureTable=value
;*****

; set up initial racetrack commands for npcs
; which have them
 actor=1
.initracetrack1
; now find pointer to initial racetrack for actor:
 add actor,c1
 x1=actor ; number of racetrack to activate
 gosub @initracetrackx1
 if actor<maxnpcplus1 then initracetrack1

 x1=VisitTableStart
 x2=0 ; room number
.InitDone1
 list7(x1)=x2
 if x1>VisitTableEnd then InitDone2
 add x1,c1
 add x2,c1
 goto InitDone1

.InitDone2
 x1=startliedowntable
.InitMeeting1
 list7(x1)=c0
 add x1,c1
 if x1<endliedowntable then InitMeeting1

 object=seamus
 gosub @SetX4ToObjectAttributes
 x1=followOffset
 add x1,x4
 npccurrent(x1)=c1 ; make seamus follow Ingrid

 object=flopsy
 gosub @MakeObjectObedient
 object=gnoah
 gosub @MakeObjectObedient

 actor=user
 gosub @setuproom

;*****
;; bodges for playtesting:
; gosub positiontrolls
; currentpos(ambul)=c0
; trollchasing=false ; can be annoying!
;*****

 x1=1
 gosub @drawpicturex1

;; check if player really wants this part.
; m1=2499 ; do you want to continue with this part?
; gosub @PrintM1
; gosub @YesOrNo
; if Result=true then NoInitialChain
; ThisPart=0
; PartToChain=3
; gosub @ChainPartToChain
; goto InitAll ; chain failed or something
;
;.noInitialChain

 message BlankLine
 gosub @PrintRoom
 GOTO @CANCELINPUT
;---
.unfasten
.unfastentake
 verb=itake

.GET
.TAKE
; Check for prepositions e.g. GET ON, GET OFF
 IF PREP<>0 THEN TAKEFROM
.TAKEIT
; x1=hicurrentpos(actor)
; if x1=0 then nottakeinbushes
; x1=currentpos(actor)
; if x1<>bushes then nottakeinbushes
;; take when in bushes. object must also be in bushes
; pos=bushes
; hipos=in
; gosub checkobjectpos
; m1=2568 ; out of reach
; if result=false then @printm1dot
;.nottakeinbushes
 POS=ACTOR
 HIPOS=CARRIED
 GOTO @MOVEOBJECT
;
.TAKEFROM
; got a preposition e.g. TAKE noun FROM ; or TAKE noun IN etc.
 OBJECT=NOUN1
 POS=NOUN2
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
; OBJECT=NOUN1 here
 IF RESULT=FALSE THEN @ITSNOTTHERE
 GOTO TAKEIT
;---
.hide
 goto @put
;
;; HIDE bushes
; if noun1=nullobject then hide1
; if noun1<>bushes then canthide
;.hide1
; object=bushes
; gosub @checkifpresent
; if result=false then canthide
; verb=istand
; prep=in
; goto standok
;.canthide
; goto wasteoftime
;---
.SIT
;**STAND PREP NOUN2**
.STAND
 x8=currentpos(actor) ; x8 & x9 used to test if flopsy in vehicle (below)
 X9=HICURRENTPOS(ACTOR)
 lastpossibleverb=0 ; prevent prep being parsed as a verb
 x1=nextverb ;*
 nextverb=0
 IF PREP=ON THEN @STANDON
 IF PREP=OFF THEN STANDOFF
 IF PREP=UP THEN STANDUP
 IF PREP=IPIN THEN @STANDIN
 IF PREP=IPOUT THEN STANDOUT
; now fix a bug - no prep parsed for get in/out
 if prep<>0 then @DontUnderstand
 prep=on ;*
 IF x1=ivON THEN @STANDON ;*
 prep=off ;*
 IF x1=ivOFF THEN STANDOFF ;*
 prep=up ;*
 IF x1=ivUP THEN STANDUP ;*
 prep=ipin ;*
 IF x1=ivIN THEN @STANDIN ;*
 prep=ipout ;*
 IF x1=ivOUT THEN STANDOUT ;*
; GET <PREP> is being used, but we can't determine which prep is, since 
; NPCs don't use NEXTVERB.
; * firstly, treat as get up
 x1=startliedowntable
 add x1,actor
 x2=list7(x1)
 if x2=0 then notlyingdown
 prep=up
 goto standup
.notlyingdown
; * secondly, treat as get in
 x1=hicurrentpos(actor)
 prep=ipin
 if x1=0 then standOn ; try getting into a container
; * lastly, treast as get out
 prep=ipout
; GOTO @DONTUNDERSTAND
;---
.STANDOFF
.STANDOUT ; get out (e.g. of boat)
.STANDUP
;
 if x9=0 then testlying ;*
;
; can't get "off" silas when being escorted
 m1=2811
 if x8=silas then @errorm1dot
 goto okstandup ;*
;
;*graham*
; NB: all prevents and intercepts must go BEFORE this routine
.testlying
 x1=startliedowntable
 add x1,actor
 x2=list7(x1)
 if x2=0 then @silly
; hipos=0, BUT actor is lying down
.okstandup
;*graham*
;
 currentpos(actor)=ROOM
 hicurrentpos(actor)=c0
 hidest=0 ;>>added for L1
 gosub reportstand
;
; flopsy gets out of vehicles with user
; (this stops him following user while still in vehicle)
.flopsylikewise
 if actor<>user then standupret
 x1=currentpos(flopsy)
 if x1<>x8 then standupret
 x1=hicurrentpos(flopsy)
 if x1<>x9 then standupret
 currentpos(flopsy)=room
 hicurrentpos(flopsy)=c0
 m1=2517
 gosub @printm1dot ; flopsy did likewise
.standupret
 return

.ReportStand
;*graham*
 x1=startliedowntable
 add x1,actor
 list7(x1)=c0 ; all stand commands prevent lying down
.reportlie
;*graham*

;;********
; message cr
; x1=startliedowntable
;.showlying
; x2=list7(x1)
; print x2
; message space
; add x1,c1
; if x1<endliedowntable then showlying
; message cr
;;********

 noun1=nullobject
 noun2=nullobject
; print "L got out" etc.
; commandfinished=true ; otherwise, npc's give up (dunno why!)
 executeProcessed=true 
 fatalerror=false
 gosub @printactorVerb ;>> goto @done
 m1=PrepOffset
 add m1,Prep
 if hidest=0 then @printm1Dot
 gosub @printm1
 x1=dest ;>>changed for L1
 gosub @printTheObjectX1
 goto @printDot
;
;---
.BOARD ; e.g. boat
.STANDON
.STANDIN

.standin0
 cif AllowBoat
;; boat
; if noun2=nullobject then okstandin
; if noun2<>boat then standin1
;.okstandin
; prep=in
; object=boat
; gosub @checkifpresent
; if result=true then standOk
;
; steamroller
.standin1
 if noun2=nullobject then okstandon1
 if noun2<>steamroller then standin2
.okstandon1
 prep=in
 object=steamroller
 gosub @checkifpresent
 if result=true then @standOk
 cend

; STAND ON blue telelily
.standin2
 if noun2<>bluetelelily then standin3
 prep=on
 object=noun2
 gosub @checkifpresent
 x8=greentelelily
 if result=true then teleok

; STAND ON green telelily
.standin3
 if noun2<>greentelelily then standin4
 prep=on
 object=noun2
 gosub @checkifpresent
 x8=bluetelelily
 if result=true then teleok

; STAND IN bushes
.standin4
 if noun2=nullobject then okstandon4
 if noun2<>bushes then standin5
.okstandon4
 prep=in
 object=bushes
 gosub @checkifpresent
 if result=true then @standOk

.standin5
 GOTO @silly
;---
; teleport actor using telelilies
.teleok
; first, make sure that it's on the floor
 x1=hicurrentpos(object)
 m1=2678
 if x1<>0 then @printm1dot
;
; print leaving
 gosub @printactor ; <actor>
 m1=2672
 gosub @printm1 ; stood on the
 gosub @printtheobject ; <telelily>
 m1=2670
 gosub @printm1dot ; and faded away.
;
.teleportactor
 t1=object
 object=x8
 hidest=hicurrentpos(object)
 dest=currentpos(object)
 if hidest=0 then dotele ; teleport normal room with no HIPOS
;; if dest=well then dotele ; teleport IN WELL
; otherwise, teleport to room of OBJECT
 hidest=0
 gosub @getobjectposx2
 dest=x2
 if dest<>0 then dotele
; second lily doesn't exist
 object=t1 ; teleport back
 dest=room
;
; now do the teleport
.dotele
 currentpos(actor)=dest
 hicurrentpos(actor)=hidest
 gosub @setuproom
 gosub @getxy
;
; print arrival
 message cr
 gosub @printactor ; <actor>
 m1=2671
 gosub @printm1 ; meterialized on the
 gosub @printtheobject ; <telelily>
 if actor=user then usertele
 m1=dot
 gosub @printm1
 goto @aftermove
.usertele
 wanttoprintand=user
 gosub @printroom
 gosub @aftermove
 x1=40
 if room=7 then @addscore10 ; reach down well
.teleret
 return
;---
.LIE
;*graham*
; lie on floor (in front of steamroller)
; (PREP is more or less non-specific at this point)
 x1=hicurrentpos(actor)
 if x1<>0 then @silly ; can't lie down in container
 if nextverb<>ivdown then notliedown
; LIE DOWN, cancel nextverb
 nextverb=0
 lastpossibleverb=0
 goto lieok
.notliedown
 if noun2=iroom then lieok ; LIE <NOUN=ROOM>
 if noun2=steamroller then lieok ; LIE IN FRONT OF STEAMROLLER
 if noun2<>nullobject then @silly ; LIE <NOUN<>ROOM>
.lieok
 x1=startliedowntable
 add x1,actor
 list7(x1)=c1 ; set "lying down" flag
 if noun2<>steamroller then lieonfloor
 prep=ipinfront
 object=steamroller
 goto reportlie0
.lieonfloor
 prep=ipon
 object=iroom
.reportlie0
 processed=true
 hidest=prep
 dest=object
 goto @reportlie
;*graham*
;---
.STANDOK
 x1=currentpos(actor) ;*
 if x1<>object then standok1 ;*
 x1=hicurrentpos(actor) ;*
 if x1<>0 then @silly ;* already there!
.standok1
 PROCESSED=TRUE
 HIDEST=PREP
 DEST=OBJECT
 gosub @ReportStand
 currentpos(actor)=dest ;*
 hicurrentpos(actor)=hidest ;*
 return ; GOTO @NEWLOCATION ;*
;---
.ATTACK
 executeProcessed=true
; if noun1=iroom then @vandal
.AttackNotDoor
 target=noun1
 if noun1>maxnpc then atnpc ; assumes nullobject=255
;; if noun2<minweapon then @silly
;; if noun2=nullobject then attackchoose
;; if noun2>maxweapon then @silly
;; weapon=noun2
;; goto @generalblow
;;;
;;.attackchoose
;; GOSUB @CHOOSEBESTWEAPON
;; GOTO @GENERALBLOW
;;;
.ATNPC
; if noun1<minsceneryobj then atnsceneryobject
; if noun1<maxsceneryobjplus1 then @vandal
;
 if target<>dam then notbreakdam
 m1=2606
 if dambeenbroken=true then @printm1dot ; dam been repaired too well
 gosub @printactoractiondot
 dambeenbroken=true
 draincount=1 ; start draining away
 x1=37
 currentpos(bog)=x1
 if currentuserroom<37 then nobreakmess
 if currentuserroom>39 then nobreakmess
 message 2607
 message dot
.nobreakmess
 x1=41
 gosub @addscore10
; replace dam with broken one
 currentpos(dam)=c0
 currentpos(brokendam)=room
 x1=currentpos(steamroller)
 if x1=37 then floodroller
 return
; flood steam roller
.floodroller
 x1=52
 gosub @addscore20
 object=trolls
 x6=46
 gosub @newracetrackforobject
 object=silas
 x6=47
 gosub @newracetrackforobject ; silas & trolls go to repair dam
 if currentuserroom<37 then nostuckmess
 if currentuserroom>39 then nostuckmess
 message 2608
 message dot
.nostuckmess
 return
.notbreakdam
;
 if noun1=root then breakroot
 if noun2<>root then notbreakroot
.breakroot
 noun1=root
 noun2=nullobject
 prep=0
 if currentuserroom=19 then delaybreakroot
 currentpos(root)=c0
 gosub @printactoractiondot
 m1=2664
 x1=currentpos(ambul)
 if x1<>19 then @printm1dot
 trollchasing=false
 chasemoves=false ;*
 x1=ambul
 gosub @addscore20
; * Telelilys "grow" in Soggybottom field after the flood AND after Ambul 
; has been trapped. This prevents Ingrid from teleporting away from Ambul
; while being chased. I would like to have the lilys visibly grow 
; after the flood has drained, but this would allow Angrid to wait there 
; with Ambul, take the lilys and teleport away using Flopsy's help.
; * This feature also prevents the lilys being used to teleport silas or 
; the trolls at the start of the game.
 x1=37
 currentpos(bluetelelily)=x1
 currentpos(greentelelily)=x1
 m1=2665
 goto @printm1dot
; npc (flopsy) won't break root if ingrid still in lower warren
.delaybreakroot
 goto @singlepushfifo ; save action till next turn
.notbreakroot
;
.atnsceneryobject
.collect
.become
.WAKE
.WASTEOFTIME
 IF ACTOR<>USER THEN @NPCNOTUNDERSTOOD
 M1=3160 ; don't bother group
 GOTO @VARYMESSAGEDOT

.attackPrintM1Dot
 goto @PrintM1Dot
;---
.PUT
 IF NOUN1=NULLOBJECT THEN @CANTSEEWHAT
 IF NOUN2=NULLOBJECT THEN @CANTSEEWHERE
 OBJECT=NOUN1

; PREP is non-specific when putting objects on lily
; PUT NOUN1 PREP blue telelily
 x8=greentelelily
 if noun2=bluetelelily then @PUTTELEOK
; PUT NOUN1 PREP green telelily
 x8=bluetelelily
 if noun2=greentelelily then @PUTTELEOK

 IF PREP=ON THEN PUTON
 IF PREP=UNDER THEN @PUTUNDER
 IF PREP=IN THEN @PUTIN
 IF PREP=THROUGH THEN @PUTIN

.CANTPUTTHERE
;; if actor<>user then cptret
 gosub @actorcantverbnoun1	; can't put that
 m1=2124			; there
 goto AttackPrintM1dot
;---
.PUTON
; CHECK IF DESTINATION CAN HAVE things put on top of it
;
 object=noun2
 if noun1=hook then putobjectonhook ; fasten hook to object
 object=noun1
 if noun2=hook then putobjectonhook ; fasten object to hook
;
 x8=greentelelily
 if noun1=bluetelelily then putlilyonnoun2
 x8=bluetelelily
 if noun1=greentelelily then putlilyonnoun2
;
 if noun2=ctrapdoor then @putok ; put object on trapdoor
;
 GOTO CANTPUTTHERE
;---
.putobjectonhook
 x1=hicurrentpos(object)
 if x1=0 then notalreadyhooked
 x1=currentpos(object)
 if x1=hook then @silly ; already on hook
.notalreadyhooked
 if object=nullobject then @silly
 if object>maxmoveable then @silly
 if object=handbag then putonhookok ; handbag ok
 if object=loaf then putonhookok ; loaf ok
 if object=sack then putonhookok ; sack ok
 if object=trolls then cantputonhook
 if object=silas then cantputonhook
 if object>35 then cantputonhook ; can't hook some people (mainly groups)
 if actorhooked<>false then someonealreadyhooked
 actorhooked=object
 goto putonhookok
; oops, somebody else is already on the hook
.someonealreadyhooked
 m1=2716
 goto @printm1dot ; hook could only carry one person
.cantputonhook
 m1=2714
 goto @printm1dot ; won't fit on hook
.putonhookok
 verb=ifasten
 prep=ipto
 noun1=object
 noun2=hook
 currentpos(noun1)=noun2
 x1=on
 hicurrentpos(noun1)=x1
 if noun1=user then @done ; prevents ingrid put ingrid on hook
 goto @printactoractiondot
;---
; lilies may be put on/under certain people to teleport them
.putlilyonnoun2
 if noun2=actor then @silly ; can't put lily under yourself
; npcs with important racetracks must not be teleported.
 if noun2=bumpy then @cantputthere
 if noun2=silas then @cantputthere
 if noun2=trolls then @cantputthere
 if noun2>35 then @cantputthere ; chickens, pigs & objects
 gosub @printactoractiondot ; <actor> put the lily under <npc noun2>
 x9=actor ; save actor
 actor=noun2 ; actor is now npc to be teleported
 gosub @printactor ; <npc>
 m1=2679 ; faded away
 gosub @printm1dot
 object=noun1 ; teleport from object to x8
 gosub @teleportactor ; (see stand on telelily)
;
 if actorteleported=false then nobodycomesback
; last actorteleported comes back before new one is set up
 actor=actorteleported
 x8=t1 ; teleport back in reverse direction (see teleportactor for t1)
 gosub @oktoteleportback ; forced return teleport
; now set up new actor to teleport back next move
.nobodycomesback
 actorteleported=noun2 ; used for teleport back code in specialactivate
 movesteleported=0
;
 actor=x9 ; recover x9
 return
;---
; teleport noun1 using telelilies
.PUTteleok
; print leaving
 object=noun1
 gosub @printactoractiondot ; <actor> put <object> on telelily
 m1=2673
 gosub @printm1dot ; it faded away.
;
 object=x8
 gosub @getobjectposx2 ; x2=room of second lily
 if x2<2 then doputtele ; doesn't exist, tele back to same lily (noun2)
; teleport to second lily (new noun2)
 noun2=x8
;
; now do the teleport
.doputtele
 dest=noun2
 hidest=on
 object=noun1
 currentpos(noun1)=dest
 hicurrentpos(noun1)=hidest
;
; print arrival if user watching
 gosub @getobjectposx2 ; x2=arrival room
 if x2<>currentuserroom then putteleret
 gosub @printtheobject
 m1=2671
 gosub @printm1 ; meterialized on the
 x1=noun2
 gosub @printtheobjectx1 ; <telelily>
 m1=dot
 gosub @printm1
.putteleret
 return
;
.PUTOK
 OBJECT=NOUN1
 GOTO @MOVEOBJECTPrepNoun2

.PUTIN
 cif AllowBoat
;  if noun2=boat then putok
  if noun2=steamroller then @putok
 cend

 if noun2<>well then notputinwell
 gosub @putok
; put object in "well" room
 x1=7
 currentpos(noun1)=x1
 hicurrentpos(noun1)=c0
 m1=2674
 goto @printm1dot
.notputinwell

; block chimney with loaf
 if actor=user then blockok
; only ingrid can block chimney, since if flopsy were to do it, then 
; it is possible that ingrid could be at the farm, which causes problems 
; when her family are suddenly repositioned in the barn!
 gosub @printactor
 m1=2642 ; can't reach chimney
 goto @printm1dot
;
.blockok
 if noun2<>chimney then @notchimney
 if noun1<>loaf then @notchimney
 x1=hicurrentpos(silas)
 if x1=0 then blowup
 x1=currentpos(silas)
 if x1<>steamroller then blowup
;
; silas in steamroller
 m1=2640
 goto @printm1dot
;
.blowup
 gosub @putok
 message 2641
 message dot
 x1=currentpos(steamroller)
 currentpos(steamroller)=c0
 currentpos(ashes)=x1			; replace steamroller with ashes
 x1=53
 gosub @addscore20
;
; reposition ingrid's family in barn
.positiontrolls
 x8=gnora
 x9=13 ; barn
.putinbarn
 if x8=bumpy then nextpib		; ignore bumpy
 if x8=12 then pibok
 if x8>7 then nextpib			; ignore null npcs (8-11)
.pibok
 actor=x8
 gosub @stop
 hicurrentpos(actor)=c0
 currentpos(actor)=x9			; ingrid's family locked in barn
.nextpib
 add x8,c1
 if x8<13 then putinbarn
 actor=user
;
; position silas, trolls and rabbit
 x1=35
 currentpos(rabbit)=x1			; rabbit to lead Ingrid to warren
 currentpos(trolls)=c0			; destroy "group" trolls
 currentpos(silas)=c0			; silas dissapears until endgame
 currentpos(ambul)=currentuserroom	; ambul chases.
  object=ambul
   x6=48
    gosub @newracetrackforobject
     trollchasing=ambul
; remaining troll racetracks already set up in table.txt
 x1=227
  currentpos(bane)=x1			; static. outside farm
 x1=5
  currentpos(chugg)=x1			; static. inside farm
 x1=25
  currentpos(doldrum)=x1		; patroll. follow if meet user
 x1=222
  currentpos(ergot)=x1			; static. outside barn
 x1=222
  currentpos(fugg)=x1			; patroll. follow if meet user
 x1=226
  currentpos(gormley)=x1		; patroll. follow if meet user
 return
.notchimney

; put deeds in/through gap
 if noun1<>deeds then @cantputthere
 if noun2=gap then @win

.objectwontfit
 GOTO @CANTPUTTHERE

.putunder
;
 x8=greentelelily
 if noun1=bluetelelily then @putlilyonnoun2
 x8=bluetelelily
 if noun1=greentelelily then @putlilyonnoun2
;
; if ingrid puts deeds under door, finish part 2
 if noun1<>deeds then @cantputthere
 if noun2=generaldoor then @win
 if noun2=gap then @win
;
 goto @cantputthere
;---
.ISOBJECTMOVEABLE
; return RESULT=TRUE if OBJECT can be moved
 if object>maxmoveable then @returnfalse
;*graham*
 if object>maxNpc then iomtrue ;if object<maxnpcplus1 then @returnfalse ;*
 if noun1=hook then iomtrue ;*
 if noun2<>hook then @returnfalse ;*
.iomtrue
 result=TRUE
.IOMRET
.cptret
.standret
 RETURN
;---
.MoveObjectPrepNoun2
 pos=Noun2
 hipos=Prep

; Super routine for moving objects about. E.g, putting something inside 
; a bag. Or removing it. It differs from "NEWLOCATION", which is concerned 
; with walking-about-type-movement, primarily in the way that the action 
; is reported. MOVEOBJECT validates the movement before carrying it out.
.MOVEOBJECT
; Move 'OBJECT' to 'POS', 'HIPOS'
; Return RESULT=TRUE if move was successful
;; if object<>user then notmoveuser
;; if hipos<>carried then notcarryuser
;; if pos=rook then moveobj1 ; rook carries user
;;.notcarryuser
;; if hipos<>0 then notdropuser
;; x1=currentpos(user)
;; if x1=rook then moveobj1 ; rook drops user
;;.notdropuser
;;.notmoveuser
 GOSUB ISOBJECTMOVEABLE
 IF RESULT=FALSE THEN @IMMOVABLE
; is the contents already contained by the container (or V-V) ?
 GOSUB @CHECKIFCONTAINED
;
 IF HIPOS=0 THEN MONOTACTOR
; ACTOR to gain this object, check if is able to carry it
; actually this code is now used whenever an object
; goes to a position not on the ground. This
; is to catch people trying to avoid SPECIALTAKES
 IF HIPOS<>WORN THEN MOVEOBJ1
; is it wearable ?
 IF OBJECT<minclothes THEN @cantwear
 if object>maxclothes then @cantwear

.MOVEOBJ1
; Now check if the ACTOR is standing on it or some similar problem
 OBJECTSAVE=OBJECT
 DEST=POS ; save value
 HIDEST=HIPOS ; save it
;
 POS=OBJECT
 HIPOS=NONSPECIFIC
 OBJECT=ACTOR
 GOSUB @CHECKOBJECTPOS
;
 OBJECT=OBJECTSAVE
 POS=DEST ; restore value
 HIPOS=HIDEST ; restore value
 IF RESULT=TRUE THEN @MOVEOBJFAIL
 GOSUB @SPECIALTAKES ; game-specific take messages
 IF RESULT=FALSE THEN @MOVEOBJRET
;
.MONOTACTOR
 X1=CURRENTPOS(OBJECT)
 IF X1<>ACTOR THEN MMNOTLOSE
 X1=HICURRENTPOS(OBJECT)
 IF X1=0 THEN MMNOTLOSE
; ACTOR is to lose object
 IF X1<>WORN THEN MMLOSENOTWORN
; ACTOR is wearing object, if it was specified using EVERYTHING,
; then don't drop it as this could cause embarrasment
 IF noun1isgd=FALSE THEN MMLOSENOTWORN
 if verb=iremove then mmlosenotworn
 RESULT=FALSE
 if actor<>user then @npcnotunderstood
 M1=2134 ; you're wearing
 gosub @printM1
 gosub @printTHEobject
 goto @printDOT

.MMLOSENOTWORN
 GOSUB @SPECIALDROPS
 IF RESULT=FALSE THEN MOVEOBJRET

.MMNOTLOSE
 IF HIPOS=0 THEN MMNL1
 IF POS=OBJECT THEN @CANTPUTTHERE
.MMNL1
; any other special cases ?
;
; is it going to a NPC ?
 if actor=pos then montonpc ; ok for people to take things
 IF HIPOS=0 THEN MONTONPC
 IF POS<minnpc THEN MONTONPC
 IF POS>MAXNPC THEN MONTONPC
; code here is to avoid NPCs having things put on them etc.
; or the statue / bloodworm / bat being given things
; no special cases for giving to NPC, so make it carry it
 IF HIPOS=WORN THEN MONTONPC ; unless it is going to wear it
 HIPOS=CARRIED

.MONTONPC

 FROM=CURRENTPOS(OBJECT)
 HIFROM=HICURRENTPOS(OBJECT)
 CURRENTPOS(OBJECT)=POS
 HICURRENTPOS(OBJECT)=HIPOS
;
; now decribe the move
;
; show ACTOR doing something
; verb is set up
 if verb=ithrow then monodesc
 objectsave=object
 gosub @printACTORactiondot
 object=objectsave

.monodesc
 gosub @specialaftermoveobj
 goto @returnTRUE ; move went just fine!

.MOVEOBJFAIL
 M1=2131 ;  you're on it
 gosub @errorm1

.MOPREVENT
 RESULT=FALSE
.moveobjret
 RETURN
;---
.POSITIONSHADOWS
; Make objects follow the ACTOR around where applicable. e.g. DOORS.
; and other objects which are in several places at once. 
 RETURN
;---
.FASTEN
 object=noun2
 if noun1=hook then @putobjectonhook ; fasten hook to object
 object=noun1
 if noun2=hook then @putobjectonhook ; fasten object to hook
 goto @actorcantverbnoun1dot
;---
;.untiefirst
; m1=2158 ; must untie it first
; goto @printM1dot
;---
; Move something/someone to a new location in the game, reporting the 
; movement with messages such as 'X enters from the north'.
.NEWLOCATION
; Given FROM=old location, HI,DEST=new location
; and DIR=direction,
; print any messages which appear on moving through doors etc.
; GOSUB SETUPROOM
 FROM=ROOM
 GOSUB @SPECIALMOVES
 blockedbysm=TRUE
 IF RESULT=FALSE THEN @NLRET
 if actor<>user then NewMoveNotUser
 gosub @saveOops

.NewMoveNotUser
 blockedbysm=FALSE
;
.ABSNEWLOCATION
; as for newlocation, but don't do any checking for special
; case code. Use this routine where the move is forced, so
; don't want to trip any movement traps
;*graham*
 x1=startliedowntable
 add x1,actor
 list7(x1)=c0 ; all move commands prevent lying down
;*graham*
 ExecuteProcessed=true ; we did something! >>mike 28/3/88
 if dest=0 then @nlret ;>>mike 8/1/88
 FROM=ROOM
; describe door closing (if there is one)

 cif AllowBoat
;  if dest=boat then anl2a ;>>special to Lancelot - only affects TO BOAT
  if dest=steamroller then anl2a
 cend

 IF HIDEST<>0 THEN ANL2 ; skip checks for moving into container
 GOSUB @CHECKEXIT

.anl2a
 gosub @printleaving
;
.ANL2
 LASTROOM=ROOM
 CURRENTPOS(ACTOR)=DEST
 HICURRENTPOS(ACTOR)=HIDEST
 gosub @closedoor
 roomsave=ROOM
 gosub @setuproom
 gosub @printarrival
; no messages printed between printarrival and printroom please
.NLEND


 cif AllowBoat

 x1=hicurrentpos(user) ;>>special to Lancelot3/boat
 if x1=0 then NLEND1

 x1=currentpos(steamroller) ;>>L2
 if x1<>actor then NLNotPushingCart ;>>L2
 x1=currentpos(user) ;>>L2
 if x1=steamroller then NLPrintMoveAnyway ;>>L2
.NLNotPushingCart
 goto NLEnd1

.NLPrintMoveAnyway
 actorsave=actor ;>>special to Lancelot3/boat
 actor=user ;>>special to Lancelot3/boat
 gosub @SetUpRoom ;>>special to Lancelot3/boat
 gosub @printRoom ;>>special to Lancelot3/boat
 actor=actorsave ;>>special to Lancelot3/boat
 goto @aftermove ;>>special to Lancelot3/boat

.NLEND1

 cend ; end of boat stuff


 IF ACTOR<>user THEN @AFTERMOVE ; npc doesn't want description
.NLENDPrint
 timeinroom=0
 GOSUB @printROOM
 gosub firstvisit
 goto @aftermove

; for user only, print any messages due on first visit
.firstvisit
;
; special case for warren if root already been destroyed by another 
; npc.
 if room<>15 then notinwarren
 x1=currentpos(root)
 if x1=c0 then fvret ; no root!
.notinwarren
;
 x1=VisitTableStart
 add x1,Room
 if x1>VisitTableEnd then fvret
 x2=List7(x1)
 list7(x1)=c0 ; prevent printing it again
 x1=1350 ; base for initial visit
 add x1,x2
 gosub SpecialVisitMessage
 message x1
.fvret
 return
;---
.SpecialVisitMessage
; about to print message x1
; zero x1 if you don't want to!
 return
;---
.printLEAVING
 if verb>15 then NLRet
 verbsave=verb

 cif AllowBoat
;
; moving in the boat
 x1=hicurrentpos(actor)
 if x1=0 then plnotinvehicle ; actor not in vehicle
; x1=currentpos(actor)
; if x1<>boat then plnotinboat ; actor not in boat
;; now check for rooms in which boat is allowed
; if dest<34 then leaveboat
; if dest>36 then leaveboat
;; boat does the move, and user returns in boat
; currentpos(boat)=dest
; hicurrentpos(boat)=hidest
; dest=boat
; hidest=in
; verb=2521 ; 2571-50 - paddled the boat to the
; goto dl1
;.leaveboat
; gosub @printactor ; <actor>
; m1=2512 ; got out of boat
; gosub @printm1
; wanttoprintand=actor
; goto plnotinvehicle ; and went <dir>
;.PLNotInBoat
;
; moving in the steamroller
 x1=currentpos(actor)
 if x1<>steamroller then plnotinsteamroller ; actor not in steamroller
 if actor<>silas then leavesteamroller
; now check for rooms in which steamroller is allowed
; if dest=11 then notleavesteamroller ; smithy is exception
; if dest=12 then notleavesteamroller ; also barn
 if dest<20 then leavesteamroller ; inside
 if dest<60 then notleavesteamroller ; outside
 if dest<80 then leavesteamroller
.notleavesteamroller
 lastrollerroom=currentpos(steamroller) ; save last room for reversing
 lastrollerdir=dir
; steamroller does the move, and user returns in steamroller
 currentpos(steamroller)=dest
 hicurrentpos(steamroller)=hidest
 dest=steamroller
 hidest=in
 verb=2523 ; 2573-50 - drove the steamroller to the
 goto dl1
.leavesteamroller
 gosub @printactor ; <actor>
 m1=2515 ; got out of steamroller
 gosub @printm1
 wanttoprintand=actor
 goto plnotinvehicle ; and went <dir>
.plnotinsteamroller
;
.plnotinvehicle
 cend

 if descriptionmode=inone then nlret

; silas "escorts" ingrid
 x1=hicurrentpos(user)
 verb=2762 ; 2812-50 "escorted ingrid"
 if x1=15 then dl1 ; 15=escorted
.plnotescort

; verb=istruggle
; if dir=iclimb then dl1
; verb=163 ; rook flies
; if actor=rook then dl1
 verb=58 ; go

.dl1
 gosub @printACTORverb ; the npc goes
.printdirectionanddoor
 m1=verboffset ; north-1
 add m1,dir
 gosub @printM1 ; direction
 gosub @printdoor
;
 verb=verbsave ; Bug fix. Graham 17/5/88
 if actor<>user then @printDOT ; print a dot and terminate
 wanttoprintand=user ; followed immediately by description
.desclret
.nlret
 return
;---
.printdoor
 IF DOOR=FALSE THEN DESCLret
 M1=2115 ; through the door
 gosub @checkifgate ;*
 if result=false then @printm1 ;*
 m1=2502 ; through the gate ;*
 goto @printM1
;---
.printARRIVAL
; first print description of object
 if descriptionmode=inone then desclret

 IF actor=user then DESCLRET ; for startup
 if verb>15 then DESCLRet

 cif AllowBoat
; verb=2522 ; 2572-50 - paddled the boat from the
  x1=hicurrentpos(actor)
  if x1=0 then PANotInBoat
  x1=currentpos(actor)
;  if x1=boat then pa2
 verb=2524 ; 2574-50 - drove steamroller from the
  if x1=steamroller then pa2
 
.PANotInBoat
 cend

 VERB=IENTER

.pa2
 object=actor
 gosub @printANobjectVERB ; the npc enters...
 m1=584
 add m1,dir
 gosub @printM1
 gosub @printdoor
 goto @printdot
;---
.TICKCLOCK
; add on time a minute at a time
.TCADDMINUTES
 GOSUB @TIMEDEPENDENTCODE
 add timeinroom,c1
.TCRET
.waitret
.OPENDOORRET
.SAYRET
.OPENRET
.throwret
.abnret
.pushret
.ANLRET
.dlret
 RETURN
;---
.pull
;
 if object=brick then @take
;
 if object=root then @breakroot
;
; start vanes with brake
 if object<>brake then notpullbrake
 m1=2700
 if vanesturning=true then @printm1dot ; vanes already turning
 vanesturning=true
 m1=2701
 goto @printm1dot ; vanes start turning
.notpullbrake
;
; pull lever to lift hook
 if object<>lever then @notpulllever
 m1=2706
 if vanesturning=false then @printm1dot ; no power
 x1=currentpos(hook)
 m1=2707
 if x1=40 then @printm1dot ; lever already at top
 x1=40
 currentpos(hook)=x1
 if currentuserroom=33 then seeleverrise
 if currentuserroom=21 then risethroughwindow
 return ; user not in mill room or mill yard
.risethroughwindow
 m1=2708
 gosub @printm1dot ; see hook rise through window
 goto hookcontents
.seeleverrise
 message 2709 ; see hook rise from yard
 message dot
;
; show contents on hook. used for push & pull lever.
.hookcontents
 searchpos=hook
 hisearchpos=nonspecific
 forceprinting=true ; user is either in mill or yard
 gosub @printobjects ; see contents lifted on hook
 if actorhooked=false then lcret
; show actor who is hooked
 object=actorhooked
 gosub @printtheobject ; <npc>
 m1=2710
 gosub @printm1dot ; waved his arms about etc. (only printed for first npc)
 if actorhooked<>trollchasing then nothooktrollchasing
 trollchasing=false ; stop troll chasing
 chasemoves=false ;*
 goto lcret
.nothooktrollchasing
 if actorhooked<>user then lcret
 x8=actor
 actor=user
 gosub @setuproom ; set up room for printroom
 message cr
 gosub @printroom
 x1=bushes
 currentpos(user)=x1
 x1=in
 hicurrentpos(user)=x1
 gosub @setuproom ; set up currentuserroom. actorhooked=false in timedep.
 actor=x8
 gosub @setuproom ; reset room for actor **bug fix(?)**
.lcret
; don't allow lilys to be lifted (by actor)
 object=greentelelily
 gosub @getobjectposx2
 if x2=40 then objectfalls
 object=bluetelelily
 gosub @getobjectposx2
 if x2<>40 then notobjectfalls
.objectfalls
 x1=33
 currentpos(object)=x1
 hicurrentpos(object)=c0
 message cr
 gosub @printtheobject
 message 2841
.notobjectfalls
 forceprinting=false
 return
.notpulllever
;
 goto @immovable
;
.PUSH
;
; push troll in cellar
 if object>maxnpc then notpushtroll
 gosub @printtheobject
 m1=2774
 if object<ambul then @printm1dot
 if object>gormley then @printm1dot ; not troll
 x1=currentpos(otrapdoor)
 if x1=0 then @printm1dot ; no open trapdoor
; push troll down trapdoor
 x1=6
 currentpos(object)=x1 ; fall into cellar
 m1=2775
 goto @printm1dot
.notpushtroll
;
;stop vanes with brake
 if object<>brake then notpushbrake
 m1=2702
 if vanesturning=false then @printm1dot ; already stopped
 vanesturning=false
 m1=2703
 goto @printm1dot ; vanes stop
.notpushbrake
;
; push lever to lower hook
 if object<>lever then notpushlever
 m1=2706
 if vanesturning=false then @printm1dot ; no power
 x1=currentpos(hook)
 m1=2711
 if x1=33 then @printm1dot ; lever already at bottom
 x1=33
 currentpos(hook)=x1
 x1=42
 gosub @addscore10
 if currentuserroom=33 then seeleverfall
 if currentuserroom=21 then fallthroughwindow
 return ; user not in mill room or mill yard
.fallthroughwindow
 m1=2712
 gosub @printm1dot ; see hook fall through window
 goto @hookcontents ; show contents move on hook
.seeleverfall
 message 2713 ; see hook fall from yard
 message dot
 goto @hookcontents ; show contents move on hook
.notpushlever
;
 goto @immovable
;---
.OPEN
 if noun1<>generalDoor then OpenNotDoor
 IF DOOROPEN=TRUE THEN @ALREADYOPEN
.OpenDoor
;
; barn door
 if room<>222 then notbarndoor
 m1=2723
 if brickcount>4 then @printm1dot ; collapsed
 m1=2722
 x1=currentpos(ashes)
 if x1<>0 then @printm1dot ; locked
.notbarndoor
;
; open gate & pigs get out
 x1=currentpos(guineapigs)
 if x1<>9 then notreleasepigs ; pigs not in pen
; check if pen gate is opened
 if room=8 then pigsreleased
 if room<>9 then notreleasepigs
; pigs released
.pigsreleased
 gosub opendoorok ; open the gate
 x1=8
 currentpos(guineapigs)=x1 ; let the pigs out
 m1=2801
 goto @printm1dot ; show the message
.notreleasepigs
;
; turnips collapse in bedroom
 if room<>22 then opendoorok
 x1=currentpos(turnips)
 if x1=room then opendoorok 
 dooropen=true
 goto @buried
;
.OpenDoorOk
 DOOROPEN=TRUE
 goto @printACTORactiondot

.OpenNotDoor
;
; open trapdoor
 if noun1=otrapdoor then alreadyopen
 if noun1<>ctrapdoor then dontneedtodothat
 gosub istrapdoorblocked
 m1=2773
 if result=true then @printm1dot
 currentpos(ctrapdoor)=c0
 currentpos(otrapdoor)=room
 itword=otrapdoor
 goto @printactoractiondot
;
.DONTNEEDTODOTHAT
 m1=2148 ; you don't need to do that
 goto @errorM1dot
;---
;RESULT=TRUE if trapdoor blocked by heavy object
.istrapdoorblocked
 pos=ctrapdoor
 hipos=on
 object=sack
 gosub @checkobjectpos
 if result=true then itdbret ; sack on trapdoor
 object=millstone
 gosub @checkobjectpos ; true if millstone on trapdoor
.itdbret
 return
;---
.ALREADYOPEN
 M1=2117 ; already open
 GOTO @errorM1dot
;---
.GIVE
 HIPOS=CARRIED
 IF NOUN2=USER THEN GIVENPC
 IF NOUN2<minnpc THEN NOBODYWANTSIT
 IF NOUN2<maxnpcplus1 THEN GIVENPC
 goto nobodywantsit
; IF NOUN2<>NULLOBJECT THEN NOBODYWANTSIT
; GOSUB @ANYBODYHERE
; IF OBJECT=NULLOBJECT THEN NOBODYWANTSIT
; NOUN2=OBJECT
; GOTO GIVENPC
;---
.NOBODYWANTSIT
 M1=2172 ; nobody wants it
 GOTO @ERRORM1dot
;---
.GIVENPC
; giving NOUN1 to NPC NOUN2
 IF NOUN2=NULLOBJECT THEN NOBODYWANTSIT
 OBJECT=NOUN1
 pos=noun2
 GOSUB @MOVEOBJECT
 if result=true then @specialaftergive ;*graham* bug fix
 return ;*graham* bug fix
;---
.THROW
 if noun2=nullobject then @drop
; drop the object...
 pos=room ;** could probably do 'VERB=IDROP, GOTO DROP'
 hipos=0
 gosub @moveobject
 if result=FALSE then @throwret ; not possible
;; if noun2<minnpc then thrownotnpc
;; if noun2>maxnpc then thrownotnpc
;; throw something at someone - so treat as aggressive
;; object=noun1 here
;; gosub ithits ; print what happens
;; blowstrength=1
;; target=noun2
;; gosub makeenemies
;; goto dodamage
;;
;;.thrownotnpc
;; drop through to ithits



.ithits
 verb=ihit
;; object=noun1
 gosub @printOBJECTverb ; prints 'the object hits'
 object=noun2
 gosub @printTHEobject2 ; print out him etc.
 goto @printdot
;---
.CHECKIFLIGHT
; Return RESULT=TRUE if room is illuminated
; (either naturally or by objects etc.)
 goto @ReturnTrue

;---
.BRIEF
.VERBOSE
 NORMALDESCRIPTIONMODE=VERB
 GOTO @DONE
;---
.immovable
 if actor<>user then @actorcantverbnoun1dot
 gosub @printTheObject
 m1=3150 ; won't move
 goto @varyERRORM1dot
;
.cut
.squeeze
.badobject
.cantwear
 goto @actorcantverbnoun1dot
;---
.initlocations
; go through and place the special locations in
; appropriate pseudo-random locations..
.drret
 return
;-----------------------------
.shortdesc ; print the short description for ROOM
; if room<minsynthroomminus1 then descstaticroom
; gosub @convertroom ; is there a special feature here?
; if x1=0 then drsynthesised
;; x1 is room number in special rooms i.e. 1..24
; picturetodraw=x1
; x2=startsynthshortdescs
; add x2,x1
; message x2
;; drop through to print tree/terrain combination at this location
;
;.drsynthesised
;; X1=ROOM
;; GOSUB DRAWPICTUREX1
; x2=minsynthroom
; sub x1,x2
; x1=terraintable(x1)
; x3=800 ; 1020-minsynthroomminus1(220)
; add x3,x1
;.drOnRiver
; message x3
; drop through to descstaticroom - return
;---
.descstaticroom
 picturetodraw=room
 x1=shortroomdescs
 add x1,room
 message x1
 return
;---
.printROOM
 picturetodraw=0
 LASTWORDPRINTED=0 ; prevent printing of 'it'
 GOSUB @POSITIONSHADOWS
 if room=DestToDescribeExitsIn then dr1
 if descriptionmode=inone then drret
;
.dr1
 if actor<>user then drret ; never any description for npcs
 GOSUB @CHECKIFLIGHT
 IF RESULT=TRUE THEN DESCROOM1
 if wanttoprintand=FALSE then dr2
 wanttoprintand=FALSE
 message dot ; not linked to previous message
;
.dr2
 MESSAGE 2021 ; It's dark
 LASTPICTURE=0
 CLS G ; clear graphics window
.DescRoomRet
 RETURN
;---
.DESCROOM1
 GOSUB @SPECIALactor ; print 'You are..'
 GOSUB @SETUPROOM
;
.ABSDESCROOM
 gosub shortdesc
;
 if room<125 then descRoomRemainder ; echo locations.
 if room<151 then @PrintDot

.descroomremainder
 IF DESCRIPTIONMODE<>IBRIEF THEN DESCROOM3A
 if room=DestToDescribeExitsIn then descroom3a ; full desc of destinat
 message dot
 if AutoExits=ivoff then briefexits
 GOSUB @PRINTEXITS
.briefexits
 if normalDescriptionMode<>ibrief then descroom3e
 GOTO DESCROOM3C
;
.DESCROOM3A
 X1=LONGROOMDESCS
 ADD X1,ROOM
 MESSAGE X1
.DESCROOM3
 MESSAGE DOT
 gosub @specialdescbeforeexits
; if OnRiver=True then descroom3c
 if AutoExits=ivoff then descroom3c
 GOSUB @PRINTEXITS
;
.DESCROOM3C
 gosub showpicture ; start selected picture drawing.

.descroom3e
 SEARCHPOS=ROOM
 HISEARCHPOS=0
 GOSUB @PRINTOBJECTS
;>>mike 8/2/88 GOSUB @DESCactor
 GOTO @SPECIALDESC
;---
.showpicture
; displaypicture for room PICTURETODRAW

;*****
; special case to show steamroller in certain rooms
 if room=34 then norollerpic ; waits here
 if room=37 then norollerpic ; and here (tea break!)
 object=steamroller
 gosub @checkifpresent
 x1=27
 if result=true then @drawpicturex1
.norollerpic

 x3=startpicturetable
.scanforpicture
 x2=list5(x3) ; get room
 add x3,c1
 x1=list5(x3) ; get pic
 add x3,c1
 if x2=room then sdrawpicturex1
 if x2<>0 then scanforpicture
;*****

 return

.sdrawpicturex1
;*****
 if x1<>4 then notbarnpic
 if brickcount<5 then notbarnpic
 x1=5 ; show barn collapsed
.notbarnpic
;*****
 goto @DrawPictureX1
;---
.CHECKEXIT
 ceroomsave=room
 room=from
 GOSUB ABSCHECKEXIT
 room=ceroomsave
 GOTO @SPECIALEXITS ; Exits conditional on game
;---
.ABSCHECKEXIT
; EXIT ( From FROM diection DIR )
; return DEST, DOOR, EXITVISIBLE
 door=FALSE
 dest=0
 exitvisible=FALSE
 if room<minsynthroomminus1 then fixedexit
;
; is there a fixed exit here? if so, it will override
; any synthesised exits that might otherwise operate
 gosub @convertroom
; now x1=1..25 if any scenery object is here
 if x1=0 then acesynthesised
 x2=minsceneryobjminus1
 add x1,x2
 EXIT x1 DIR STATUS DEST
 if dest>2 then checkexitstatus ; do rest of fixed exit code ;>>L1 was 1
;>> - allow multiple size grids.
; room 1 gives modifiers for synth rooms.
;>>L2 - also room 2
;
.acesynthesised
; ++++ please note: must have done gosub getXY BEFORE calling
 if dir=8 then acenorth
 if dir>2 then acenotnorth
.acenorth
 if y=ymax then acenoexit
.acenotnorth
 if dir=2 then aceeast
 if dir=3 then aceeast
 if dir<>5 then acenoteast
.aceeast
 if x=xmax then acenoexit
.acenoteast
 if dir=6 then acesouth
 if dir=5 then acesouth
 if dir<>4 then acenotsouth
.acesouth
 if y=0 then acenoexit
.acenotsouth
 if dir<6 then acenotwest
 if dir>8 then acenotwest
 if x=0 then acenoexit
.acenotwest
; look at the exit from room 1 to get the destination modifier
 x1=2 ; >>special to L1 - use exits from room 2 instead of the usual 1
 exit x1 dir status dest
 if dest=0 then acenoexit
 add dest,from
 x1=dest
 x2=256
 gosub @x1modx2
 dest=x1
 exitvisible=TRUE
 return
;
.acenoexit
 dest=0
 return
;
.fixedexit ; See if there any fixed exits from here.
 DOOR=FALSE
 EXITVISIBLE=FALSE
 EXIT ROOM DIR STATUS DEST
 if dest=2 then ceret ; room 1 is used to give ;>>L1 - 2 instead of 1
; move modifiers for synthesised rooms.
 IF DEST=0 THEN CERET
 if dest<minsceneryobj then checkexitstatus
; find room which scenery object DEST is in - becomes destination room

; prs " [dir:"
; print dir
; prs " to object:"
; print dest

 dest=currentpos(dest)

; prs " room:"
; print dest
; prs " ] "

.CHECKEXITSTATUS
 X1=STATUS
 IF X1<4 THEN CE2
 DOOR=TRUE
 X2=4
 SUB X1,X2 ; subtract 4
.CE2
 IF X1>1 THEN CERET
 EXITVISIBLE=TRUE
.CERET
 RETURN
;---
.close
 if noun1<>generaldoor then closenotdoor
 dooropen=FALSE
 goto @printACTORactiondot
;---
.closenotdoor
;
; close trapdoor
 if noun1=ctrapdoor then @dontneedtodothat
 if noun1<>otrapdoor then @dontneedtodothat
 currentpos(otrapdoor)=c0
 currentpos(ctrapdoor)=room
 itword=ctrapdoor
 goto @printactoractiondot
;
 goto @dontneedtodothat
;---
.closedoor
; subroutine called whenever door is to be closed
; (e.g. moving though it)
 if actor<>user then closedoorret
 dooropen=FALSE
;
.closedoorret
 return
;---
.parserun
; verb=isetuprun here
 againverb=isetuprun
 goto parsego1
;
.parsego
 againverb=isetupgo
; verb=isetupgo here
.parsego1
; return noun1 as room number of destination
 noun1=nullobject
;>>removed by L2 treetype=0
;>>removed by L2 terraintype=0
.gad1
 adjective1=nullobject
 adjective2=nullobject
 treatasfind=FALSE
 gosub getpart
 if gperror=TRUE then baddestination
 if treatasfind=TRUE then parsefindvalue
 if verb=0 then gadnotmove
 if verb<maxdirectionplus1 then gadend ; exit tidily for 'GO EAST'
.gadnotmove
 if noun1<>nullobject then gadend ; exit tidily for 'go interesting place'
 goto baddestination
;
.gadend
; clean up rest of input - may be useful, intelligent stuff,
; or it may be complete garbage
; Loop until we get a verb
 if nomoreinput=TRUE then gadret
 gosub @getnextword
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then gadend
 gosub @goback ; retrieve verb for later parsing
.gadret
 againnoun1=noun1
 noun2=nullobject
 return
;---
.parsefindvalue
; user entered 'go moveable object'
; treat as find
 if verb<>isetuprun then pfv1
 descriptionmode=inone
;
.pfv1
 verb=isetupfind
 noun1=value
 noun2=nullobject
 prep=0
 return
;---
.baddestination ; a parser error
 gosub @stop
 noun1=nullobject
 verb=0
 goto @cantseewhere
;---
.getparterror
 gperror=TRUE
 return
;---
.getpart
; return noun1 as destination room,
; or verb=direction to move in
; or treetype/terraintype
 gperror=FALSE
 gosub @getnextword
 if eol=TRUE then getparterror
; just possibly, could be a direction
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then getpart1
 if value=ivto then getpart ; go to ...
 if value>maxdirection then getpart1 ; strange verb
 verb=value
 return
;
.getpart1
 searchtype=adjetype
 gosub @checktype
 if value=nullvalue then getpart2
 adjective1=value
 gosub @checktypemore
 if value=nullvalue then getpart2
 adjective2=value
;
.getpart2
 index=0
.goloop
 searchtype=nountype
 gosub @checktypemore

 if value=nullvalue then getpart ; ignore garbage words here.
 if value>mingarbage then getpart
 if adjective1=nullobject then goloopnoadjective
 if value=adjective1 then goloopnoadjective ; could be right dest
 if adjective2=nullobject then goloopnoadjective
 if value>adjective2 then goloopnoadjective
 if value<>adjective2 then goloop ; can't be right destination
;
.goloopnoadjective
 if value>maxsceneryobj then goloopnotlocationobject
;
.golooptreatasfind
; does object exist in game?
 x1=currentpos(value)
 if x1=0 then goloop
 treatasfind=TRUE
 return
;
.goloopnotlocationobject
; maybe 'go static location'
; if so, extract room number
 if value<500 then goloop ; shortroomdescs-nounoffset
 x1=500 ; shortroomdescs-nounoffset
 noun1=value
 if value<800 then goloopshortdescs ; longroomdescs-nounoffset
 x1=800 ; longroomdescs-nounoffset
.goloopshortdescs
 sub noun1,x1
 return
;---
.gdgoxy
 if y<noun2 then gdgonorth
 if y>noun2 then gdgosouth
; y=y1; so just go east or west
 if x=noun1 then @followfinished ; have arrived at destination, terminate command
 dir=3 ; east
 if x<noun1 then gdgotdir
 dir=7
 goto gdgotdir
;
.gdgosouth
 dir=4 ; south
 if x=noun1 then gdgotdir
 dir=5 ;se
 if x<noun1 then gdgotdir
 dir=6 ;sw
 goto gdgotdir
;
.gdgonorth
 dir=1 ; north
 if x=noun1 then gdgotdir
 dir=2 ;ne
 if x<noun1 then gdgotdir
 dir=8
; fall through to gdgotdir
.gdgotdir
 intendeddirection=dir
 anglefromintended=0
;;>>mike 8/2/88 gdroomsave=room
 gdCurrentSave=currentpos(actor) ;>>mike 8/2/88
 gdHiSave=hicurrentpos(actor) ;>>mike 8/2/88
.gdtrydir
 from=room
 dir=intendeddirection
 gosub adddir
;
 gosub @checkexit
 if exitvisible=FALSE then tryanotherdirection
 if dest<minsynthroomminus1 then tryanotherdirection
; if dest=126 then tryanotherdirection
; if dest=125 then tryanotherdirection
; if dest=118 then tryanotherdirection
 hidest=0
 verb=dir
 commandfinished=FALSE
 gosub @move ; move the npc, describing as appropriate
;
; if a specialmoves trap was activated, we have to abort the
; find. (Because a message will have been printed, so continuing
; would just confuse the player. A better tracking algorithm
; in future games MIGHT be able to get round this)
 if blockedbysm=TRUE then @reportProblem ;>>mike 8/2/88 
;         >>8/2/88 followjustfinished ; something badly wrong.


;>>mike 8/2/88 if room=gdroomsave then tryanotherdirection ; something went wrong
; x1=currentpos(actor) ;>>mike 8/2/88
; if x1<>gdCurrentSave then gdt1
; x1=hicurrentpos(actor) ;>>mike 8/2/88
; if x1=gdHiSave then tryanotherDirection

.gdt1
 if room=destnoun1 then @followjustfinished
 return ; all went well.
;---
.tryanotherdirection
; have reached an obstruction in a goaldirected movement
 if anglefromintended>negative then tad2 ; am wheeling to left
 if anglefromintended<>0 then tad1 ; am wheeling to right
 anglefromintended=1
 goto gdtrydir
;---
.tad1
; was not going in intended direction when the obstruction
; was reached
; try wheeling round to right (clockwise)
 if anglefromintended=2 then tad2a
 add anglefromintended,c1 ; try +1, +2
 goto gdtrydir
;---
.tad2a
 anglefromintended=0
.tad2
; try wheeling round to left
 if anglefromintended=65534 then @cantgothere ; can't cope at present
 sub anglefromintended,c1 ; try -1,-2
 goto gdtrydir
;---
;>>mike 28/3/88 .cantgothere
;>>mike 28/3/88  if actor<>user then @NpcNotUnderstood
;>>mike 28/3/88  m1=3605 ; can't go there from here ;>>mike 28/3/88
;>>mike 28/3/88  gosub @printM1dot
;>>mike 28/3/88  goto @followfinished
;---
.adddir
; do add dir,anglefromintended
; this is complicated because south,southeast are swapped round
; Also must wrap round at north, northwest
;
; first, swap south,southeast
 gosub swapdir
 add dir,anglefromintended
 gosub makedirwithinbounds
; fall through to swapdir ; and swap back again
;
.swapdir
; swap round south, southeast
 if dir<>4 then swapdirnotsouth
 dir=5
 return
;---
.swapdirnotsouth
 if dir<>5 then swapdirret
 dir=4

.swapdirret
 return
;---
.makedirwithinbounds
 if dir<9 then mdwb1
 dir=1
 return
;---
.mdwb1
 if dir>0 then mdwb2
 dir=8
.mdwb2
.diwtret
.mmdret
.teleportret
.ringret
 return
;---
.teleport
 cif allowCheat
; we came here straight from the parser, so set up verb...
 if cheatmode=0 then @nicetry
 verb=iteleport
.allowteleport
 gosub @parsego
 if noun1=nullobject then teleportret
 if verb<>isetupfind then teleporttonoun1
 object=noun1
 gosub @getobjectposx2
 noun1=x2
;
.teleporttonoun1
 dest=noun1
;
.magicmove
 hidest=0
;
.magicmovedest
 if dest=0 then mmnomove
 if dest<2 then @cantseewhere
 currentpos(actor)=dest
 hicurrentpos(actor)=hidest
.mmaftermove
 gosub @setuproom
 gosub @getxy
 if actor<>user then mmdret
 currentuserroom=room
 gosub @printroom
 GOTO @CANCELINPUT
;---
.mmnomove
 cend

 m1=2995 ; you end up where you were
 gosub @printM1dot
 goto @cancelinput ; goto mmaftermove
;---
.noexit
 m1=2114 ; no exit!
 goto @errorM1dot
;---
.dig
 x1=currentpos(turnips)
 m1=2511
 if x1<>room then @errorm1dot
 object=turnips
 noun1=turnips
 noun2=nullobject
 prep=0
 gosub @printactoractiondot ; dig turnips
;
; empty all objects out of turnips and into ROOM, rescuing any NPCs
.emptyturnips
 object=1
 x8=22
.emptyturnips1
 x1=currentpos(object)
 if x1<>turnips then objectnotinturnips
 x1=hicurrentpos(object)
 if x1=0 then objectnotinturnips
; object is in turnips
 currentpos(object)=x8
 hicurrentpos(object)=c0
 if object>maxnpc then objectnotinturnips
 gosub @printtheobject ; <npc>
 m1=2512 ; was rescued
 gosub @printm1dot
.objectnotinturnips
 add object,c1
 if object<maxmoveaplus1 then emptyturnips1
 return
;---
.forcem1dot
 message m1
 message dot
.snapret
.PlayRet
 return
;---
.ring ; ring/play
 m1=282 ; no!
 goto @printm1dot
;---
.snap
; snap fingers
.plant
 goto @noverb ;** remove verb?
;-
;---
.drink
 m1=285 ; bleuch
 goto @errorm1dot
;---
;---
.NotWaterTight
 gosub @printTheObject
 m1=2595 ; not watertight
; m1=2596 ; already full
.NWT1
 goto @printm1Dot
;---
.fill
; cup/chalice
 goto NotWatertight

;.NoWater
; m1=2037 ; no water/nothing suitable
; goto @printm1 ; no dot!

;---
.make
; Make sign of cross
; if noun1=250 then makeSign
; if noun2<>250 then @actorcantverbnoun1
;.makeSign
; m1=2506 ; made sign of cross
; gosub ActorM1Dot

;; Now special cases for destroying fiends
; if room<>13 then CrossNotPriest
; m1=2507 ; "vanished in a puff of evil"
; object=Priest
;.CrossObject
; gosub @checkifpresent ; make sure the object is here
; if result=false then CrossRet
;
; if m1=0 then DestroyObject
; gosub @printTheObject
; gosub @printm1dot
; goto DestroyObject
;
;.CrossNotPriest
; if room<>5 then CrossNotPavillion
;; m1=2508 ; pavillion vanished
;.DestroyPavillion
; ;m1=2507
; object=pavillion
; gosub CrossObject
; object=Damosel
; goto CrossObject

.CrossRet
 return
;---
.eat
 m1=107 ; Yeuch!
 goto @errorm1dot
;----
;.GENERALBLOW
;; given TARGET,ACTOR (WHO IS ATTACKING)
;; do an ordinary (non-magical) blow
;;
; IF ACTOR=TARGET THEN @mighthurtyourself
;; object=target
;; gosub @isobjectalive
;; if result=true then gbalive
;; if target>maxpeople then @silly
;; m1=3509 ; what harm could a dead body do you?
;; goto @errorm1dot
;;
;;.gbalive
;; first calculate blow strength
; X1=ATTACKOFFSET
; ADD X1,ACTORATTRIBUTES
; BLOWSTRENGTH=NPCINITIAL(X1)
;; IF WEAPONSTRENGTH<BLOWSTRENGTH THEN GB1
;; BLOWSTRENGTH=WEAPONSTRENGTH
;.GB1
;; GOSUB @RANDOMIZEBLOWSTRENGTH
;; DO A GENERALBLOW
;; now do the blow
;; with strength BLOWSTRENGTH
;; see if target dodges
;; OBJECT=TARGET
;; GOSUB @SetX4ToObjectAttributes
;; X1=DODGEOFFSET
;; ADD X1,X4
;; x6=npcinitial(x1)
;; random x1
;; IF X1>X6 THEN GBNDODGE
;;
;;.describedodge
;;; you bet, so print "you attack the klingon"
;; verb=40 ; attack
;; gosub @describeattackverb
;; m1=3517 ; but
;; gosub @reportm1
;; object=target
;; lastwordprinted=object ; force printing of article
;; verb=idodge
;; gosub @objectverb
;; m1=dot
;; goto @reportm1
;;
;;.GBNDODGE
; GOSUB @DESCRIBEATTACK ; first part of report
; m1=dot
; gosub @Printm1
;
;.gbnnodescription
;; GOSUB @CHECKARMOUR
;;; returns X1=object number of armour worn (0 if none)
;; IF X1=0 THEN GBH
;;; damage/destroy shield etc.
;; M1=3511 ; blow strikes its
;; IF TARGET<>USER THEN GBSHIELD
;;; M1=3510 ; blow strikes your
;;.GBSHIELD
;; gosub @reportm1
;; GOSUB @DESCOBJX1 ; describe armour etc.
;;.gbnodesc
;; IF X1<>SHIELD THEN GBARMOUR
;; SUB SHIELDSTRENGTH,BLOWSTRENGTH
;; IF SHIELDSTRENGTH=0 THEN GBSHATTER
;; IF SHIELDSTRENGTH>NEGATIVE THEN GBSHATTER
;; X2=SHIELDSTRENGTH
;;.GBEND
;; MESSAGE 3525 ; (which has
;; PRINT X2 ; strength of armour remaining
;; MESSAGE 3526 ; hit points left).
;;.GBRET
;; RETURN
;;
;;.GBSHATTER
;; CURRENTPOS(X1)=C0
;; M1=3514 ; shattering it.
;; goto @reportm1
;;
;.GBH
;; target not wearing armour or whatever,
;.DODAMAGE
; OBJECT=TARGET
; GOSUB @SetX4ToOBJECTAttributes
; X1=HITPOINTOFFSET ; find hit points
; ADD X1,X4
; hitpoints=NPCCURRENT(X1)
;;
; cif AllowCheat
;  if target<>user then gbhnocheat
;  if cheatmode<>false then ddnotdead
;
;.gbhnocheat
; cend
;;
; SUB hitpoints,BLOWSTRENGTH
; if hitpoints<negative then ddnotdead
; hitpoints=0
; 
;.ddnotDead
; npccurrent(x1)=hitpoints
;; describe hit points remaining on target
; gosub reporthealth
; if hitpoints<>0 then @makeenemies
;; drop through to death
; goto targetdeath
;;-
;.reporthealth
;; describe hit points remaining on target
; OBJECT=TARGET
;.reporthealthobject
;; x1 must be set up (see below in code)
; verb=82 ; you are/it is
; x6=x1 ; preserve position in npcxxx()
; gosub @PrintObjectverb
; if hitpoints=0 then dddead
; x1=npcinitial(x6) ; initial hit points
; x2=10
; gosub @x1divx2
;; x1=number of points for each health report division
; x2=x1
; x1=hitpoints
; gosub @x1divx2
; if x1>0 then printhealth
;.dddead
; x1=0 ; dead!
;.printhealth
; if x1<10 then PrintHealth1
; x1=9
;.PrintHealth1
; m1=2560 ; health report
; add m1,x1
;.PrintHealthPrint
; if m1<>2560 then PrintHealthPrint1
; if hitPoints=0 then PrintHealthPrint1
; m1=2561 ; not quite dead yet
;.PrintHealthPrint1
; goto @Printm1dot
;-

;---
;.DESCRIBEATTACK
; gosub @printactor
; m1=2540 ; smote
; gosub @printm1
; object=Target
; goto @printTheObject


; first part of damage report for ACTOR vs TARGET
;
; now pick out the appropriate verb - from "scratch"
; through to "pulverise"
; x1=blowstrength ; (approx 1..40)
; x2=4 ; ( want 10 divisions, 0..9)
; gosub @x1divx2
; if x1<10 then daok
; x1=9 ; max blow
;.daok
; verb=170 ; armed blows
; if weapon<>nullobject then da1
; verb=180 ; unarmed blows ( relative to verboffset)
;.da1
; add verb,x1 ; appropriate attack verb
;.describeattackverb
; noun1=target
; prep=with
; noun2=weapon
; goto @printActorAction
;---
;---
;.CHECKARMOUR
;; return X1=object number of armour worn by TARGET or X1=0 if none
;.CAFAIL
; X1=0 ; no armour found
;
;.CARET
; RETURN
;---
;---

.actordeath
 target=actor

.targetdeath

 if target>54 then KillGoody
 if target>18 then targetDeathNotGoodKnight
.KillGoody
 x1=100
 sub GeneralScoreAddition,x1

.targetDeathNotGoodKnight


;; enemies don't hate it any more...
 x4=enemyoffset
.targetdeath1
 x1=npccurrent(x4)
 if x1<>target then targetdeath2
 npccurrent(x4)=c0
.targetdeath2
 x1=npcentrysize ; 16 ; npcentrysize
 add x4,x1 ; npc entry size
 if x4<npctablesize then targetdeath1


; set target to have 0 hit points (for benefit of NPC.TXT, if nowt else)
 OBJECT=TARGET
 GOSUB @SetX4ToOBJECTAttributes
 X1=HITPOINTOFFSET ; find hit points
 ADD X1,X4
 npccurrent(x1)=c0
 HIPOS=CARRIED ; only drop carried things, not worn etc.
 POS=TARGET
 DEST=ROOM
 HIDEST=0
 GOSUB @POSSLOOP ; drop everything
 actorsave=actor
 actor=target
 GOSUB @stop ; don't let it continue with commands !!!
 actor=actorsave
 currentpos(target)=c0
 if target=user then @userDeath
 return
;---
;---
.REMOVE
; also FREE, RELEASE
 POS=ACTOR
 HIPOS=CARRIED
 GOTO @MOVEOBJECT
;---
.gameAfterRestore
 GOSUB @PRINTROOM

;; if we've just chained, does anyone want to join us from the other part?
; if room<>227 then GARNotChained
; object=2
;.GARLoop
; x1=currentpos(object)
; if x1<>59 then GARNoFollow
; x1=hicurrentpos(object)
; if x1<>0 then GARNoFollow
;; there, are they following?
; gosub SetX4ToObjectAttributes
; x1=followOffset
; add x1,x4
; x1=npccurrent(X1)
; if x1<>user then GARNoFollow
;.GARFollow
; x1=enemyOffset
; add x1,x4
; npccurrent(x1)=c0 ; make them active!
; currentpos(object)=room
; hicurrentpos(object)=c0
;
;.GARNoFollow
; add object,c1
; if object<19 then GARLoop
;
;.GARNotChained
 actor=user
 gosub @stop
 GOTO @getfromuser
;---
