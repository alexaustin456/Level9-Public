;'RAM' and 'OOPS' for Converted Trilogies

;Copyright (C) 1986 Level 9 Computing

;B:OOPS.TXT

;-----

VAR
 SAVEL90 SAVEL91 SAVEL92 SAVEL93 ;> NICK 12/8/86

BEGIN

;'RAM SAVE  or 'RAM LOAD'

.RAMCOMMAND
 GOSUB @PARSEINPUT ;>> MIKE 18/8/86
 VALUE=VERB ;>>MIKE 18/8/86
 IF VALUE=IRESTORE THEN RAMLOAD

;Otherwise it's a RAM SAVE:

 PARSEX2=C0 ; first position
 GOSUB @RAMWRITE
.RAMSAVEEND
 IF RESULT<>C0 THEN NOTAVAILABLE
 MESSAGE OK
 GOTO @ENDCOMMAND

.NOTAVAILABLE
 MESSAGE 4300 ;Not available            >> ANDY 14 8 86
 GOTO @CANCELINPUT

;'RAM' keyword followed by LOAD/RESTORE

.RAMLOAD
 PARSEX2=C0 ; first position
 GOSUB @RAMREAD
 IF RESULT=C0 THEN @AFTERRESTORE 
 MESSAGE 4300 ;Not available            >> ANDY 14 8 86
 GOTO @CANCELINPUT

;-----

.INITOOPS
; count number of oops positions available
 LASTOOPSROOM=0
 OOPSPOSEND=C0
 OOPSPOS=C0
 NEXTOOPSPOS=C0
 NEXTOOPSEND=C0

 PARSEX2=1
 GOSUB @RAMWRITE
 IF RESULT=C0 THEN INITOOPS1

 PARSEX2=C0
 GOSUB @RAMWRITE
 IF RESULT<>C0 THEN INITOOPSRET ;No RAM SAVE
 MESSAGE 4301 ;Only RAM SAVE available  >> ANDY 14 8 86
 GOTO INITOOPS2

.INITOOPS1
 OOPSPOS=C1
 NEXTOOPSPOS=C1
 MESSAGE 4302 ; ram and oops available  >> ANDY 14 8 86

; now go through and write 'certified garbage' to all positions
.INITOOPS2
 C2=65000 ; show that positions are invalid
.INITOOPS3
 GOSUB @RAMWRITE
 ADD PARSEX2,C1
 IF RESULT=C0 THEN INITOOPS3
 C2=2 ; restore C2
.INITOOPSRET
 RETURN

;-----

.OOPS
 GOSUB TRYOOPS
 IF RESULT=TRUE THEN @AFTERRESTORE

.ENDCOMMAND ;>>MIKE 12/8/86
 RETURN ;>>MIKE 12/8/86 GOTO @ENDCOMMAND
;>>MIKE12/8/86 GOTO @ENDCOMMAND

.TRYOOPS
; OOPSPOS points to next free position in ram save area
; go back some positions if they are available
 IF OOPSPOS<>C0 THEN OOPS1
 MESSAGE 4300 ;Not available            >> ANDY 14 8 86
 RESULT=FALSE
 RETURN

.OOPS1
 IF OOPSPOS<>C1 THEN OOPS3
; have gone to position 0, so need to wrap round to end of ram area
 IF OOPSPOSEND<>C0 THEN OOPS2

 MESSAGE 4304 ;No OOPS position found   >> ANDY 14 8 86
 RESULT=FALSE
 RETURN

.OOPS2
 OOPSPOS=OOPSPOSEND ; first invalid position

.OOPS3
 SUB OOPSPOS,C1
 PARSEX2=OOPSPOS
 GOSUB RAMREAD
 NOMOREINPUT=TRUE
 RESULT=TRUE
 RETURN

;-----

.SAVEOOPS
; OOPSPOS points to the next free position in ram save area
; this routine called on EVERY movement
; try writing to current position

 IF VERB=IOOPS THEN SAVEOOPSRET ;>> NICK 27/6/86 - was I1
 IF OOPSPOS=C0 THEN SAVEOOPSRET ;OOPS not available
 if room=lastoopsroom then saveoopsret ;>>mike 26/10/86
 LASTOOPSROOM=ROOM ; - was R1 - MIKE 18/8/86
.SAVEOOPS1
 PARSEX2=oopspos
 GOSUB RAMWRITE
 IF RESULT=C0 THEN SAVEOOPSOK ; fine, inc pointer and finish
; something went wrong.
; if we are in the first position, tell the user
; that it is not available here
 IF OOPSPOS<2 THEN SAVEOOPSRET ; keep quiet, ignore the error
; ok, so have some saved positions. Rotate round cyclically
 OOPSPOSEND=OOPSPOS ; save first invalid position
 OOPSPOS=C1
 GOTO SAVEOOPS1

.SAVEOOPSOK
 ADD OOPSPOS,C1
.SAVEOOPSRET
 return
;-----
.RAMREAD
 PARSEX1=23 ; code for ramload
 GOSUB RAMOPERATION
 IF C2<>2 THEN RAMERROR ;Do not use C2. Check for corrupted variables
 RETURN

.RAMERROR
 MESSAGE 4303 ; Must RAM SAVE first     >> ANDY 14 8 86
 GOTO @ABORTGAME

;-----

.RAMWRITE
 PARSEX1=22 ; code for ramsave
; drop through to RAMOPERATION

.RAMOPERATION
; write to position PARSEX2, return RESULT=0 if OK
 SAVEL90=LINPUT(C0)
 SAVEL91=LINPUT(C1)
 SAVEL92=LINPUT(C2)
 SAVEL93=LINPUT(C3)

 LINPUT(C0)=PARSEX1
 LINPUT(C1)=PARSEX2 ; position number
 LINPUT(C2)=C0
 DRIVER
 C0=0 ;In case variables are corrupted.
 RESULT=LINPUT(0)

;Now restore LIST 9. However variables may have been corrupted.
 LINPUT(0)=SAVEL90
 LINPUT(1)=SAVEL91
 LINPUT(2)=SAVEL92
 LINPUT(3)=SAVEL93
 RETURN
;
;-----
