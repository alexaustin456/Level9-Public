;Parser for Converted Trilogies

;Copyright (C) 1986 Level 9 Computing

;B:APARSE.TXT

;>> NICK 1/7/86 "MARKOBJECT" changed to allowed optionally coloured
;>> NICK 1/7/86 buttons

CONST
 SIGNIFICANT=235

VAR
 CSAVEHISEARCHPOS EVENTUALPREP
 WANTWHATNOW
 alreadyprintedscenery
 colour

TABLE ;>>
 TEMPLISTBASE=2 ;>>

BEGIN
.CANCELINPUT
; something of great importance has happened - remove
; rest of input from line
 GOSUB @CLEARINPUT
 NOUN1=NULLOBJECT ;>>
 EVERYTHING=FALSE ;>>
 CURRENTOBJECT=NULLOBJECT ;>>
 GOTO @RESETSTACK
;
;---
.PRESENTMULTIPLE
; GIVEN VERB,PREP,NOUN2 AND OBJECTTABLE,
; CALL VERB ONCE FOR EACH OBJECT SPECIFIED BY OBJECTTABLE
; EVERYTHING, IT ETC. ARE HANDLED HERE
; Work down from top so static objects, containers come first
 MESSAGE CR
 DIR=C0 ; prevent some SPECIALMOVES being triggered
 GOSUB @CONVERTVERB

 IF VERB=C0 THEN NOAGAIN1
 AGAINVERB=VERB
.NOAGAIN1

 GOSUB @SELECTOBJECTPOS
;
;; ??? as a kludge - test here to see if NOUN2 is present
; IF NOUN2=NULLOBJECT THEN PM1
; OBJECT=NOUN2
; GOSUB CHECKIFPRESENT
; IF RESULT=FALSE THEN CANTSEEIT

;>>.PM1
 IF EVERYTHING=TRUE THEN PMEVERYTHING
; handle individual objects
 CURRENTOBJECT=C1 ; pointer into OBJECTTABLE
.PMSINGLE1
 OBJECT=OBJECTTABLE(CURRENTOBJECT)

 IF OBJECT=C0 THEN PMSINGLEEND

; GOSUB @CHECKIFACCESSIBLE
; IF RESULT=TRUE THEN PMSINGLE2
; GOSUB @OBJECTNOTHERE
; HAVECALLEDVERB=TRUE
; GOTO PMSINGLENEXT
;.PMSINGLE2
 NOUN1=OBJECT
 HAVECALLEDVERB=TRUE
 GOTO CALLVERB ;>> was GOSUB

.PMSINGLENEXT
 ADD CURRENTOBJECT,C1
 GOTO PMSINGLE1

.PMSINGLEEND
 IF HAVECALLEDVERB=TRUE THEN @GETNEWINPUT ;>> was PMSINGLERET
 NOUN1=NULLOBJECT
 GOTO CALLVERB ;>> was GOSUB

;---
.PMEVERYTHING
 CURRENTOBJECT=MAXOBJECTVISIBLE
 NOUN1=NULLOBJECT
.PMEV1
;
; check if object if forbidden
;
 OBJECT=CURRENTOBJECT

;>>> IF OBJECT=153 THEN PMEV3 ;>> For Dungeon. Exclude 'KEY' from 'ALL'
;>> IF OBJECT=61 THEN PMEV3 ;>>For Quest. Exclude 'COMPASS' from 'ALL'
;>> IF OBJECT=95 THEN PMEV3 ;>> NICK 2/7/86 Exclude coffin
 
 GOSUB @CHECKIFACCESSIBLE

 IF RESULT=FALSE THEN PMEV3

; SEARCHDEPTH=1
; GOSUB @CHECKIFOBVIOUS
; IF OBVIOUS=FALSE THEN PMEV3

 GOSUB @CHECKIFFORBIDDEN
 IF RESULT=TRUE THEN PMEV3

 NOUN1=CURRENTOBJECT
 HAVECALLEDVERB=TRUE
 GOTO CALLVERB ;>> was GOSUB

.PMEV3
 SUB CURRENTOBJECT,C1
 IF CURRENTOBJECT>MINOBJECT THEN PMEV1
 NOUN1=NULLOBJECT ;>> added
 IF HAVECALLEDVERB=TRUE THEN @GETNEWINPUT ;>>was PMRET
 GOTO CALLVERB ;>> was GOSUB

;---
.CALLVERB
; GIVEN VERB,PREP,NOUN1,NOUN2,
; DO THE JUMP-TABLE INDEXING ON THE VERB

 MESSAGE CR
; CSAVEHISEARCH=HISEARCHPOS

 IF NOUN1=NULLOBJECT THEN CALLVERBNODESC
 IF EVERYTHING=TRUE THEN CALLVERBDESC
 IF VERBSTOCALL<C2 THEN CALLVERBNODESC
.CALLVERBDESC
; IF PLAYER<>USER THEN CALLVERBNODESC

 IF EVERYTHING=FALSE THEN NOXXX ;>>>
 ITWORD=NOUN1                   ;>>>
.NOXXX                          ;>>>

 IF NOUN1=SIGNIFICANT THEN CALLVERBNODESC ;>>
 PARSEX1=NOUN1
 GOSUB @DESCOBJPARSEX1
 MESSAGE COLON

.CALLVERBNODESC
 GOTO @GETEND1 ;>> was GOSUB ABSCALLVERB

; HISEARCHPOS=CSAVEHISEARCH
; RETURN
;;---
.CHECKIFACCESSIBLE
; return RESULT=TRUE if OBJECT is accessible to VERB
; objects must be present in way HISEARCHPOS
 IF OBJECT<NUMBEROFFSET THEN CIANOTNUMBER
 IF OBJECT>HINUMBEROFFSET THEN CIANOTNUMBER
 PARSEX1=NUMBEROFFSET
; OBJECT=BUTTONS

.CIANOTNUMBER
 IF OBJECT>MAXOBJECT THEN @CHECKIFSCENERYHERE
;
 IF HISEARCHPOS<>NONSPECIFIC THEN CIANOTNS
 GOSUB @ISOBJECTHERE
 IF RESULT=TRUE THEN CIAHAVECHECKED
 GOTO CIAISITOWNED

.CIANOTNS
 IF HISEARCHPOS<>NOUNCARRIED THEN CIANOTCARRIED
.CIAISITOWNED
 GOSUB @ISOBJECTCARRIED
 GOTO CIAHAVECHECKED

.CIANOTCARRIED
 GOSUB @ISOBJECTHERE
;
.CIAHAVECHECKED
 RETURN
.CIATRUE ;>>MIKE 28/7/86
 RESULT=TRUE ;>>MIKE 28/7/86
 RETURN ;>>MIKE 28/7/86
;---
.PRINTINPUTWORD
 MESSAGE QUOTE
 PRINTINPUT
 MESSAGE QUOTE
 RETURN
;---
.PARSENOTKNOWN ; WORD NOT RECOGNIZED
 MESSAGE 2005 ; I don't know the word
 GOSUB PRINTINPUTWORD
 PARSEM1=C0
 GOTO PARSEERROR
;---
.SECONDPREP
.PARSENOVERB
.CANTUSEHERE
; IF PLAYER<>USER THEN NPCNOTUNDERSTOOD
 MESSAGE 2003
 GOSUB PRINTINPUTWORD
 PARSEM1=2004
 GOTO PARSEERROR
;---
.NOTCLEAR
; User has referred to a piece of scenery which is not nearby
; IF PLAYER<>USER THEN NPCNOTUNDERSTOOD
 PROCESSED=TRUE ;>> MIKE 21/6/86
 ITWORD=NULLOBJECT
 OBJECT=C0
 HAVECALLEDVERB=TRUE
 message 2020 ; I can find no mention of "
 PRINTINPUT
; MESSAGE COLON
 MESSAGE 2021 ; "here >>mike 8/9/86
 RETURN
;---
.DONTUNDERSTAND
; general error message when the parsing has borken
; down for some reason
 PARSEM1=2010
; drop through to PARSEERROR
;-
.PARSEERROR
; IF PLAYER<>USER THEN NPCNOTUNDERSTOOD
 MESSAGE PARSEM1
 MESSAGE DOTCR
 GOTO @CANCELINPUT
;---
.PARSEINPUT
; CONVERT INPUT TO VERB, PREP, OBJECT FORM FOR
; EASY UNDERSTANDING BY THE REST OF THE PROGRAM

 HAVECALLEDVERB=FALSE
 GOSUB @GETNEXTWORD
 VERB=C0
; NOUN1=C0 ;>>*
; EVERYTHING=C0 ;>>*
; HAVECALLEDVERB=FALSE ;>>*
 IF EOL=TRUE THEN @PIEND; NOTHING ENTERED !
;
;; is player trying to talk to someone ?
; SEARCHTYPE=NOUNTYPE
; GOSUB @CHECKTYPE
; IF VALUE<NPCBASE THEN PINOTNPC
; IF VALUE>NPCMAX THEN PINOTNPC
;; yes, so is the target here ?
; OBJECT=VALUE
; GOSUB CHECKIFPRESENT
; IF RESULT=TRUE THEN PINPC
; MESSAGE 2060 ; talking to yourself ?
; GOTO CLEARINPUT
;
;>>.PINOTNPC
 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 IF VALUE<>C0 THEN PI0

 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPE
 IF VALUE>NEGATIVE THEN @PARSENOVERB ;>>
 IF VALUE>IGARBAGE THEN PARSEINPUT ; CONJUNCTION ENTERED, SO TRY AGAIN
 GOTO @PARSENOVERB ; Wrong type of word found

.PI0
 IF VALUE<>IAGAIN THEN PI0A

 VERB=AGAINVERB
 GOTO @PIEND ;>> IF LASTVERBVALID=TRUE THEN @PIEND

;>>.LASTVERBINVALID
; IF PLAYER<>USER THEN NPCNOTUNDERSTAND
;>> PARSEM1=2050 ; last verb not valid
;>> GOSUB @VARYMESSAGE
;>> GOTO @CANCELINPUT

.PI0A
 VERB=VALUE

 IF VERB=C0 THEN NOAGAIN2
 AGAINVERB=VERB
.NOAGAIN2

;>>.VERBPLUS
 OBJECTTABLE(C0)=C0
 OBJECTTABLE(C1)=C0
 EVERYTHING=FALSE ; EVERYTHING NOT DETECTED YET
 EXCEPT=FALSE ; EXCEPT NOT DETECTED YET
 PREP=C0
 EVENTUALPREP=C0
 NOUN1=NULLOBJECT ; NEEDED ?
 NOUN2=NULLOBJECT
 VERBSTOCALL=C0
 LASTVERBVALID=FALSE

; IF VERB=IGETME THEN @GETME ;*
 IF VERB<9 THEN PIEND ; directions have no objects, but
; things like IN, CLIMB CAN have objects e.g. ON TABLE

; VERB MAY BE FOLLOWED BY SOMETHING ELSE
 GOSUB @CONVERTVERB
 GOSUB @SELECTOBJECTPOS

.PINEXT
;>>.PIANOTHERNOUN
 GOSUB @GETNEXTWORD

 IF SEPARATOR=TRUE THEN PINEXT
 IF EOL=TRUE THEN PIEND
;>>.PINEXT1

; IF VERB=ISAY THEN @SAY
; IF VERB=IDROP THEN PINOTPREP ; DROP BENCH AND ON

 if room<>28 then picouldbeprep ; in house plant
 if verb=itake then pinotprep ; take fish fungus and out

.picouldbeprep

 SEARCHTYPE=PREPTYPE
 GOSUB @CHECKTYPE

;>>MIKE 29/7/86;"LOOK AT" = "EXAMINE"
;>>MIKE 29/7/86 IF VALUE=C0 THEN PINOTPREP  ;>>
;>>MIKE 29/7/86 IF VERB<>ILOOK  THEN PIPREP ;>>
;>>MIKE 29/7/86 VERB=IEXAMINE               ;>>
;>>MIKE 29/7/86 VALUE=C0                    ;>>
 IF VALUE<>C0 THEN PIPREP

.PINOTPREP
 OBJECT=VALUE
 GOSUB @CHECKNOUN

 IF OBJECT<>C0 THEN PIEXAMINENOUN
 IF PROCESSED=TRUE THEN PINEXT

 SEARCHTYPE=ASCITYPE
 GOSUB @CHECKTYPE
 IF VALUE=ICOMMA THEN PINEXT
 IF VALUE<>C0 THEN PINEXT

 SEARCHTYPE=NUMBTYPE
 GOSUB @CHECKTYPE
 IF VALUE=C0 THEN PINOTNUMBER

; OBJECT=BUTTONS
 ADD VERBSTOCALL,C1
 GOTO PINEXT

.PINOTNUMBER
; ANYTHING ELSE (CONJ, VERBS ETC.) TERMINATE THIS SENTENCE
 GOSUB @GOBACK ; STORE (VERB?) FOR FUTURE ANALYSIS

.PIEND
 IF EVENTUALPREP=C0 THEN PIRET
 PREP=EVENTUALPREP
.PIRET
 RETURN
 
.PIPREP
 IF PREP<>C0 THEN @SECONDPREP ; GOT A SECOND PREP
 PREP=VALUE
 GOSUB @CONVERTVERB
 GOSUB @SELECTOBJECTPOS
 GOTO PINEXT

.PIEXAMINENOUN
 IF OBJECT<>IIT THEN PINOTIT
 OBJECT=ITWORD
 IF OBJECT<NULLOBJECT THEN PINOTIT
; IF PLAYER<>USER THEN NPCNOTUNDERSTAND
 MESSAGE 2053 ; it's not clear what IT refers to here
 GOTO @CANCELINPUT

.PINOTIT
 IF PREP<>C0 THEN @PINOUN2
 IF OBJECT=IEVERYTHING THEN PIEVERYTHING
 IF OBJECT=IEXCEPT THEN @PIEXCEPT
; GOT AN ORDINARY NOUN SPECIFIED
 ITWORD=OBJECT
;>> IF OBJECT<NUMBEROFFSET THEN PION0
;>> IF OBJECT>HINUMBEROFFSET THEN PION0
;
;>> NOUN2=OBJECT ;>>Dungeon wants I3 as the number keyword
;
;>> GOTO @PINEXT
;;
.PION0
 PARSEX1=NOUNFORBIDDEN ; mark noun as forbidden
 IF EXCEPT=TRUE THEN PIMARK ; DON'T CHECK IT'S HERE (YET)
; mark ordinary noun
 PARSEX1=NOUNSPECIFIED
.PIMARK
 NOUN1=OBJECT
 GOSUB MARKOBJECT ; MARK NOUN AS SPECIFICALLY REQUESTED
 GOTO @PINEXT
;
.PIEVERYTHING
 EVERYTHING=TRUE
 GOTO @PINEXT

;---
.STRIPX1
; STRIP OFF TOP TWO BITS OF PARSEX1.
 IF PARSEX1<64 THEN STRIPX1RET
 PARSEX2=64
 SUB PARSEX1,PARSEX2
 GOTO STRIPX1
.STRIPX1RET
 RETURN
;---
.CHECKIFSCENERYHERE
; given OBJECT as a noun requested by user (relative to NOUNOFFSET)
; see if it is part of a room description, and
; if so, return RESULT=TRUE if in current room
;> PARSEX1=NOUNOFFSET
;> ADD PARSEX1,OBJECT
;> IF OBJECT>1999 THEN RETURNTRUE ;>2000, so a random output message
 GOSUB @SETUPROOM ;>> only needed for early games
 PARSEX1=OBJECT ;>> only needed when room descs are before objects
 PARSEX2=SHORTROOMDESCS
 SUB PARSEX1,PARSEX2
 IF PARSEX1=ROOM THEN RETURNTRUE
; PARSEX2=300 ; LONGROOMDESCS-SHORTROOMDESCS ;>>
; SUB PARSEX1,PARSEX2 ;>>
; IF PARSEX1<>ROOM THEN RETURNFALSE ;>>
 GOTO RETURNFALSE ;>>
; drop through to return TRUE
.RETURNTRUE
 RESULT=TRUE
 RETURN
.RETURNFALSE
 RESULT=FALSE
 RETURN
;---
.MARKOBJECT
; mark object as PARSEX1
 if object>255 then @scenery ;>>mike 25/10/86
 PARSEX2=OBJECTTABLE(C0)
 IF PARSEX2=C0 THEN MARKOBJ1
 IF PARSEX1<>PARSEX2 THEN @DONTUNDERSTAND ; have had both mark and prevent types
.MARKOBJ1
 PARSEX2=C1
.MARKOBJ2
 PARSEX3=OBJECTTABLE(PARSEX2)

; after .markobj2, parsex3=objecttable(parsex2)
;>>MIKE 25/8/85 - see below IF PARSEX3=OBJECT THEN MARKOBJRET ; already marked

;>> NICK 1/7/86
;>> For Eden: Convert "verb colour BUTTON" to "verb colour"
 if verb=isay then notbutton ; treat normally
 if verb=iexamine then notbutton ; treat normally
 if verb<>ipush then notpush
 IF OBJECT=IBUTTON THEN MARKOBJRET ;>> NICK 1/7/86
 GOTO COLOUR1 ;>>MIKE 25/8/86 - a coloured button, allow multiple refs.

.notpush
 IF object<240 THEN NOTCOLOUR1 ;>> NICK 1/7/86
 IF object>249 THEN NOTCOLOUR1 ;>> NICK 1/7/86
 colour=object
 parsex4=240
 sub colour,parsex4
 return ; don't mark it

.NOTCOLOUR1 ;>> NICK 1/7/86
; if object<102 then notform
; if object>105 then notform
;; should have colour in COLOUR
; if colour<2 then notform
; if colour>5 then notform
; object=100 ; base for forms - colour=2..5
; add object,colour
;; now object=object number of appropriate form
;.notform
;
; if object<>121 then notticket
; if colour<>2 then notredticket
; object=121 ; red ticket
;.notredticket
; if colour<>5 then notticket
; object=122 ; green ticket
;
;.notticket
; if object<>ibutton then notbutton
; object=colour
; parsex4=240
; add object,parsex4 ; make "press green button" be "press green"
;
.notbutton

 IF PARSEX3=OBJECT THEN MARKOBJRET ;>>MIKE 25/8/86
;>> - moved here to allow multiple buttons of same colour
.COLOUR1

;>>mike 15/10/86 - IF PARSEX3=OBJECT THEN MARKOBJRET ; already marked

 IF PARSEX3=C0 THEN MARKOBJ3
 ADD PARSEX2,C1
 GOTO MARKOBJ2

.MARKOBJ3
 IF PARSEX2>60 THEN @DONTUNDERSTAND  ; OBJECTTABLE OVERFLOW
 ADD VERBSTOCALL,C1
 OBJECTTABLE(C0)=PARSEX1
 OBJECTTABLE(PARSEX2)=OBJECT
 ADD PARSEX2,C1
 OBJECTTABLE(PARSEX2)=C0
.MARKOBJRET
 RETURN
;---
.CHECKIFFORBIDDEN
 RESULT=FALSE
 PARSEX1=OBJECTTABLE(C0)
 IF PARSEX1<>NOUNFORBIDDEN THEN CIFRET
 PARSEX2=C1
.CIF1
 PARSEX1=OBJECTTABLE(PARSEX2)
 ADD PARSEX2,C1
 IF PARSEX1=C0 THEN CIFRET
 IF PARSEX1<>OBJECT THEN CIF1
 RESULT=TRUE
.CIFRET
 RETURN
;---
.SCENERY
; Have got a noun which is in a room description or similar,
; so it is just scenery. Print an appropriate message.
; IF PLAYER<>USER THEN NPCNOTUNDERSTAND
;
; x1=objecttable(0) ;>>mike 25/10/86
; if x1<>0 then examplat1 ;do nothing - because have a valid
;; object to process in the same command - >>mike 25/10/86

 PROCESSED=FALSE
 GOSUB @SETUPROOM
 IF VERB<>IEXAMINE THEN FUNNIES ; always allow them to happen

 if alreadyprintedscenery=true then examplat1
 alreadyprintedscenery=true

; examine - special for platform rooms
 if room=101 then examineplatform
 if room=102 then examineplatform
 if room<40 then notplatform
 if room<46 then examineplatform
.notplatform

; but examine wants to sometimes tell player it is 'just scenery'
; more detailed comments in DUNGEON version which was derived
; from this parser
; IF ROOM=60 THEN FUNNIES ; pile of rocks
; IF ROOM=41 THEN FUNNIES ; examining stone slab
; IF ROOM=7 THEN FUNNIES ; >> appalling kludge - MIKE 21/6/86
; IF ROOM=8 THEN FUNNIES ; >>    "
; IF ROOM=44 THEN FUNNIES
; IF ROOM=110 THEN FUNNIES ; elf
; IF ROOM=73 THEN FUNNIES ; dark shape flailing at you
; IF ROOM=223 THEN FUNNIES ; demon lord (at end)
; IF ROOM=224 THEN FUNNIES ; demon lord (at end)
; IF ROOM=207 THEN FUNNIES ; demon lord (almost at end)
; IF ROOM<82 THEN FUN3 ; underwater range
; IF ROOM<98 THEN FUNNIES ; underwater range
; IF ROOM=178 THEN FUNNIES ; padded cell - machine
.FUN3
;
;>>mike 8/9/86 PRINTINPUT
;>>mike 8/9/86 MESSAGE COLON

; GOSUB @FUNNIES ; Print out any special messages

 if room=4 then cantsaymore
 if room=18 then cantsaymore
 if room=21 then cantsaymore
 if room=51 then cantsaymore
 if room=89 then cantsaymore
 if room=101 then cantsaymore
 if room=102 then cantsaymore
 if room=153 then cantsaymore
 if room=110 then cantsaymore
 if room=122 then cantsaymore
 if room=147 then cantsaymore
 if room<40 then csmnotplatform
 if room<46 then cantsaymore
.csmnotplatform

 PARSEM1=2030 ; just scenery group
 GOSUB @VARYMESSAGE
.examplat1
 OBJECT=C0
 PROCESSED=TRUE ;>> MIKE 21/6/86
 ITWORD=NULLOBJECT
 HAVECALLEDVERB=TRUE
 RETURN
;---
.cantsaymore
 m1=2023 ; sorry, I can't say any more...
 if verb=iexamine then csmprint
 m1=2024 ; you can't dot that
.csmprint
 message m1
 goto examplat1
;---
.examineplatform
 message 856 ; platfrom description
 goto examplat1
;---
.FUNNIES
; >> MIKE 21/6/86
; is player referring to scenery in a room
; where the scenery may be useful
; e.g. water, oil, piles of rocks etc.
; if so, print 'name:' and try calling the game
 PROCESSED=TRUE
 OBJECT=SIGNIFICANT
 PROCESSED=TRUE
 RETURN
;---

.PIEXCEPT
 EXCEPT=TRUE
 GOTO @PINEXT

.PINOUN2
; another noun in input, not part of any multiple noun
 if noun2=object then pinoun2ok ;>>mike 6/12/86
; multiple references to noun2,
; so ok to use.

 IF NOUN2<>NULLOBJECT THEN @DONTUNDERSTAND
;
.pinoun2ok
 NOUN2=OBJECT
 GOTO @PINEXT
;---

.CHECKTYPE
; SEE IF THERE IS A WORD OF WORDTYPE 'SEARCHTYPE' IN CURRENT WORD
; IF NOT, RETURN VALUE=0
; IF THERE IS RETURN ITS WORD NUMBER IN VALUE
 INDEX=0

.CHECKTYPEMORE

 GOSUB @READINPUTLIST
 IF VALUE=0 THEN CHECKTYPERET ;>>MIKE 18/6/86
 IF WORDTYPE<>NUMBTYPE THEN CTNOTNUMBER
 ADD INDEX,C2 ; numbers are 4 byte values

.CTNOTNUMBER
 ADD INDEX,C2
;>>MIKE 18/6/86 IF VALUE=C0 THEN CHECKTYPERET
 SOMETHINGPROCESSED=TRUE
; IF VALUE=IRUDE THEN @RUDEWORD
 IF WORDTYPE<>SEARCHTYPE THEN CHECKTYPEMORE
;* should maybe re-enable this IF WORDTYPE<>NOUNTYPE THEN CHECKTYPERET
; IF VALUE<470 THEN CHECKTYPERET
; IF VALUE>699 THEN CHECKTYPERET
; an examine message
; PARSEX1=470
; SUB VALUE,PARSEX1

.CHECKTYPERET
 RETURN
;---

.CHECKNOUN
;Check if noun if present in list 9.

;Alternatives are checked in priority. It is very dangerous to do all
;checking in combined tests (this may not work for all conversions)
;so each alternative is isolated. Order of checks is:
;   if not defined anywhere as "^N xxx" then return as 'not found'
;   if it's 'noise' (4000-4001)
;   if it's a keyword not originally in the game but which might have
;      been added in anywhere (such as 'IT' 'ALL' and 'BUT')
;   if it's a keyword for an object in the current room or worn/carried
;   if it's scenery in the current room
;   if it's a keyword for an object elsewhere
;   if it's scenery elsewhere.

 IF PREP=C0 THEN CHECKNOUN1
 HISEARCHPOS=NONSPECIFIC
.CHECKNOUN1

 GOSUB @CHECKNOUNDEFINED ;Check if any noun(s) exist in LIST 9.
 IF RESULT=TRUE THEN CHECKNOUN2
;Not defined anywhere as noun
 PROCESSED=FALSE ;>> (Otherwise doesn't do TAKE xxx DROP xxx.)
 OBJECT=C0
 RETURN

.CHECKNOUN2
 GOSUB CHECKNOUNGARBAGE
 IF RESULT=FALSE THEN CHECKNOUN3
;Garbage word
 PROCESSED=TRUE
 OBJECT=C0
 RETURN

.CHECKNOUN3    
 GOSUB CHECKNOUNANYWHERE
 IF RESULT=FALSE THEN CHECKNOUN4
;Word like IT ALL BUT THEN..
 PROCESSED=FALSE
 OBJECT=VALUE
 RETURN

.CHECKNOUN4
;Must either be scenery (in a room description) or a keyword

 GOSUB CHECKNOUNKEYWORD
; returns RESULT=TRUE if an actual object is referred to and present
; and OBJECT = value
 IF RESULT=FALSE THEN CHECKNOUN5
;Object
;>>MIKE 21/6/86 PROCESSED=TRUE
;>>MIKE 21/6/86 OBJECT=VALUE
 RETURN

;Must be scenery..
.CHECKNOUN5
;>; first check if it is a word that is always present
;> INDEX=0
;>.CHECKNOUN5A
;> GOSUB CHECKTYPEMORE
;> IF VALUE=0 THEN CHECKNOUN5B
;> IF VALUE<850 THEN CHECKNOUN5A
;> IF VALUE>870 THEN CHECKNOUN5A
;> PROCESSED=FALSE
;> OBJECT=0
;> RETURN ; something which is always present

;.CHECKNOUN5B
; must be some type of scenery
;
 GOSUB @CHECKNOUNROOM ; >> MOVED FROM BELOW
 IF RESULT=TRUE THEN @SCENERY
;
 GOSUB @CHECKNOUNSTATUS
 IF RESULT=FALSE THEN CHECKNOUN6
;Status noun
;>> MIKE 21/6/86 PROCESSED=TRUE
 RETURN ;>>MIKE 28/7/86

.CHECKNOUN6
 IF OBJECT>255 THEN @NOTCLEAR ;>> NICK 1/7/86
 RETURN ;>>MIKE22/6/86 not found, so let the game itself decide
;
;-----
;
.CHECKNOUNGARBAGE
;Check if one of the possible nouns in LIST 9 is a garbage word.
 SEARCHTYPE=NOUNTYPE
 INDEX=C0
 GOSUB CHECKTYPE
 OBJECT=C0

.CHECKGAR1
 IF VALUE=C0 THEN CHECKGAR2

 IF VALUE<3000 THEN CHECKGAR2 ;>>MIKE 23/7/86
 IF VALUE<3100 THEN CHECKGAR3 ;>>MIKE 23/7/86
; IF VALUE=3000 THEN CHECKGAR3
; IF VALUE=3001 THEN CHECKGAR3

 GOSUB CHECKTYPEMORE
 GOTO CHECKGAR1

.CHECKGAR2
 RESULT=FALSE
 RETURN

.CHECKGAR3
 RESULT=TRUE
 RETURN

;-----

.CHECKNOUNANYWHERE
;Check if one of the possible nouns if LIST 9 is one of a
;group of keyword nouns which could be anywhere in the message file.
;(Because of possible clashes with other messages in the converted
;game these nouns may violate the rules on keyword numbering.)

 SEARCHTYPE=NOUNTYPE
 INDEX=C0
 GOSUB @CHECKTYPE
 OBJECT=C0
.CHECKSPEC1

 IF VALUE=C0 THEN CHECKSPEC1A

 IF VALUE=IIT THEN CHECKSPEC2
;>> IF VALUE=ITHEN THEN CHECKSPEC2
 IF VALUE=IEXCEPT THEN CHECKSPEC2
 IF VALUE=IEVERYTHING THEN CHECKSPEC2
 IF VALUE=ISAVE THEN CHECKSPEC2 ;>>
 IF VALUE=IRESTORE THEN CHECKSPEC2 ;>>

 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPEMORE

 GOTO CHECKSPEC1

.CHECKSPEC1A
 OBJECT=C0
 RESULT=FALSE
 RETURN

.CHECKSPEC2
 OBJECT=VALUE
 RESULT=TRUE
 RETURN

;-----

.CHECKNOUNKEYWORD
;Check if there is a noun in LIST 9 which is in the range
;MINOBJECT thru MAXOBJECT.

 RESULT=TRUE
 SEARCHTYPE=NOUNTYPE
 INDEX=C0
;>> MIKE 21/6/86 GOSUB CHECKTYPE
 OBJECT=C0

.CHECKKEY1
 GOSUB @CHECKTYPEMORE ;>> MIKE 21/6/86
 IF VALUE=0 THEN CHECKKEYFALSE

;Value will already have been 'adjusted' if it
;lies in the range MINADJUST..MAXADJUST

 IF VALUE>MAXOBJECT THEN CHECKKEY1 ;>> MIKE 21/6/86
 IF VALUE<MINOBJECT THEN CHECKKEY1 ;>> MIKE 21/6/86

 OBJECT=VALUE
 GOSUB @CHECKIFACCESSIBLE ;>> MIKE 21/6/86
 IF RESULT=FALSE THEN CHECKKEY1 ;>> MIKE 21/6/86
;>> MIKE 21/6/86 RESULT=TRUE
 RETURN

;>>MIKE 21/6/86.CHECKKEY2
;>> GOSUB CHECKTYPEMORE
;>> GOTO CHECKKEY1

.CHECKKEYFALSE
 RESULT=FALSE
 RETURN

;-----

.CHECKNOUNSTATUS ;>>
;Check if nount in LIST 9 is present in a status message.

 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPE

 GOSUB @SETUPROOM

.CHECKSTAT1
 IF VALUE=C0 THEN CHECKSTAT3

 PARSEX1=VALUE
 PARSEX2=NOUNOFFSET
 ADD PARSEX1,PARSEX2
 IF PARSEX1<MINSTATUS THEN CHECKSTAT2
 IF PARSEX1>MAXSTATUS THEN CHECKSTAT2
 RESULT=TRUE
 RETURN

.CHECKSTAT2
 GOSUB @CHECKTYPEMORE
 GOTO CHECKSTAT1

.CHECKSTAT3
 RESULT=FALSE
 RETURN

;-----

.CHECKNOUNROOM
;Check if noun is present in list 9.
;which corresponds to scenery of the current room location.

 SEARCHTYPE=NOUNTYPE
 INDEX=C0

;>> MIKE 21/6/86 GOSUB CHECKTYPE

 GOSUB @SETUPROOM ;Set ROOM=R1

.CHECKROOM1
 GOSUB @CHECKTYPEMORE ;>>MIKE 21/6/86
 IF VALUE=C0 THEN CHECKROOM2

 PARSEX1=VALUE
 PARSEX2=SHORTROOMDESCS
 SUB PARSEX1,PARSEX2
 OBJECT=VALUE
 RESULT=TRUE
 IF PARSEX1=ROOM THEN CHECKROOM3
 GOTO CHECKROOM1 ;>>MIKE 21/6/86
;>>MIKE 21/6/86 GOSUB CHECKTYPEMORE
;>>MIKE 21/6/86 IF VALUE<>C0 THEN CHECKROOM1

.CHECKROOM2
 RESULT=FALSE

.CHECKROOM3
 RETURN

;-----

.CHECKNOUNDEFINED
;Check if there is a noun in LIST 9.

 SEARCHTYPE=NOUNTYPE
;>> INDEX=C0
 GOSUB @CHECKTYPE

 IF VALUE<>0 THEN CHECKSCENE1

 OBJECT=VALUE
 RESULT=FALSE
 RETURN

.CHECKSCENE1
 RESULT=TRUE
 RETURN

;-----

.CLEARINPUT
; called after any errors - remove rest of input from line
 IF NOMOREINPUT=TRUE THEN CLEARINPEND ;>>
 INDEX=C0
 GOSUB READINPUTLIST
 IF VALUE=C0 THEN CLEARINPEND
 SUPRESSCHECKING=TRUE ; don't check words for validity
 GOSUB GETNEXTWORD
 GOTO CLEARINPUT
.CLEARINPEND
 SUPRESSCHECKING=FALSE
 RETURN

;-----

.GETNEXTWORD
; GET NEXT WORD IN LINPUT
; set EOL=TRUE if get ".", eol, etc.
; Set SEPARATOR=TRUE if get "." ","
 IF NOMOREINPUT=TRUE THEN GNWEND
 IF WORDNOTPROCESSED=TRUE THEN GNWEND ; HAVE USED GOBACK TO RETRIEVE

 INPUT PARSEX1 PARSEX1 PARSEX1 PARSEX1
 SEARCHTYPE=ASCITYPE
 GOSUB @CHECKTYPE
 IF VALUE<33 THEN GNW1
 IF VALUE<38 THEN GETNEXTWORD
.GNW1
 GOSUB CHECKEOL ; CHECK FOR "." "THEN" etc.
.GNWEND
 WORDNOTPROCESSED=FALSE
.CIGRET
 RETURN

;-----

.CHECKEOL
 INDEX=C0
 GOSUB READINPUTLIST
 SEPARATOR=FALSE
 EOL=FALSE
 IF VALUE=C0 THEN SETNOTHINGMORE
 SEARCHTYPE=CONJTYPE
 GOSUB @CHECKTYPE
 IF VALUE=ITHEN THEN SETEOL
 SEARCHTYPE=ASCITYPE
 GOSUB @CHECKTYPE
 IF SUPRESSCHECKING=TRUE THEN CHECKEOL1
 IF VALUE=128 THEN @PARSENOTKNOWN ; WORD NOT UNDERSTOOD
.CHECKEOL1
 IF VALUE=ICOMMA THEN SETSEPARATOR
 IF VALUE=IDOT THEN SETEOL
 RETURN
.SETSEPARATOR
 SEPARATOR=TRUE
 GOTO SETEOL

.SETNOTHINGMORE
; There is no more input to come on this line
 NOMOREINPUT=TRUE
.SETEOL
 EOL=TRUE
 RETURN
;---
.GOBACK
; MARK CURRENT WORD AS UNPROCESSED, SO A SUBSEQUENT INPUT ROUTINE
; CAN GET A CHANCE AT READING IT
 INDEX=C0
 GOSUB READINPUTLIST
 IF VALUE=C0 THEN GOBACKRET
 WORDNOTPROCESSED=TRUE
.GOBACKRET
 RETURN
;---
.READINPUTLIST
 ; VALUE:=@INPUT(INDEX) 16 BIT. PARSEX1,PARSEX2 corrupted
 VALUE=LINPUT(INDEX)
 IF VALUE<>C1 THEN RILNOTNUMBER
 WORDTYPE=NUMBTYPE
 PARSEX1=INDEX
 ADD PARSEX1,C1
 VALUE=LINPUT(PARSEX1) ; returns low order of number
 RETURN

.RILNOTNUMBER
 WORDTYPE=VALUE
; STRIP OFF TOP THREE ( WORDTYPE ) BITS
 PARSEX1=32
.RIL1
 IF VALUE<32 THEN RIL2
 SUB VALUE,PARSEX1
 GOTO RIL1
.RIL2
 GOSUB VALUETIMES256
 PARSEX1=C1
 ADD PARSEX1,INDEX
 PARSEX2=LINPUT(PARSEX1)
 ADD VALUE,PARSEX2
; Separate out WORDTYPE = top three bits
 PARSEX2=WORDTYPE
 WORDTYPE=ASCITYPE
 PARSEX1=ASCIOFFSET
 IF PARSEX2<32 THEN RILRET
 WORDTYPE=VERBTYPE
 PARSEX1=VERBOFFSET
 IF PARSEX2<64 THEN RILRET
 WORDTYPE=CONJTYPE
 PARSEX1=CONJOFFSET
 IF PARSEX2<96 THEN RILRET
 WORDTYPE=PREPTYPE
 PARSEX1=PREPOFFSET
 IF PARSEX2<128 THEN RILRET
 WORDTYPE=NOUNTYPE
 PARSEX1=NOUNOFFSET
 IF PARSEX2<160 THEN RILRET
 WORDTYPE=ADJETYPE
 PARSEX1=ADJEOFFSET
 IF PARSEX2<192 THEN RILRET
 WORDTYPE=MATCHTYPE
 PARSEX1=MATCHOFFSET
 IF PARSEX2<224 THEN RILRET
 WORDTYPE=7
 PARSEX1=C0
.RILRET
 IF WORDTYPE<>NOUNTYPE THEN NOADJUST  ;>>
 IF VALUE<MINNOUNADJUST THEN NOADJUST ;>>
 IF VALUE>MAXNOUNADJUST THEN NOADJUST ;>>
 PARSEX1=ADJUSTOFFSET                 ;>>
.NOADJUST                             ;>>
 SUB VALUE,PARSEX1 ; SUBTRACT OFFSET
;>>> IF VALUE>60000 THEN RILRET1
 RETURN
;>>.RILRET1
;>> VALUE=C0
;>> RETURN
;---
.VALUETIMES256
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 ADD VALUE,VALUE
 RETURN
;---
.VALUEDIV256
; divide VALUE by 256
; must preserve PARSEX4
 PARSEX1=C0
 PARSEX2=256
.VD256
 SUB VALUE,PARSEX2
 IF VALUE>NEGATIVE THEN VDEND
 ADD PARSEX1,C1
 GOTO VD256

.VDEND
 VALUE=PARSEX1
 RETURN
;---

.GETCOMMAND
 I1=C0 ;>>
 I2=C0 ;>>
 I3=C0 ;>>
 I4=C0 ;>>
 WANTWHATNOW=TRUE
 GOTO GI0

;---

.GETI1I2I3I4 ;>>
;Request input and return first two verbs in I1 and I2
 I1=C0
 I2=C0
 I3=C0
 I4=C0

.GETI1
 NOMOREINPUT=FALSE
 WORDNOTPROCESSED=FALSE
 SUPRESSCHECKING=TRUE

 GOSUB @GETNEXTWORD

 INDEX=C0
 GOSUB @READINPUTLIST
 IF VALUE=C0 THEN GETI2
 IF I4>C1 THEN GETI1 ;Already found two verbs ?

 SEARCHTYPE=VERBTYPE ; Check if it's a verb
 GOSUB @CHECKTYPE
 IF VALUE=C0 THEN GETI1

 ADD I4,C1 ;Number of verbs found
 IF I4=C1 THEN GETI3
 I2=VALUE ;Save second verb
 GOTO GETI1
.GETI3
 I1=VALUE ;Save first verb
 GOTO GETI1

.GETI2
 IF I4=C0 THEN GETI1I2I3I4
 SUPRESSCHECKING=FALSE
 RETURN

;-----

.GI0
 I1=C0
 I2=C0
 I3=C0
 IF NOUN1=NULLOBJECT THEN GETNEWINPUT
; in middle of presentmultiple
 IF EVERYTHING=TRUE THEN @PMEV3
 GOTO @PMSINGLENEXT

.GETNEWINPUT
;>> VERB=C0 ;>> 24/5/86 to fix 'TAKE ALL (cr) (cr)' problem

 NOUN1=NULLOBJECT
 IF NOMOREINPUT=FALSE THEN GNI1
 NOMOREINPUT=FALSE
 IF SOMETHINGPROCESSED=FALSE THEN GNI1 ; prevent CR giving WHAT NOW
 SOMETHINGPROCESSED=FALSE

 IF WANTWHATNOW=FALSE THEN GNI1
 MESSAGE WHATNOW
 alreadyprintedscenery=false

.GNI1
 EVERYTHING=FALSE ;??
 NOUN1=FALSE ;>>>*
 GOSUB @PARSEINPUT
 if verb=0 then getnewinput
 GOTO @PRESENTMULTIPLE

.GETEND1
 IF VERB=IEXITS THEN @PRINTEXITS
 I1=VERB
 IF VERB=C0 THEN GETEND5 ;>>
;>> IF PREP=C0 THEN GETEND2
 I2=PREP
.GETEND2
 IF NOUN1=NULLOBJECT THEN GETEND3
 I2=NOUN1
.GETEND3
 IF NOUN2=NULLOBJECT THEN GETEND4
 if i2<>0 then getendi3 ;>>mike 22/8/86 - allow "PUSH 1" etc.
 i2=noun2
 goto getend4
.getendi3
 I3=NOUN2
.GETEND4
 I4=C3
 IF I3<>C0 THEN GOTIT
 I4=C2
 IF I2<>C0 THEN GOTIT
 I4=C1
 IF I1<>C0 THEN GOTIT
.GETEND5 ;>>
 I4=C0
.GOTIT

;; replace 121 (red ticket) with i2=red,i3=ticket
; if i2<>121 then gnotredticket
;; i2=121 ; ticket
; i3=202 ; red
;.gnotredticket
; if i2<>122 then gnotgreenticket
; i3=205 ; green
;.gnotgreenticket
; if i2<102 then gnotform
; if i2>105 then gnotform
; i3=i2
; parsex1=100
; add i3,parsex1 ; numbers are 202..205 for forms 102..105 (red..green)
;.gnotform
 if verb<>ipush then gnotpush
 if i2<>0 then gnotpush
 i2=ibutton

.gnotpush


;***** Please do not delete the next 9 debugging instructions:
; MESSAGE CR ;*****
; PRINT I1 ;*****
; MESSAGE SPACE ;*****
; PRINT I2 ;*****
; MESSAGE SPACE ;*****
; PRINT I3 ;*****
; MESSAGE SPACE ;*****
; PRINT I4 ;*****
; MESSAGE DOTCR ;*****

 RETURN
;---
.GETVALUE
 GOSUB @GETNEXTWORD
 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 IF VALUE<>C0 THEN GOTIT
 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPE
 RETURN
;---
.INITPARSER
 CURRENTOBJECT=NULLOBJECT
 NOUN1=NULLOBJECT
 NOUN2=NULLOBJECT
 NOMOREINPUT=TRUE
 SOMETHINGPROCESSED=TRUE ; allow WHAT NOW to be printed
 ITWORD=NULLOBJECT ;>>***
; and clear out OBJECTTABLE
 PARSEX1=C0
.IP1
;>> OBJECTTABLE(PARSEX1)=C0
 TEMPLISTBASE(PARSEX1)=C0 ;>>
 ADD PARSEX1,C1
 IF PARSEX1<512 THEN IP1 ;>>
;>> IF PARSEX1<60 THEN IP1
 RETURN
;---
.SELECTOBJECTPOS ;Is this code complete?
 HISEARCHPOS=NOUNCARRIED
 IF VERB=IDROP THEN SOPRET
 IF VERB=ITHROW THEN SOPRET
 HISEARCHPOS=NOUNONGROUND
 IF VERB=ITAKE THEN SOPRET
 HISEARCHPOS=NONSPECIFIC
.SOPRET
 RETURN

;---

;.GETCOMMAND
; GOSUB @TICKCLOCK
;.GPARSEC0
; STACK
;.GPARSEC1
;; before printing What now?, check if any more commands waiting
; IF NOMOREINPUT=FALSE THEN GPARSEC3 ; still something left on line
; NOMOREINPUT=FALSE ; disable flag which is set on getting 0 from input
; IF SOMETHINGPROCESSED=FALSE THEN GPARSEC3 ; prevent CR producing 'WHAT NOW'
; MESSAGE 17 ; WHAT NOW ?%
; RANDOM PARSEX1 ; kick random number generator
; SOMETHINGPROCESSED=FALSE
; PLAYER=USER
; GOSUB SETUPROOM
;.GPARSEC3
; GOSUB @PARSEINPUT
; IF VERB<>0 THEN GPARSEC4
; GOTO GPARSEC0
;
;.GPARSEC4
; GOSUB @PRECOMMAND
; GOSUB PRESENTMULTIPLE ; HANDLE MULTIPLE OBJECTS, CALLING VERB REPEATEDLY
; GOTO @POSTCOMMAND
;---
;>>.PMSINGLERET
;>> GOTO GETNEWINPUT ;>> was  RETURN
;---
;.PMRET
; GOTO GETNEWINPUT ;>> was  RETURN
;---
;.ABSCALLVERB
;
;; Come here to call verb without printing desc first
; LASTVERBVALID=TRUE
; OBJECT=NOUN1
; HISEARCHPOS=NONSPECIFIC
; RESULT=TRUE
; GOSUB @FUNNIES
; IF RESULT=TRUE THEN @CVRET
; OBJECT=NOUN2
; GOSUB @OBJECTTRIGGER
; IF RESULT=TRUE THEN @CVRET
; OBJECT=NOUN1
; GOSUB @OBJECTTRIGGER ; TRIGGERS FOR ANY VERB ON OBJECT
; IF RESULT=TRUE THEN @CVRET ; FLAG NOT RESET, SO COMMAND PROCESSED
;
;; Do jump-table type indexing
;; Flow will return to PRESENTMULTIPLE when the verb has finished
;
;; IF VERB=ICLIMB THEN @CLIMB
;; IF VERB=IJUMP THEN @JUMP
;; IF VERB<16 THEN @MOVE
;; IF VERB=22 THEN @INVENTORY
;; IF VERB=IRESTORE THEN @RESTORE
;; IF VERB=ISAVE THEN @SAVE
;; IF VERB=IQUIT THEN @QUIT
; IF VERB=ILOOK THEN @DESCRIBEROOM
;; IF VERB=ILISTEN THEN @HEAR
;; IF VERB=ISMELL THEN @SMELL
;IF VERB=IWAIT THEN @WAIT
; IF VERB=ISLEEP THEN @SLEEP
; IF VERB=IVHELLO THEN @HELLO
; IF VERB=IKNOCK THEN @KNOCK
;
; IF VERB=IPICTURE THEN @PICTURE
; IF VERB=IWORDS THEN @WORDS
; IF VERB=ISTAND THEN @STAND
; IF VERB=ILIE THEN @LIE
; IF VERB=ISIT THEN @SIT
; IF VERB=ISCORE THEN @SCORE
; IF VERB=IVERBOSE THEN @VERBOSE
; IF VERB=IBRIEF THEN @BRIEF
;
; IF VERB=IGOTO THEN @GOTO ; ******
; IF NOUN1<>NULLOBJECT THEN CVGOTNOUN
; IF PLAYER<>USER THEN NPCNOTUNDERSTAND
; M1=2033 ; must supply an object group
; GOTO @VARYMESSAGE

;.CVGOTNOUN
; IF VERB<41 THEN TOOCOMPLEX
; IF VERB=IOPEN THEN @OPEN
; IF VERB=ITAKE THEN @TAKE
; IF VERB=IPICK THEN @TAKE
; IF VERB=IWEAR THEN @WEAR
; IF VERB=IDROP THEN @DROP
; IF VERB=IPUT THEN @PUT
; IF VERB=IEXAMINE THEN @EXAMINE
; IF VERB=IATTACK THEN @ATTACK
; IF VERB=ICUT THEN @CUT
; IF VERB=IREMOVE THEN @REMOVE
; IF VERB=ITHROW THEN @THROW
; IF VERB=IEAT THEN @EAT
; IF VERB=IPUSH THEN @PUSH
; IF VERB=IPULL THEN @PULL
; IF VERB=IRING THEN @VRING
; IF VERB=IGIVE THEN @GIVE
; IF VERB=IWAKE THEN @WAKE
; IF VERB=ISQUEEZE THEN @SQUEEZE
; IF VERB=ICAST THEN @CAST
; IF VERB=IFASTEN THEN @FASTEN
; IF VERB=IRUB THEN @RUB
;IF VERB=ILIGHT THEN @LIGHT
;IF VERB=IEXTINGUISH THEN @EXTINGUISH
; MESSAGE 2036 ; don't understand verb
;.CVRET
; RETURN
;;---
;.TOOCOMPLEX
; MESSAGE 2039 ; sentence is too complex
; RETURN
;;---
;>>.PARSETOOMUCH ; TOO MUCH ENTERED
;>> PARSEM1=2001
;>> GOTO PARSEERROR
;---
;>>.PARSENOOBJECT
;>> PARSEM1=2002
;>> GOTO PARSEERROR
;---
;.NPCLOOKSFORSOMETHING
; GOSUB ISNPCVISIBLE
; IF RESULT=FALSE THEN NPCLFSRET
; PARSEX1=PLAYER
; GOSUB @DESCTHEOBJPARSEX1
; MESSAGE 2065 ; looks around as if looking for something
;.NPCLFSRET
; RETURN
;;---
;.NPCNOTUNDERSTOOD
; an NPC (variable PLAYER) is trying to do something which it can't
;; PARSEX1=CURRENTPOS(USER)
;; PARSEX2=CURRENTPOS(PLAYER)
;; IF PARSEX1<>PARSEX2 THEN NCRET
; GOSUB ISNPCVISIBLE
; IF RESULT=FALSE THEN NPCLFSRET
; PARSEX1=PLAYER
; GOSUB DESCTHEOBJPARSEX1
; M1=2062 ; looks puzzled
; GOSUB VARYMESSAGE
; GOTO CANCELINPUT
;---
;.NPCCONFUSED
;; NPC has been instructed to do something which it can't
;; but, don't want to stop, so print a message like
;; 'the frak looks around, as if searching for something'
;; and then carry on with processing the rest of the command (if any)
; M1=2065 ; NPC is confused
; GOTO PRINTM1
;---
.OBJECTNOTHERE
; THE OBJECT IS NOT AVAILBALE TO THE COMMAND
; THIS ERROR RETURNS AS IT IS USED IN PRESENTMULTIPLE
; IF OBJECT=C0 THEN ONTRET
; IF PLAYER<>USER THEN NPCLOOKSFORSOMETHING
; IF HISEARCHPOS=NOUNONGROUND THEN ONT1
; IF HISEARCHPOS=NONSPECIFIC THEN CANTSEEIT
; MESSAGE 2012 ; don't have..
;.ONTERROR
; MESSAGE THE
; PARSEX1=OBJECT
; GOSUB @DESCTHEOBJX1
; MESSAGE DOT
; GOTO @CANCELINPUT

;.ONT1
; POS=PLAYER
; HIPOS=NONSPECIFIC
; GOSUB @CHECKOBJECTPOS
;>> GOSUB ISOBJECTCARRIED
;>> IF RESULT=TRUE THEN ONT2
;>>.CANTSEEIT
;>> IF OBJECT=IEVERYTHING THEN CANTUSEHERE ; EVERYTHING as NOUN2
;>> GOSUB ISOBJECTCARRIED
; POS=PLAYER
; HIPOS=NONSPECIFIC
; GOSUB @CHECKOBJECTPOS
;>> IF RESULT=TRUE THEN ONT2
;>> MESSAGE 2011 ; Can't see ..
;>> GOTO ONTERROR
;>>.ONT2
;>> IF VERB=ISTAND THEN ONTDROPFIRST
;>> MESSAGE 2013 ; Already have ..
;>> GOTO ONTERROR

;>>.ONTDROPFIRST
;>> MESSAGE 2014 ; have to drop it first
;>>.ONTRET
;>> RETURN
;----
;>>.ITSNOTTHERE
; user asked for NOUN1 in NOUN2 or similar
; but NOUN1 is not contained by NOUN2
;>> MESSAGE 2017 ; it's not there
;>> RETURN
;---
;.PARSEINPUT
; CONVERT INPUT TO VERB, PREP, OBJECT FORM FOR
; EASY UNDERSTANDING BY THE REST OF THE PROGRAM
; HAVECALLEDVERB=FALSE
; GOSUB @GETNEXTWORD
; VERB=C0
; IF EOL=TRUE THEN @PIEND; NOTHING ENTERED !
;
;; is player trying to talk to someone ?
; SEARCHTYPE=NOUNTYPE
; GOSUB @CHECKTYPE
; IF VALUE<NPCBASE THEN PINOTNPC
; IF VALUE>NPCMAX THEN PINOTNPC
;; yes, so is the target here ?
; OBJECT=VALUE
; GOSUB CHECKIFPRESENT
; IF RESULT=TRUE THEN PINPC
; MESSAGE 2060 ; talking to yourself ?
; GOTO CLEARINPUT
;
;.CANTTALKTOSEVERAL
;; can't talk to more than one person
; MESSAGE 2061
; GOTO CLEARINPUT
;
;.PINPC
;; set up conversation target as player
; IF PLAYER<>USER THEN CANTTALKTOSEVERAL
; PLAYER=VALUE
; GOSUB SETUPROOM
; GOSUB GETNEXTWORD ; first word of what's said
; GOTO SAY
;
;>>.LASTVERBINVALID
; IF PLAYER<>USER THEN NPCNOTUNDERSTAND
;>> PARSEM1=2050 ; last verb not valid
;>> GOSUB @VARYMESSAGE
;>> GOTO @CANCELINPUT

;.PI0A
;>> IF VALUE<>IRAM THEN PI0B ;>>
;>> GOSUB @GETNEXTWORD       ;>>
;>> I2=VALUE                 ;>>
;>> GOTO @RAMCOMMAND         ;>>

;
;.PION0
; IF OBJECT<SPELLBASE THEN PION1
; IF OBJECT>SPELLMAXPLUSONE THEN PION1
; SPELL=OBJECT
; GOTO PINEXT

;.PION1
;; hold on a moment. There are certain constructs where
;; the first noun can be the destination
;; e.g. "GIVE ME THE MANDRAKE"
; IF VERB<>IGIVE THEN PION2
; IF OBJECT=USER THEN PIGIVE
; IF OBJECT>NPCMAX THEN PION2
; IF OBJECT>NPCBASE THEN PIGIVE
;
;>>.PIGIVE
;>> IF PREP<>C0 THEN DONTUNDERSTAND
;>> NOUN2=OBJECT
;>> EVENTUALPREP=ITO
;>> GOTO @PINEXT
;---
;>>.CNNOTCLEAR1
;>>; OBJECT>MAXOBJECT, see if it is valid
;>> IF OBJECT=IEVERYTHING THEN CHECKNNORMAL
;>> IF OBJECT=IIT THEN CHECKNNORMAL
;>> IF OBJECT=IEXCEPT THEN CHECKNNORMAL
;>> GOTO @NOTCLEAR
;
;.CHECKNOUNEND
; IF OBJECT<SPELLBASE THEN CNENSPELL
; IF OBJECT>SPELLMAXPLUSONE THEN CNENSPELL
; GOTO CHECKNNORMAL
;---
; .CHECKOBJECTPOS
; Return RESULT=TRUE if 'OBJECT' is
; at 'HIPOS', 'POS'
; if POS=0, it is treated as NONSPECIFIC
; likewise, HIPOS=NONSPECIFIC is handled
; return PARSEX4=lo position of object (or object if on ground)
; PARSEX4=OBJECT
;.COP1
; IF POS=C0 THEN COPHI
; PARSEX1=CURRENTPOS(PARSEX4)
; IF PARSEX1<>POS THEN @COPNOTYET
;.COPHI
; lo address is same, now check hi address
; PARSEX1=HICURRENTPOS(PARSEX4)
; IF PARSEX1=C0 THEN COPHI1
; IF HIPOS=NONSPECIFIC THEN COPFOUND ; provided object is contained
;.COPHI1
; IF PARSEX1<>HIPOS THEN COPNOTYET
;.COPFOUND
; RESULT=TRUE
; RETURN
;.COPNOTFOUND
; RESULT=FALSE;
; RETURN
;
;.COPNOTYET
; PARSEX1=HICURRENTPOS(PARSEX4)
; IF PARSEX1=C0 THEN COPNOTFOUND
; PARSEX4=CURRENTPOS(PARSEX4)
; GOTO COP1
;---
;.CHECKIFPRESENT
;; is OBJECT in same room as player ?
; SAVEHISEARCHPOS=HISEARCHPOS
; HISEARCHPOS=NONSPECIFIC
; GOSUB CHECKIFACCESSIBLE
; HISEARCHPOS=SAVEHISEARCHPOS
; RETURN

;-----
;.CONVERTVERB
; IF VERB<>ITAKE THEN CVNTAKE
;; GET ON etc.
; IF PREP<>ON THEN CVNGETON
; VERB=UP
; PREP=0
;.CVNGETON
;.CVNTAKE
; RETURN
;---

 
;---
.CONVERTVERB
; Given VERB,PREP, convert to standard forms of certain commands
; e.g. LOOK AT => EXAMINE ;     GET ON => STAND ON  ;  GET OFF => LEAVE
; This is called as soon as the first noun is found - so
; if it is necessary to separate prepositions before+after nouns,
; this is a good place to do it

 GOSUB @SETUPROOM

 IF VERB<>ILOOK THEN CVNOTLOOK
 IF PREP=0 THEN CVNOTLOOK
 VERB=IEXAMINE
 PREP=0

.CVNOTLOOK
 IF VERB<>IGET THEN CVNGETON
 IF PREP<>IPON THEN CVNGETON
.CVUP
 VERB=11 ; on autoscythe
 PREP=0

.CVNGETON
 IF VERB<>IGET THEN CVNGETOFF
 IF PREP<>IPOFF THEN CVNGETOFF
 VERB=12 ; off autoscythe
 PREP=0

.CVNGETOFF
; IF VERB<>IVON THEN CVNOTON
; PREP=IPON
; VERB=ISTAND
;
;.CVNOTON
; IF VERB<>IVOFF THEN CVNOTOFF
; PREP=IPOFF
; VERB=ISTAND
;.CVNOTOFF

.CVNOTONOFF
; this code doesn't seem to work, so it is commented out at present:
; IF VERB<>IDROP THEN CVNDROP
; IF PREP=0 THEN CVNDROP
; IF NOUN2=NULLOBJECT THEN CVNDROP ; ignore PREP if no second noun
;; DROP noun1 PREP noun2
;; probably equivalent to PUT noun PREP noun2
; VERB=IPUT

.CVNDROP
 IF VERB<>ITAKE THEN CVNTAKE
; take off something (REMOVE something)
 IF PREP<>IPOFF THEN CVNTAKE
 IF NOUN1<>NULLOBJECT THEN CVNTAKE
; VERB=IREMOVE
; just TAKE ...
 PREP=0

.CVNTAKE
 IF VERB<>IPUT THEN CVNPUT
; put on something (WEAR something)
 IF PREP<>IPON THEN CVNPUTON
 IF NOUN1<>NULLOBJECT THEN CVNPUT
 VERB=IWEAR
 PREP=0
 RETURN
.CVNPUTON
; IF PREP<>IPOUT THEN CVNPUT
;; put out => extinguish
; VERB=IEXTINGUISH ; put candle out
; IF NOUN1<>NULLOBJECT THEN CVNPUT
; NOUN1=NOUN2 ; put out candle
;
.CVNPUT
; IF VERB<>IGET THEN CVNGET
; VERB=ITAKE

.CVNGET
 RETURN
;---
;--------------------------------------------------------
;--------------------------------------------------------
;--------------------------------------------------------
