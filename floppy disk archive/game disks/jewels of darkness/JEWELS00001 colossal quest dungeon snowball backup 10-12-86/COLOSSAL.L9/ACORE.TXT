;Parser for Triligy Conversions

;Copyright (C) 1986 Level 9 Computing

;B:ACORE.TXT

VAR
 DESCRIPTIONMODE WHEELFOUND

BEGIN
 GOTO @STARTGAME
;---
;.DESCRIBEROOM
; LASTWORDPRINTED=DISABLEIT ; prevent printing of 'it'
; GOSUB @POSITIONSHADOWS
; GOSUB @CHECKIFLIGHT
; IF RESULT=TRUE THEN DESCROOPARSEM1
; MESSAGE 2108 ; It's dark
; LASTPICTURE=0
; CLS G ; clear graphics window
;
; RETURN
;
;.DESCROOPARSEM1
;
; GOSUB @SPECIALPLAYER
; GOSUB @SETUPROOM
; SEARCHPOS=ROOM
; HISEARCHPOS=0
;
; PARSEX1=500 ; base for pictures
; ADD PARSEX1,ROOM
; IF PARSEX1=LASTPICTURE THEN DESCROOM2
; CLS G
; PICTURE PARSEX1
; LASTPICTURE=PARSEX1
;
;.DESCROOM2
; PARSEX1=SHORTROOMDESCS
; ADD PARSEX1,ROOM
; MESSAGE PARSEX1
; IF DESCRIPTIONMODE=IBRIEF THEN DESCROOM3
; PARSEX1=LONGROOMDESCS
; ADD PARSEX1,ROOM
; MESSAGE PARSEX1
;.DESCROOM3
; MESSAGE DOT
; GOSUB PRINTEXITS
; SEARCHPOS=ROOM
; HISEARCHPOS=0
; IF WHEELFOUND=TRUE THEN DESCROOM4A ; SPECIAL
; IF ROOM=66 THEN DESCROOM4 ; SPECIAL to Price of Magik
;.DESCROOM4A ; SPECIAL
; GOSUB @PRINTOBJECTS
;.DESCROOM4 ; SPECIAL to Price of Magik
;
; GOSUB DESCPLAYER
; GOSUB @SPECIALDESC
;.DESCROOMRET
; RETURN
;;---
;.DESCPLAYER
;; Print any special messages for player
;; e.g. 'You are standing on the object'
; PARSEX1=HICURRENTPOS(PLAYER)
; IF PARSEX1=LIEON THEN DESCPLAY0
; IF PARSEX1=SITON THEN DESCPLAY0
; IF PARSEX1<>ON THEN DESCPLAY1
;.DESCPLAY0
; MESSAGE 370 ; you
; PARSEX2=76
; ADD PARSEX1,PARSEX2
; MESSAGE PARSEX1 ; are standing on / sitting on / lying on etc.
; GOTO DESCPLAY5
;.DESCPLAY1
; RETURN
;.DESCPLAY5
; PARSEX1=CURRENTPOS(PLAYER)
; GOSUB @DESCTHEOBJPARSEX1
; MESSAGE DOT
; RETURN
;;---
.PRINTEXITS
; OWTYPE=OWEXITS
 GOSUB @SETUPROOM ;>>
 NUMEXITS=0
 DIR=1 ; current direction
 OUTPUTWORD=0 ;>>
.PELOOP
; PRINT AN EXIT (IF VISIBLE)
 FROM=ROOM
 GOSUB @CHECKEXIT
 WORD1=0
 WORD2=0
 WORD3=0
 WORD4=0
 IF EXITVISIBLE=FALSE THEN PENEXTDIR
 WORD1=VERBOFFSET ;> EXITDESCBASE
 ADD WORD1,DIR
; IF DOOR=0 THEN PENODOOR
; WORD2= ; base for door messages
; ADD WORD2,DOOROPEN
;.PENODOOR
 ADD NUMEXITS,C1
 IF NUMEXITS<>2 THEN PE2
 MESSAGE 3020 ; EXITS ARE
.PE2
; IF WORD2<>0 THEN PEDESC ; through a door, so don't describe destination
; WORD2=* ; to
; WORD3=SHORTROOMDESCS
; ADD WORD3,DEST

;.PEDESC
 GOSUB OUTWORD12 ;>> 34
.PENEXTDIR
 ADD DIR,C1
 IF DIR<NUMDIRECTIONS THEN PELOOP ;> 14
.PERET1
 IF NUMEXITS>1 THEN PERET2
 IF NUMEXITS=0 THEN PERET
 MESSAGE 3021 ; ONLY EXIT IS
.PERET2
 WORD1=0
 WORD2=0
 GOSUB @OUTWORD12
.PERET
 GOTO @RESETSTACK ;>> RETURN
;---
;.CHECKIFOBVIOUS
;; see if 'OBJECT' is immediately obvious
; OBVIOUS=TRUE
; PARSEX1=HICURRENTPOS(OBJECT)
; IF PARSEX1=0 THEN CIORET ; things on ground are always obvious
; PARSEX1=CURRENTPOS(OBJECT)
; IF PARSEX1=PLAYER THEN CIORET ; player's contents are obvious
; ADD PARSEX1,PARSEX1
; ADD PARSEX1,C1 ; look at hi initial position of container
; PARSEX2=OBJECTSTART(PARSEX1)
; IF PARSEX2>127 THEN CIORET ; 'obvious' bit set
; IF SEARCHDEPTH=0 THEN CIORET
; OBVIOUS=FALSE
;;
;.CIORET
; RETURN
;;---
;.PRINTOBJECTS
;; GO THROUGH CURRENT OBJECT POSITION LIST,
;; AND DISPLAY ALL THE OBJECTS AT (HISEARCHPOS,SEARCHPOS)
; OWTYPE=OWOBJECTS
; GOSUB @INITGETOBJ
; LASTWORDPRINTED=0
; TOTALOBJECTFOUND=0
;.PO1
; GOSUB GETNEXTOBJECT
; IF OBJECT=0 THEN PO1A
; GOSUB CHECKIFOBVIOUS
; IF OBVIOUS=FALSE THEN PO3
;;
; IF OBJECT>MAXOBJECTVISIBLE THEN PO3
; IF OBJECT=PLAYER THEN PO3
;
;.PO1A
; IF NUMOBJECTFOUND<>1 THEN PO2
; ADD TOTALOBJECTFOUND,C1
; WORD1=0
; WORD2=0
; GOSUB @OUTWORD12 ; output any buffered words
; GOSUB @PRINTCONTAINMENT ; PRINT CONTAINER ON FIRST OBJECT FOUND ONLY
;.PO2
; WORD1=OBJECT
; WORD2=0
; GOSUB @OUTWORD12 ; Output object name (delayed effect)
;.PO3
; IF OBJECT<>0 THEN PO1
; LASTWORDPRINTED=DISABLEIT
; RETURN
;;---
;.GETNEXTOBJECT
;; RETURN OBJECT=OBJECT FOUND
;;    SEARCHPOS=ROOM OR CONTAINER WHERE FOUND
;;  HISEARCHPOS=TYPE OF CONTAINMENT (=0 FOR ROOMS)
;;
;; BEFORE FIRST CALL, MUST SP=0, GOSUB INITGETOBJ AND SETUP HI,SEARCHPOS
;; AT END OF SEARCH, ALL ZEROS ARE RETURNED
;; RETURN NUMOBJECTFOUND=NUMBER OF OBJECT FOUND IN THIS PASS
;;
;; ALSO ADD ON WEIGHT OF THIS OBJECT TO 'WEIGHT'
; PARSEX1=MAXOBJECTVISIBLE ;MAXOBJECT ??
;.GETNEXTOBJPARSEX1
; GETNEXT PARSEX1 HISEARCHPOS SEARCHPOS OBJECT NUMOBJECTFOUND SEARCHDEPTH
; IF OBJECT>PARSEX1 THEN GNOERR
;.GNORET
; RETURN
;.GNOERR
; OBJECT=0
; NUMOBJECTFOUND=0 ; ??
; RETURN
;;---      
; 
;.INITGETOBJ
; SEARCHDEPTH=1
; PARSEX1=0
; GETNEXT PARSEX1 PARSEX1 PARSEX1 PARSEX1 PARSEX1 PARSEX1
; RETURN
;;--- 
;.PRINTCONTAINMENT
; PARSEX3=24 ; BASE FOR CONTAINMENT MESSAGES
; IF HISEARCHPOS=NONSPECIFIC THEN PCRET
; IF SEARCHPOS<>PLAYER THEN PPARSEC1
; PARSEX3=60 ; BASE for 'You are wearing' and 'You are carrying'
;.PPARSEC1
; ADD PARSEX3,HISEARCHPOS
; MESSAGE PARSEX3
; IF HISEARCHPOS=0 THEN PCRET ; DON'T PRINT 'THE object' FOR 'YOU CAN SEE'
; PARSEX1=SEARCHPOS ; CONTAINER OBJECT NUMBER
; GOSUB @DESCTHEOBJPARSEX1
; PARSEX1=16
; ADD PARSEX3,PARSEX1 ; print second half of containment messages
; MESSAGE PARSEX3
;.PCRET
; RETURN
;;---
.OUTWORD12
 WORD3=0
 WORD4=0
.OUTWORD1234
; WE ARE OUTPUTING A LIST OF WORDS, SEPARATED BY COMMAS
; ETC. THIS ROUTINE TAKES A SERIES OF WORDS ONE AT A TIME
; AND OUTPUTS THEM. BEFORE CALLING, SET OUTPUTWORD=0
; AT THE END OF THE LIST, CALL THIS ROUTINE WITH PARSEX1=0 AND THE LIST
; WILL BE FINISHED OFF WITH A FULL STOP ETC.
 IF WORD1=0 THEN OWEND
; FIRST OR SECOND WORD - JUST ADD TO BUFFER
 PARSEX4=OUTPUTWORD
 VALUE=WORD1
 GOSUB WRITEOUTBUFFER
 VALUE=WORD2
 GOSUB WRITEOUTBUFFER
 VALUE=WORD3
 GOSUB WRITEOUTBUFFER
 VALUE=WORD4
 GOSUB WRITEOUTBUFFER
 OUTPUTWORD=PARSEX4
 IF OUTPUTWORD<>24 THEN OWRET
;
.OW1
; THIRD TO SUBSEQUENT WORDS - print out oldest word
; in buffer, and shift the other two down
 PARSEX4=0 ; index into OUTPUTBUFFER
 GOSUB OWPRINT
 PARSEX1=0
 PARSEX2=8
.OW2
 PARSEX3=OUTPUTBUFFER(PARSEX2)
 OUTPUTBUFFER(PARSEX1)=PARSEX3
 ADD PARSEX1,C1
 ADD PARSEX2,C1
 IF PARSEX1<16 THEN OW2
 MESSAGE COMMA
 OUTPUTWORD=16
.OWRET
 RETURN

.OWEND
; HAVE RECEIVED THE TERMINATOR
 IF OUTPUTWORD=0 THEN OWRET ; NO WORDS OUTPUT AT ALL
; THERE MUST BE AT LEAST ONE WORD REMAINING IN BUFFER - SO OUTPUT IT
 PARSEX4=0 ; index into OUTPUTBUFFER
 GOSUB OWPRINT
 IF OUTPUTWORD=8 THEN OWSTOP ; ONLY ONE WORD OUTPUT - SO THATS IT !
; MUST HAVE OUTPUTWORD=2, SO 2 OR MORE WORDS OUTPUT.
; THEREFORE WANT TO FINISH OFF WITH "AND"
 MESSAGE AND
 PARSEX4=8 ; index into OUTPUTBUFFER
 GOSUB OWPRINT
.OWSTOP
 OUTPUTWORD=0
 MESSAGE DOT
 RETURN
;---
.OWPRINT
; Print words by message number starting at outputbuffer(PARSEX4)
 PARSEX3=3 ; words to print
.OWPRINT1
 GOSUB READOUTBUFFER
 PARSEX1=VALUE
;> IF OWTYPE=OWOBJECTS THEN DESCANOBJPARSEX1
 MESSAGE VALUE
 SUB PARSEX3,C1
 IF PARSEX3<NEGATIVE THEN OWPRINT1
 RETURN
;
;---
.WRITEOUTBUFFER
; write 16 bit word VALUE to OUTPUTBUFFER at (PARSEX4)
; do 16 bit autoincrement after the write
; must preserve PARSEX3
 ADD PARSEX4,C1 ; write low byte first
 OUTPUTBUFFER(PARSEX4)=VALUE
 SUB PARSEX4,C1
 GOSUB @VALUEDIV256
 OUTPUTBUFFER(PARSEX4)=VALUE
 ADD PARSEX4,C2 ; skip on to next entry
 RETURN
;---
.READOUTBUFFER
; read 16 bit word VALUE from OUTPUTBUFFER(PARSEX4)
; do 16 bit autoincrement after the read
 VALUE=OUTPUTBUFFER(PARSEX4)
 GOSUB @VALUETIMES256
 ADD PARSEX4,C1
 PARSEX1=OUTPUTBUFFER(PARSEX4)
 ADD VALUE,PARSEX1
 ADD PARSEX4,C1 ; skip on to next entry
 RETURN
;;---
;>>.DESCTHEOBJX1
;>>; PRINT OUT 'THE <desc>'
;>>; First check if can print 'it'
;>> IF PARSEX1<>LASTWORDPRINTED THEN DTOPARSEX2
;>> MESSAGE 2002 ; 'it'
;>> RETURN
;
;>>.DTOPARSEX2
;>> IF PARSEX1=USER THEN DTOXNOTHE ; PREVENT 'the you ...'
;>>; IF PARSEX1=MYGLAR THEN DTOXNOTHE
;>> MESSAGE THE
;>>.DTOXNOTHE
;>> GOTO DESCOBJPARSEX1
;;---
;.DOSOME
; MESSAGE 23 ; SOME
; GOTO DESCOBJPARSEX1
;.DOAN
; MESSAGE 22 ; AN
;;---
.DESCOBJPARSEX1
 LASTWORDPRINTED=PARSEX1
;>>.DOPARSEX1A2
;???* IF PARSEX1>MAXVISIBLEOBJECT THEN DESCOBJRET
 IF PARSEX1>67 THEN DESCOBJCOLOSSAL
 PARSEX2=OBJECTDESCBASE
 ADD PARSEX2,PARSEX1
 MESSAGE PARSEX2
.DESCOBJRET
 RETURN
.DESCOBJCOLOSSAL ;>>MIKE 26/8/86
 IF PARSEX1>MAXOBJECT THEN DESCOBJRET
 PARSEX2=1000
 ADD PARSEX2,PARSEX1
 MESSAGE PARSEX2
 RETURN
;;---
.CHECKEXIT
; GOSUB ABSCHECKEXIT
; GOTO @SPECIALEXITS ; Exits conditional on game
;;---
.ABSCHECKEXIT
; EXIT (From FROM diection DIR )
; return DEST, DOOR, EXITVISIBLE
 DOOR=FALSE
 EXITVISIBLE=FALSE
 EXIT FROM DIR STATUS DEST
 IF DEST=0 THEN CERET
.CHECKEXITSTATUS
 PARSEX1=STATUS
 IF PARSEX1<4 THEN CE2
 DOOR=TRUE
;> CURRENTPOS(GENERALDOOR)=ROOM
 SUB PARSEX1,C4
.CE2
 IF PARSEX1>1 THEN CERET
 EXITVISIBLE=TRUE
.CERET
 RETURN
;;---
;.CALCDIRECTION
;; given 'FROM', 'TO' as adjacent locations,
;; return 'DIR'=direction going from 'FROM' to 'TO'
; DIR=15
;.CALCDIR1
; SUB DIR,C1
; GOSUB ABSCHECKEXIT
; IF DIR=0 THEN CALCDIRRET
; IF DEST<>TO THEN CALCDIR1
;.CALCDIRRET
; RETURN
;;---
.CRVARYMESSAGE
 MESSAGE CR
.VARYMESSAGE
;; OUTPUT ONE OF THREE MESSAGES AT 'PARSEM1'
;; GOSUB RAND3
;; ADD PARSEM1,NUMBER
; MESSAGE PARSEM1
; RETURN
 ADD CURRENTMESSAGE,C1
 IF CURRENTMESSAGE<3 THEN VMOK
 CURRENTMESSAGE=0
.VMOK
 PARSEX1=PARSEM1
 ADD PARSEX1,CURRENTMESSAGE
 MESSAGE PARSEX1
 RETURN
;---
;-------------------------------------
;-------------------------------------
;---------------------------------
