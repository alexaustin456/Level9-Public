; Gnome Ranger source, copyright (C) 1987 Level 9 Computing.
;
; AVERB.TXT, fairly standard code to handle ordinary verbs (there 
; is no point in writing code to handle movement; get/drop; examine
; etc. etc. afresh for each game.) You will need to make some changes, 
; adding new verbs and those special cases which can't go elsewhere, 
; and possibly removing verbs, e.g the combat routines if your game 
; is non-violent.
;
BEGIN
;
; Start of game, transferred here directly from APARSE. 
;
.noicky indeed, 
;; and we advise you to keep your hands off. 
; if thisgame<>GnomeRanger then notchained
; if parttochain<>constantpartnum then notchained
; if thispart=1 then notchained
;; must have loaded a saved pos which caused
;; this part to be chained in.
; thispart=parttochain
; message space
; message cr
; goto @afterrestore
;
;.notchained
; CLEAR ; clears all variables
 x1=0
 c1=1
.clearall
; some of the table cleared here is also cleared by initnpc
 currentpos(x1)=c0 ; must be donicky indeed, 
;; and we advise you to keep your hands off. 
; if thisgame<>GnomeRanger then notchained
; if parttochain<>constantpartnum then notchained
; if thispart=1 then notchained
;; must have loaded a saved pos which caused
;; this part to be chained in.
; thispart=parttochain
; message space
; message cr
; goto @afterrestore
;
;.notchained
; CLEAR ; clears all variables
 x1=0
 c1=1
.clearall
; some of the table cleared here is also cleared by initnpc
 currentpos(x1)=c0 ; must be done else OBJECTTRIGGER fails for OBJECT=0
 add x1,c1
 if x1<npctablesizetozero then clearall
 MESSAGE 2100 ; welcome to game
; initialise some variables which retain their values throughout
; the game
 thisgame=GnomeRanger
 thispart=constantpartnum
 C1=1
 C2=2
 C3=3
 c6=6
 c8=8
 C10=10
;
 ITWORD=NULLOBJECT ; first object seen
 ITNUMBER=NULLNUMBER
 NOMOREINPUT=TRUE ; have come to end of input line
; CARRYCAPACITY=NORMALCAPACITY
 GOSUB @INITOBJECTS
;>>> gosub randomizetreasure
 gosub @initnpcs
 HOUR=10
 day=1
 minute=20
 SOMETHINGPROCESSED=TRUE ; force printing of WHAT NEXT ?
 NORMALDESCRIPTIONMODE=IVERBOSE
 OOPSPOS=1
 vandalptr=vandalbase
;
 gosub @initlocations

; now set up variables as pointers to starts
; within segmented lists
 value=list5(0)
 gosub @valuetimes256
 x1=list5(1)
 add value,x1
 startfloorpointers=value

 value=list5(2)
 gosub @valuetimes256
 x1=list5(3)
 add value,x1
 startracetracks=value

 value=list5(4)
 gosub @valuetimes256
 x1=list5(5)
 add value,x1
 startreversaltable=value

 value=list5(6)
 gosub @valuetimes256
 x1=list5(7)
 add value,x1
 StartPotionTable=value


; set up initial racetrack commands for npcs
; which have them
 actor=1
.initracetrack1
; now find pointer to initial racetrack for actor:
 add actor,c1
 x1=actor ; number of racetrack to activate
 gosub @initracetrackx1
 if actor<maxnpcplus1 then initracetrack1

; set up CurrentBook
.RandomiseBook
 random x1
 x2=12
 gosub @x1DivX2
 if x1>20 then RandomiseBook
 currentBook=x1

 actor=user
 gosub @setuproom
 x1=1
 gosub @drawpicturex1

 message 2500 ; intro - please make some tea for me!
 message dot
 message BlankLine
 gosub @PrintRoom
; initialscene=1
 GOTO @CANCELINPUT
;---
.unfasten
.unfastentake
 verb=itake

.GET
.TAKE
; Check for prepositions e.g. GET ON, GET OFF
 IF PREP<>0 THEN TAKEFROM
.TAKEIT
 POS=ACTOR
 HIPOS=CARRIED
 GOTO @MOVEOBJECT
;
.TAKEFROM
; got a preposition e.g. TAKE noun FROM ; or TAKE noun IN etc.
 OBJECT=NOUN1
 POS=NOUN2
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
; OBJECT=NOUN1 here
 IF RESULT=FALSE THEN @ITSNOTTHERE
 GOTO TAKEIT
;---

.STAND
 lastpossibleverb=0 ; prevent prep being parsed as a verb
 nextverb=0
 if prep=0 then standoff ; >>special to gnome2 - fix bug
 IF PREP=ON THEN STANDON
 IF PREP=OFF THEN STANDOFF
 IF PREP=UP THEN STANDUP
 IF PREP=IPIN THEN STANDIN
 IF PREP=IPOUT THEN STANDOUT
 GOTO @DONTUNDERSTAND
;---
.STANDOFF
.STANDOUT ; get out (e.g. of boat)
.STANDUP
 X1=HICURRENTPOS(ACTOR)
 IF X1=0 THEN @SILLY
 currentpos(actor)=ROOM
 hicurrentpos(actor)=c0
 goto @done
;
.BOARD ; e.g. boat
; PREP=ON

.STANDON
.STANDIN
; HIDEST=PREP ; ON, IN ETC.
; GOTO silly
;---
.LIE
; HIDEST=LIEON
; GOTO silly
;---
.SIT
; HIDEST=SITON
 goto @silly
;---
.STANDOK
 gosub @printACTORactiondot
 PROCESSED=TRUE
 HIDEST=PREP
 DEST=OBJECT
 GOTO @NEWLOCATION
;---
.ATTACK
 commandfinished=true ; always terminates immediately now
 if noun1=iroom then @vandal
 m1=2565 ; too strong to break
 if noun1=wall then @PrintM1Dot
 if object<95 then attackNotPotion
 if object>99 then attackNotPotion
 gosub @destroyobject
 goto @done

.AttackNotPotion
;; target=noun1
;; if noun1>maxnpc then atnpc ; assumes nullobject=255
;; if noun2<minweapon then @silly
;; if noun2=nullobject then attackchoose
;; if noun2>maxweapon then @silly
;; weapon=noun2
;; goto @generalblow
;;;
;;.attackchoose
;; GOSUB @CHOOSEBESTWEAPON
;; GOTO @GENERALBLOW
;;;
;;.ATNPC
 if noun1<minsceneryobj then atnsceneryobject
 if noun1<maxsceneryobjplus1 then @vandal
;
.atnsceneryobject
.collect
.become
.WAKE
.WASTEOFTIME
 IF ACTOR<>USER THEN @NPCNOTUNDERSTOOD
 M1=3160 ; don't bother group
 GOTO @VARYMESSAGEDOT
;---
.pourpotion
 verb=iput
 prep=ipon

.PUT
 IF NOUN1=NULLOBJECT THEN @CANTSEEWHAT
 IF NOUN2=NULLOBJECT THEN @CANTSEEWHERE
 OBJECT=NOUN1

 IF PREP=ON THEN PUTON
 IF PREP=UNDER THEN @PUTUNDER
 IF PREP=IN THEN @PUTIN
 if prep=through then @putin

.CANTPUTTHERE
;; if actor<>uto @printM1Dot

.NotWeedkillerHedge
 if noun2<130 then cantputthere
 if noun2>138 then cantputthere
 if noun2<>138 then NotResistant
; cave mouth is resistant
 object=noun2
 gosub @PrintTheObject
 m1=2543 ; seemed to be resistant
 goto @printM1dot

.NotResistant
; kill plant weedkiller was put on
 if noun2<5 then putonweedkiller
 if noun2>137 then @NothingHappens
 if noun2<130 then @NothingHappens
.putonweedkiller
 object=Noun2
 gosub @PrintTheObject
 m1=2509 ; died
 gosub @printM1Dot
to @printM1Dot

.NotWeedkillerHedge
 if noun2<130 then cantputthere
 if noun2>138 then cantputthere
 if noun2<>138 then NotResistant
; cave mouth is resistant
 object=noun2
 gosub @PrintTheObject
 m1=2543 ; seemed to be resistant
 goto @printM1dot

.NotResistant
; kill plant weedkiller was put on
 if noun2<5 then putonweedkiller
 if noun2>137 then @NothingHappens
 if noun2<130 then @NothingHappens
.putonweedkiller
 object=Noun2
 gosub @PrintTheObject
 m1=2509 ; died
 gosub @printM1Dot
 goto @destroyobject

.PutonNotWeedKiller
 if noun2<>greenslave then putNotGreenslave
 if noun1=animatePotion then putOK

.putNotGreenslave
 if noun1<>fertiliserPotion then putNotFertiliser
 if noun2=witheredteabush then regrowteabush
 goto @nothinghappens

;
.PutNotFertiliser
.PUTOK
 OBJECT=NOUN1
 GOTO MOVEOBJECTPrepNoun2

.PUTIN
 if noun2=blueTelelily then putinTelelily
 if noun2<>whiteTelelily then putinNotTelelily
.putinTelelily
 if noun1>83 then putok
 if noun1<82 then putok
 if noun1<maxnpcPlus1 then putinNotTelelily
; anything except telelilys will fit inside!
 object=noun1
 gosub @printTheObject
 m1=2550
 gosub @printM1
 object=noun2
 gosub @printTheObject
 goto @PrintDot

.putinNotTelelily
 if noun2=pot then putok
 if noun2=pond then putOk
.objectwontfit
 GOTO @CANTPUTTHERE

.putunder
 goto @cantputthere
;---
.ISOBJECTMOVEABLE
; return RESULT=TRUE if OBJECT can be moved
 if actor<>treehouse then iomNotTreehouse
 if object<maxNpcPlus1 then iomtrue ; treehouse can take all people

.iomNotTreeHouse
 if object>maxmoveable then @returnfalse
 if object<maxNpcPlus1 then @returnfalse
.iomtrue
 result=TRUE
.IOMRET
.cptret
 RETURN
;---
.reGrowTeaBush
 currentpos(witheredTeaBush)=c0
 currentpos(TeaBush)=room
 x1=TeaBush
 currentpos(TeaLeaf)=x1
 x1=growingFrom
 hicurrentpos(TeaLeaf)=x1
 m1=2606 ; tea bush regrows
 goto @printm1dot
;---
.MoveObjectPrepNoun2
 pos=Noun2
 hipos=Prep

; Super routine for moving objects about. E.g, putting something inside 
; a bag. Or removing it. It differs from "NEWLOCATION", which is concerned 
; with walking-about-type-movement, primarily in the way that the action 
; is reported. MOVEOBJECT validates the movement before carrying it out.
.MOVEOBJECT
; Move 'OBJECT' to 'POS', 'HIPOS'
; Return RESULT=TRUE if move was successful
 GOSUB ISOBJECTMOVEABLE
 IF RESULT=FALSE THEN @IMMOVABLE
; is the contents already contained by the container (or V-V) ?
 GOSUB @CHECKIFCONTAINED
;
 IF HIPOS=0 THEN MONOTACTOR
; ACTOR to gain this object, check if is able to carry it
; actually this code is now used whenever an object
; goes to a position not on the ground. This
; is to catch people trying to avoid SPECIALTAKES
 IF HIPOS<>WORN THEN MOVEOBJ1
; is it wearable ?
 if object<>weedkillerPotion then NotWearWeedkiller
 if actor<>user then @WeedkillActor
.wearweedkiller
 m1=2541 ; it improved ingrid's complexion
 gosub @printM1Dot
 weedkillersmeared=true
 goto @destroyobject

.NotWearWeedKiller
 IF OBJECT<minclothes THEN @cantwear
 if object>maxclothes then @cantwear

.MOVEOBJ1
; Now check if the ACTOR is standing on it or some similar problem
 OBJECTSAVE=OBJECT
 DEST=POS ; save value
 HIDEST=HIPOS ; save it
;
 POS=OBJECT
 HIPOS=NONSPECIFIC
 OBJECT=ACTOR
 GOSUB @CHECKOBJECTPOS
;
 OBJECT=OBJECTSAVE
 POS=DEST ; restore value
 HIPOS=HIDEST ; restore value
 IF RESULT=TRUE THEN @MOVEOBJFAIL
 GOSUB @SPECIALTAKES ; game-specific take messages
 IF RESULT=FALSE THEN @MOVEOBJRET
;
.MONOTACTOR
 X1=CURRENTPOS(OBJECT)
 IF X1<>ACTOR THEN MMNOTLOSE
 X1=HICURRENTPOS(OBJECT)
 IF X1=0 THEN MMNOTLOSE
; ACTOR is to lose object
 IF X1<>WORN THEN MMLOSENOTWORN
; ACTOR is wearing object, if it was specified using EVERYTHING,
; then don't drop it as this could cause embarrasment
 IF noun1isgd=FALSE THEN MMLOSENOTWORN
 if verb=iremove then mmlosenotworn
 RESULT=FALSE
 if actor<>user then @npcnotunderstood
 M1=2134 ; you're wearing
 gosub @printM1
 gosub @printTHEobject
 goto @printDOT

.MMLOSENOTWORN
 GOSUB @SPECIALDROPS
 IF RESULT=FALSE THEN MOVEOBJRET

.MMNOTLOSE
 IF HIPOS=0 THEN MMNL1
 IF POS=OBJECT THEN @CANTPUTTHERE
.MMNL1
; any other special cases ?
;
; is it going to a NPC ?
 if actor=pos then montonpc ; ok for people to take things
 IF HIPOS=0 THEN MONTONPC
 IF POS<minnpc THEN MONTONPC
 IF POS>MAXNPC THEN MONTONPC
; code here is to avoid NPCs having things put on them etc.
; or the statue / bloodworm / bat being given things
; no special cases for giving to NPC, so make it carr
 gosub @errorm1

.MOPREVENT
 RESULT=FALSE
.moveobjret
 RETURN
;---
.SCORE
 MESSAGE 2240 ; you score
 
.PRINTSCORE
 X4=part1score
 sub x4,TeabushDestroyed
 add x4,AnimatePotionMade
 add x4,AntidotePotionMade
 add x4,WeedkillerPotionMade
 add x4,FertilizerPotionMade
 add x4,TeaPotionMade
 add x4,BooksRead
 add x4,telelilysgrown
 add x4,greenslavegrown
 add x4,treehousecrossedroad
 add x4,hedgecrossed
 add x4,WallBroken
 add x4,HedgeSmashed
 add x4,ReachedStinkwort
 add x4,AntidoteDr
 gosub @errorm1

.MOPREVENT
 RESULT=FALSE
.moveobjret
 RETURN
;---
.SCORE
 MESSAGE 2240 ; you score
 
.PRINTSCORE
 X4=part1score
 sub x4,TeabushDestroyed
 add x4,AnimatePotionMade
 add x4,AntidotePotionMade
 add x4,WeedkillerPotionMade
 add x4,FertilizerPotionMade
 add x4,TeaPotionMade
 add x4,BooksRead
 add x4,telelilysgrown
 add x4,greenslavegrown
 add x4,treehousecrossedroad
 add x4,hedgecrossed
 add x4,WallBroken
 add x4,HedgeSmashed
 add x4,ReachedStinkwort
 add x4,AntidoteDrunk
 add x4,AirplantReached

; *** ADD CODE TO CALCULATE SCORE AT THIS POINT ***
 IF X4<30000 THEN SCORE1 ; failsafe test to prevent negative score
 X4=0
.SCORE1
 part12score=x4
 PRINT X4 ; score
 M1=2249 ; message below lowest rating
 X1=100 ; size of score categories (max score, 1000, has unique rating)
.SCORE2
 SUB X4,X1
 ADD M1,C1
 IF X4<NEGATIVE THEN SCORE2
 MESSAGE 2242 ; out of 1000 and are a 
 goto @printM1dot ; rating
;---
.POSITIONSHADOWS
; Make objects follow the ACTOR around where applicable. e.g. DOORS.
; and other objects which are in several places at once. 
 RETURN
;---
.FASTEN
; NOUN1 TO NOUN2
 GOTO @actorcantverbnoun1dot
;---
;.untiefirst
; m1=2158 ; must untie it first
; goto @printM1dot
;---
; Move something/someone to a new location in the game, reporting the 
; movement with messages such as 'X enters from the north'.
.NEWLOCATION
; Given FROM=old location, HI,DEST=new location
; and DIR=direction,
; print any messages which appear on moving through doors etc.
; GOSUB SETUPROOM
 FROM=ROOM
 GOSUB @SPECIALMOVES
 blockedbysm=TRUE
 IF RESULT=FALSE THEN NLRET
 if actor<>user then NewMoveNotUser
 gosub @SaveOops

.NewMoveNotUser
 blockedbysm=FALSE
;
.ABSNEWLOCATION
; as for newlocation, but don't do any checking for special
; case code. Use this routine where the move is forced, so
; don't want to trip any movement traps
 FROM=ROOM
; describe door closing (if there is one)
 IF HIDEST<>0 THEN ANL2 ; skip checks for moving into container
 GOSUB @CHECKEXIT
 gosub printleaving
;
.ANL2
 LASTROOM=ROOM
 CURRENTPOS(ACTOR)=DEST
 HICURRENTPOS(ACTOR)=HIDEST
 gosub @closedoor
 roomsave=ROOM
 gosub @setuproom
 gosub printarrival
; no messages printed between printarrival and printroom please
.NLEND
 IF ACTOR<>user THEN @AFTERMOVE ; npc doesn't want description
 timeinroom=0
 GOSUB @printROOM
 GOTO @AFTERMOVE
;---
.printLEAVING
 if descriptionmode=inone then dlret
 verb=istruggle
 if dir=iclimb then dl1
 verb=58 ; go
.dl1
 gosub @isactorflying
 if result=false then dl2
 verb=163 ; flew

.dl2
 gosub @printACTORverb ; the npc goes
.printdirectionanddoor
 m1=verboffset ; north-1
 add m1,dir
 gosub @printM1 ; direction
 gosub printdoor
 if actor<>user then @printDOT ; print a dot and terminate
 wanttoprintand=user ; followed immediately by description
.desclret
.nlret
 return
;---
.printdoor
 IF DOOR=FALSE THEN DESCLret
 M1=2115 ; through the door
 goto @printM1
;---
.printARRIVAL
; first print description of object
 if descriptionmode=inone then desclret
 IF actor=user then DESCLRET ; for startup
 if verb=9 then descltreehouse ;>>special to gnome2
 if verb=10 then descltreehouse ;>>special to gnome2
 if verb=14 then descltreehouse ; >>special to gnome2
.printa1
 verb=iENTER 

 gosub @isactorFlying
 if result=false then pa2
 verb=163 ; flew

.pa2
 object=actor
 gosub @printANobjectVERB ; the npc enters...
 m1=584
 add m1,dir
 gosub @printM1
 gosub printdoor
 goto @printdot
;---
.descltreehouse
 if dest<>treehouse then printa1
 if hidest=0 then printa1
 gosub @printactor
 m1=2537 ; climbed into the treehouse
 goto @printm1dot

.ANLRET
.dlret
 RETURN
;---
.TICKCLOCK
; add on time a minute at a time
.TCADDMINUTES
 GOSUB @TIMEDEPENDENTCODE
 add timeinroom,c1
.TCRET
.waitret
.OPENDOORRET
.SAYRET
.OPENRET
.throwret
.abnret
.pushret
 RETURN
;---
.PULL
.PUSH
 if object<>rock then @IMMOVABLE
; pushing boulder
 add boulderRocking,c1
 m1=2570
 add m1,BoulderRocking
 if currentuserroom<4 then pushnodesc
 if currentuserroom>7 then pushnodesc
 message m1
 message dot
.pushnodesc
 if m1<>2573 then PUSHRET
; boulder rolled down the hill, crushing the plant
 currentpos(hedge)=c0
 HedgeSmashed=10
 BoulderRocking=0
 goto @destroyObject
;---
.OPEN
 IF DOOROPEN=TRUE THEN ALREADYOPEN
.opendoor
 DOOROPEN=TRUE
 goto @printACTORactiondot


.cantopendoor
 gosub @printactor
 m1=2710 ; door bolted from inside
 goto @printm1dot
;---
.DONTNEEDTODOTHAT
 m1=2148 ; you don't nN2=NULLOBJECT THEN NOBODYWANTSIT
 OBJECT=NOUN1
 pos=noun2
 GOSUB @MOVEOBJECT
 goto @specialaftergive
;---
.THROW
 if noun2=nullobject then @drop
; drop the object...
 pos=room ;** could probably do 'VERB=IDROP, GOTO DROP'
 hipos=0
 gosub @moveobject
 if result=FALSE then @throwret ; not possible
;; if noun2<minnpc then thrownotnpc
;; if noun2>maxnpc then thrownotnpc
;; throw something at someone - so treat as aggressive
;; object=noun1 here
;; gosub ithits ; print what happens
;; blowstrenN2=NULLOBJECT THEN NOBODYWANTSIT
 OBJECT=NOUN1
 pos=noun2
 GOSUB @MOVEOBJECT
 goto @specialaftergive
;---
.THROW
 if noun2=nullobject then @drop
; drop the object...
 pos=room ;** could probably do 'VERB=IDROP, GOTO DROP'
 hipos=0
 gosub @moveobject
 if result=FALSE then @throwret ; not possible
;; if noun2<minnpc then thrownotnpc
;; if noun2>maxnpc then thrownotnpc
;; throw something at someone - so treat as aggressive
;; object=noun1 here
;; gosub ithits ; print what happens
;; blowstrength=1
;; target=noun2
;; gosub makeenemies
;; goto dodamage
;;
;;.thrownotnpc
;; drop through to ithits
.ithits
 verb=ihit
;; object=noun1
 gosub @printOBJECTverb ; prints 'the object hits'
 object=noun2
 gosub @printTHEobject2 ; print out him etc.
 goto @printdot
;---
.CHECKIFLIGHT
; Return RESULT=TRUE if room is illuminated
; (either naturally or by objects etc.)
 goto @returntrue
;---
.BRIEF
.VERBOSE
 NORMALDESCRIPTIONMODE=VERB
 GOTO @DONE
;---
.immovable
 if actor<>user then @actorcantverbnoun1dot
 gosub @printTheObject
 m1=3150 ; won't move
 goto @varyERRORM1dot
;
.cut
.squeeze
.badobject
.cantwear
 goto @actorcantverbnoun1dot
;---
.initlocations
; go through and place the special locations in
; appropriate pseudo-random locations..
.drret
 return
;-----------------------------
.shortdesc ; print the short description for ROOM
 if room<minsynthroomminus1 then descstaticroom
 gosub @convertroom ; is there a special feature here?
 if x1=0 then drsynthesised
; x1 is room number in special rooms i.e. 1..24
 picturetodraw=x1
 x2=startsynthshortdescs
 add x2,x1
 message x2
; drop through to print tree/terrain combination at this location
;
.drsynthesised
;; X1=ROOM
;; GOSUB DRAWPICTUREX1
 x1=room
 x2=minsynthroom
 sub x1,x2
 x1=terraintable(x1)
 x3=2688 ; 2800-minsynthroomminus1(112)
 add x3,x1
 message x3
;;>>special to gnome - allow short descs as well. return
;---
.descstaticroom
 picturetodraw=room
 x1=shortroomdescs
 add x1,room
 message x1
 return
;---
.printROOM
 picturetodraw=0
 LASTWORDPRINTED=0 ; prevent printing of 'it'
 GOSUB @POSITIONSHADOWS
 if room=DestToDescribeExitsIn then dr1
 if descriptionmode=inone then drret
;
.dr1
 if actor<>user then drret ; never any description for npcs
 GOSUB @CHECKIFLIGHT
 IF RESULT=TRUE THEN DESCROOM1
 if wanttoprintand=FALSE then dr2
 wanttoprintand=FALSE
 message dot ; not linked to previous message
;
.dr2
 MESSAGE 2108 ; It's dark
 LASTPICTURE=0
 CLS G ; clear graphics window
 RETURN
;---
.DESCROOM1
 GOSUB @SPECIALactor ; print 'You are..'
 GOSUB @SETUPROOM
;
.ABSDESCROOM
 gosub shortdesc
;
.descroomremainder
 IF DESCRIPTIONMODE<>IBRIEF THEN DESCROOM3A
 if room=DestToDescribeExitsIn then descroom3a ; full desc of destinat
 MESSAGE DOT
 if normalDescriptionMode<>ibrief then descroom3e
 GOTO DESCROOM3C
;
.DESCROOM3A
 X1=LONGROOMDESCS
 ADD X1,ROOM
 MESSAGE X1
.DESCROOM3
 MESSAGE DOT
 gosub @specialdescbeforeexits
 if autoexits=ivoff then descroom3c
 GOSUB @PRINTEXITS
;
.DESCROOM3C
 gosub showpicture ; start selected picture drawing.

.descroom3e
 SEARCHPOS=ROOM
 HISEARCHPOS=0
 GOSUB @PRINTOBJECTS
 GOSUB @DESCactor
 GOTO @SPECIALDESC
;---
.showpicture
; displaypicture for room PICTURETODRAW
; this is either a static room number 2..25
; or a scenery object number 180..200
; or 255=forest
;; ****** ADD SPECIAL CODE TO SELECT PICTURE X1 ******
 x1=room
 gosub @GetTerrainType
 x2=x1 ; store terrain type

 x1=9 ; stone wall pic
 x3=currentpos(wall)
 if x3=room then sdrawpicturex1

 x1=19 ; hedge
 x3=currentpos(hedge)
 if x3=room then sdrawpicturex1

 x1=16 ; alchemists cottage
 if room<4 then sdrawpicturex1

 x1=4 ; hilly upkland
 if room=122 then sdrawpicturex1
 if room<8 then sdrawpicturex1

 x1=18 ; ominous green cave
 if room=139 then sdrawpicturex1
 if room<10 then sdrawpicturex1

 x1=17 ; outside alchemist's cottage
 if room=115 then sdrawpicturex1
 if room=120 then sdrawpicturex1

 x1=20 ; cliff
 if room=142 then sdrawpicturex1

; now pictures selected by terrain types:

 x1=1 ; road
 if x2=117 then sdrawpicturex1
 x1=3 ; scrubland
 if x2>0 then sdrawpicturex1 ; for all other outside locns.
 return
;---
.sdrawpicturex1
 goto @drawpicturex1
;---
;.drawpicturex1
;.dp3
; return ; disable pictures.
;
;; display picture X1
; if x1=lastpicture then dpret
; lastpicture=x1
;;
;.waitpic
; gosub @savelist9
;
;.waitpic1
;; make sure picture 1 has finished loading before doing any other pics
; x2=34 ; icheat
; prs "[Asking for picture " ;*
; print x1 ;*
; prs "]. " ; *
;;
;.picturenotcheat
; list9(3)=c0
; list9(4)=xcoord
; list9(5)=c0
; list9(6)=ycoord
; driver
; goto @restorelist9
;---
;.drawpicturex1
;; display picture for room X1
; if x1=lastpicture then dpret
; lastpicture=x1
; gosub @savelist9
; x2=32
; list9(0)=x2
; list9(1)=c0
; list9(2)=x1 ; picture number to draw
; x1=0 ; x co-ord
; list9(3)=c0
; list9(4)=x1
; list9(5)=c0
; list9(6)=c0 ; y co-ord
; driver
; goto @restocheat
; prs "[Asking for picture " ;*
; print x1 ;*
; prs "]. " ; *
;;
;.picturenotcheat
; list9(3)=c0
; list9(4)=xcoord
; list9(5)=c0
; list9(6)=ycoord
; driver
; goto @restorelist9
;---
;.drawpicturex1
;; display picture for room X1
; if x1=lastpicture then dpret
; lastpicture=x1
; gosub @savelist9
; x2=32
; list9(0)=x2
; list9(1)=c0
; list9(2)=x1 ; picture number to draw
; x1=0 ; x co-ord
; list9(3)=c0
; list9(4)=x1
; list9(5)=c0
; list9(6)=c0 ; y co-ord
; driver
; goto @restorelist9
;---
.CHECKEXIT
 ceroomsave=room
 room=from
 GOSUB ABSCHECKEXIT
 room=ceroomsave
 GOTO @SPECIALEXITS ; Exits conditional on game
;---
.ABSCHECKEXIT
; EXIT ( From FROM diection DIR )
; return DEST, DOOR, EXITVISIBLE
 door=FALSE
 dest=0
 exitvisible=FALSE
 if room<minsynthroomminus1 then fixedexit
;
; is there a fixed exit here? if so, it will override
; any synthesised exits that might otherwise operate
 gosub @convertroom
; now x1=1..25 if any scenery object is here
 if x1=0 then acesynthesised
 x2=minsceneryobjminus1
 add x1,x2
 EXIT x1 DIR STATUS DEST
 if dest>1 then checkexitstatus ; do rest of fixed exit code
; room 1 gives modifiers for synth rooms.
;
.acesynthesised
; ++++ please note: must have done gosub getXY BEFORE calling
 if dir=8 then acenorth
 if dir>2 then acenotnorth
.acenorth
 if y=ymax then acenoexit
.acenotnorth
 if dir=2 then aceeast
 if dir=3 then aceeast
 if dir<>5 then acenoteast
.aceeast
 if x=xmax then acenoexit
.acenoteast
 if dir=6 then acesouth
 if dir=5 then acesouth
 if dir<>4 then acenotsouth
.acesouth
 if y=0 then acenoexit
.acenotsouth
 if dir<6 then acenotwest
 if dir>8 then acenotwest
 if x=0 then acenoexit
.acenotwest
; look at the exit from room 1 to get the destination modifier
 x1=1
 exit x1 dir status dest
 if dest=0 then acenoexit
 add dest,from
 x1=dest
 x2=256
 gosub @x1modx2
 dest=x1
 exitvisible=TRUE
 return
;
.acenoexit
 dest=0
 return
;
.fixedexit ; See if there any fixed exits from here.
 DOOR=FALSE
 EXITVISIBLE=FALSE
 EXIT ROOM DIR STATUS DEST
 if dest=1 then ceret ; room 1 is used to give
; move modifiers for synthesised rooms.
 IF DEST=0 THEN CERET
 if dest<minsceneryobj then checkexitstatus
; find room which scenery object DEST is in - becomes destination room
 dest=currentpos(dest)
.CHECKEXITSTATUS
 X1=STATUS
 IF X1<4 THEN CE2
 DOOR=TRUE
 X2=4
 SUB X1,X2 ; subtract 4
.CE2
 IF X1>1 THEN CERET
 EXITVISIBLE=TRUE
.CERET
.kissret
 RETURN
;---
.close
 if noun1<>generaldoor then closenotdoor
 gosub @printACTORactiondot
.close1
 dooropen=FALSE
 return
;---
.closenotdoor
 goto @dontneedtodothat
;---
.closedoor
; subrouting called whenever door is to be closed
; (e.g. moving though it)
 if actor<>user then closedoorret
 dooropen=FALSE
;
.closedoorret
 return
;---
.parserun
; verb=isetuprun here
 againverb=isetuprun
 goto parsego1
;
.parsego
 againverb=isetupgo
; verb=isetupgo here
.parsego1
; return noun1 as room number of destination
 noun1=nullobject
 treetype=0
 terraintype=0
.gad1
 adjective1=nullobject
 adjective2=nullobject
 treatasfind=FALSE
 gosub getpart
 if gperror=TRUE then baddestination
 if treatasfind=TRUE then parsefindvalue
 if verb=0 then gadnotmove
 if verb<maxdirectionplus1 then gadend ; exit tidily for 'GO EAST'
.gadnotmove
 if noun1<>nullobject then gadend ; exit tidily for 'go interesting place'
 goto baddestination
;
.gadend
; clean up rest of input - may be useful, intelligent stuff,
; or it may be complete garbage
; Loop until we get a verb
 if nomoreinput=TRUE then gadret
 gosub @getnextword
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then gadend
 gosub @goback ; retrieve verb for later parsing
.gadret
 againnoun1=noun1
 noun2=nullobject
 return
;---
.parsefindvalue
; user entered 'go moveable object'
; treat as find
 if verb<>isetuprun then pfv1
 descriptionmode=inone
;
.pfv1
 verb=isetupfind
 noun1=value
 noun2=nullobject
 prep=0
 return
;---
.baddestination ; a parser error
 gosub @stop
 noun1=nullobject
 verb=0
 goto @cantseewhere
;---
.getparterror
 gperror=TRUE
 return
;---
.getpart
; return noun1 as destination room,
; or verb=direction to move in
; or treetype/terraintype
 gperror=FALSE
 gosub @getnextword
 if eol=TRUE then getparterror
; just possibly, could be a direction
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then getpart1
 if value=ivto then getpart ; go to ...
 if value>maxdirection then getpart1 ; strange verb
 ver2=nullobject then goloopnoadjective
 if value>adjective2 then goloopnoadjective
 if value<>adjective2 then goloop ; can't be right destination
;
.goloopnoadjective
 if value>maxsceneryobj then goloopnotlocationobject
;
.golooptreatasfind
; does object exist in game?
 x1=currentpos(value)
 if x1=0 then goloop
 treatasfind=TRUE
 return
;
.goloopnotlocationobject
; maybe 'go static location'
; if so, extract room number
 if value<700 then goloop ; shortroomdescs-nounoffset
 x1=700 ; shortroom2=nullobject then goloopnoadjective
 if value>adjective2 then goloopnoadjective
 if value<>adjective2 then goloop ; can't be right destination
;
.goloopnoadjective
 if value>maxsceneryobj then goloopnotlocationobject
;
.golooptreatasfind
; does object exist in game?
 x1=currentpos(value)
 if x1=0 then goloop
 treatasfind=TRUE
 return
;
.goloopnotlocationobject
; maybe 'go static location'
; if so, extract room number
 if value<700 then goloop ; shortroomdescs-nounoffset
 x1=700 ; shortroomdescs-nounoffset
 noun1=value
 if value<1000 then goloopshortdescs ; longroomdescs-nounoffset
 x1=1000 ; longroomdescs-nounoffset
.goloopshortdescs
 sub noun1,x1
 return
;---
.gdgoxy
 if y<noun2 then gdgonorth
 if y>noun2 then gdgosouth
; y=y1; so just go east or west
 if x=noun1 then @followfinished ; have arrived at destination, terminate command
 dir=3 ; east
 if x<noun1 then gdgotdir
 dir=7
 goto gdgotdir
;
.gdgosouth
 dir=4 ; south
 if x=noun1 then gdgotdir
 dir=5 ;se
 if x<noun1 then gdgotdir
 dir=6 ;sw
 goto gdgotdir
;
.gdgonorth
 dir=1 ; north
 if x=noun1 then gdgotdir
 dir=2 ;ne
 if x<noun1 then gdgotdir
 dir=8
; fall through to gdgotdir
.gdgotdir
 intendeddirection=dir
 anglefromintended=0
 gdroomsave=room
.gdtrydir
 from=room
 dir=intendeddirection
 gosub adddir
;
 gosub @checkexit
 if exitvisible=FALSE then tryanotherdirection
 if dest<minsynthroomminus1 then tryanotherdirection
 hidest=0
 verb=dir
 commandfinished=FALSE
 gosub @move ; move the npc, describing as appropriate
;
; if a specialmoves trap was activated, we have to abort the
; find. (Because a message will have been printed, so continuing
; would just confuse the player. A better tracking algorithm
; in future games MIGHT be able to get round this)
 if blockedbysm=TRUE then @followjustfinished ; something badly wrong.
 if room=gdroomsave then tryanotherdirection ; something went wrong
 if room=destnoun1 then @followjustfinished
 return ; all went well.
;---
.tryanotherdirection
; have reached an obstruction in a goaldirected movement
 if anglefromintended>negative then tad2 ; am wheeling to left
 if anglefromintended<>0 then tad1 ; am wheeling to right
 anglefromintended=1
 goto gdtrydir
;---
.tad1
; was not going in intended direction when the obstruction
; was reached
; try wheeling round to right (clockwise)
 if anglefromintended=2 then tad2a
 add anglefromintended,c1 ; try +1, +2
 goto gdtrydir
;---
.tad2a
 anglefromintended=0
.tad2
; try wheeling round to left
 if anglefromintended=65534 then cantgothere ; can't cope at present
 sub anglefromintended,c1 ; try -1,-2
 goto gdtrydir
;---
.cantgothere
 if actor<>user then @NpcNotUnderstood
 m1=3604 ; can't go there from here
 gosub @printM1dot
 goto @followfinished
;---
.adddir
; do add dir,anglefromintended
; this is complicated because south,southeast are swapped round
; Also must wrap round at north, northwest
;
; first, swap south,southeast
 gosub swapdir
 add dir,anglefromintended
 gosub makedirwithinbounds
; fall through to swapdir ; and swap back again
;
.swapdir
; swap round south, southeast
 if dir<>4 then swapdirnotsouth
 dir=5
 return
;---
.swapdirnotsouth
 if dir<>5 then swapdirret
 dir=4

.swapdirret
 return
;---
.makedirwithinbounds
 if dir<9 then mdwb1
 dir=1
 return
;---
.mdwb1
 if dir>0 then mdwb2
 dir=8
.mdwb2
.diwtret
.mmdret
.teleportret
.ringret
 return
;---
.teleport
 cif AllowCheat
; we came here straight from the parser, so set up verb...
 if cheatmode=0 then @nicetry
 verb=iteleport
.allowteleport
 gosub @parsego
 if noun1=nullobject then teleportret
 if verb<>isetupfind then teleporttonoun1
 object=noun1
 gosub @getobjectposx2
 noun1=x2
;
.teleporttonoun1
 dest=noun1
;
.magicmove
 hidest=0
;
.magicmovedest
 if dest=0 then mmnomove
 if dest<2 then @cantseewhere
 currentpos(actor)=dest
 hicurrentpos(actor)=hidest
.mmaftermove
 gosub @setuproom
 gosub @getxy
 if actor<>user then mmdret
 currentuserroom=room
 gosub @printroom
 GOTO @CANCELINPUT
;---
 cend
.mmnomove
 m1=2995 ; you end up where you were
 gosub @printM1dot
 goto @cancelinput ; goto mmaftermove
;---
.noexit
 if room<minsynthroom then noexit5
 m1=2538 ; won't leave to north/east/west of grid
.noexit1
 if x<>0 then noexit2
 if dir=7 then noExitPrint

.noexit2
 if x<>5 then noexit3
 if dir=3 then noExitPrint

.noexit3
 if y<>4 then noexit4
 if dir=1 then noExitPrint

.noexit4
 if y<>0 then noexit5
 m1=2536 ; won't go back to part1
 if on
 gosub @destroyobject
 gosub @printTheActor
 m1=2509 ; died
 gosub @printM1Dot
 gosub @stop
 object=actor
 goto @Destroyobject
;---
.plant
; plant seed/bulb
 if object>81 then NotFertile
 if object<80 then NotFertile
 x1=room
 gosub @GetTerrainType
 if x1<>112 then NotFertile
 gosub @destroyobject
 if object<>seed then plantNotSeed
 greenslavegrown=10
 object=greenslave
 goto GrowObject

.PlantNotSeed
; must be bulb
 telelilysgrown=10
 object=whiteTelelily
 gosub GrowObject

 on
 gosub @destroyobject
 gosub @printTheActor
 m1=2509 ; died
 gosub @printM1Dot
 gosub @stop
 object=actor
 goto @Destroyobject
;---
.plant
; plant seed/bulb
 if object>81 then NotFertile
 if object<80 then NotFertile
 x1=room
 gosub @GetTerrainType
 if x1<>112 then NotFertile
 gosub @destroyobject
 if object<>seed then plantNotSeed
 greenslavegrown=10
 object=greenslave
 goto GrowObject

.PlantNotSeed
; must be bulb
 telelilysgrown=10
 object=whiteTelelily
 gosub GrowObject

 object=BlueTelelily
; drop through to GrowObject...
;-
.GrowObject
 gosub @createobject
 gosub @PrintTheObject
 m1=2600 ; grew
 goto @PrintM1Dot
;---
.NotFertile
 m1=2602 ; couldn't have grown
 gosub @printM1
 gosub @printTheObject
 m1=2603 ; here
 goto @printM1Dot
;---
.drink
 object=noun1

.drinkObject
 if object<95 then drinkNotPotion
 if object>100 then drinkNotPotion
 objectsave=object
 gosub @destroyobject
 object=objectsave
 m1=2608 ; tasted like pot noodle
 if object=potionOfGunge then @printm1dot

.drinkNotPotion
 m1=285 ; bleuch
 if object<>antidote then @printm1dot
 AntidoteDrunk=10
 m1=2601 ; antidote tasted nasty
 HaveDrunkAntidote=true
 goto @printm1dot
;---

