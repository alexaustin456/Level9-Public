; Lancelot source, copyright (C) 1988 Level 9 Computing.
;
; NPC.TXT, the non-player character control logic for the game. This 
; copes with NPC racetracks, queued commands and how they decide 
; what to do. As the philosophy of Level 9's is to treat NPCs and 
; the user as being as equal as possible, the code to cope with 
; actual NPC actions should be the same as that for player actions, 
; and found elsewhere.     
;
; Late changes:
;
;>>mike 26/3/88 - two changes to DOIWantFollowNoun1 to
;GOSUB @CHECKTYPE
 IF VALUE=ICOMMA THEN @PINEXT
 IF VALUE<>nullvalue THEN @PINEXT

 SEARCHTYPE=NUMBTYPE
 GOSUB @CHECKTYPE
 IF VALUE=nullvalue THEN PINOTNUMBER
 INUMBER=VALUE
 ADD VERBSTOCALL,C1
 GOTO @PINEXT

.PINOTNUMBER
; ANYTHING ELSE (CONJ, VERBS ETC.) TERMINATE THIS SENTENCE
 GOSUB @GOBACK ; STORE (VERB?) FOR FUTURE ANALYSIS

.PIEND
 IF EVENTUALPREP=0 THEN PIendnoprep
 PREP=EVENTUALPREP
.PIendnoprep
; check for 'drop bench and on' type construct
; if no noun2 was detected after a prete
;
;>>mike 15/5/88 small change to Boat code
;
;>>mike 2/6/88 - .REPORTPROBLEM changed to allow NPCs to report problems!
; problem was incorrect checking of MASTEROFFSET near start.
;
CONST
;
BEGIN
;
.setupuser
 actor=user
 gosub @setuproom
 gosub @setACTORATTRIBUTES
 gosub @initfifo
 goto @healactor
;>>mike 28/3/88 processed=false ; set when it has done something
;>>mike 28/3/88 return
;---
.MAINLOOP
 STACK
 forceprinting=false ; just in case!
;>>removed by L2 anythingprintedthisturn=false
 gosub @tickclock
;
; now the player's turn...
 gosub @setupuser
;
;>>mike 28/3/88  x4=npcptroffset
;>>mike 28/3/88  add x4,actorattributes
;>>mike 28/3/88  x1=npccurrent(x4) ; number of current command
;>>mike 28/3/88  if x1=0 then ml2 ; ACTOR has no queued commands
;
; ACTOR is in the middle of a goal-directed command,
; so obey it!
 gosub @executeanyorders
 if executeprocessed=true then @mainloopnpc

;;.ml2
; now do the more general ideas, such as
; 'follow someone unless I have something better to do'
 verb=0
 commandfinished=false
 gosub @doiwantfollow
 if FatalError=true then getFromUser ;>>mike 27/3/88
;>>mike 26/3/88 if fatalerror=false then ml3
;>>mike 26/3/88 gosub @stopfollowing

;;.ml3
;>>mike 28/3/88  if executeprocessed=false then followok
;>>mike 28/3/88  gosub @savelist9
;>>mike 28/3/88  gosub @checkforescape ;checkkbd
;>>mike 28/3/88  gosub @restorelist9

;;.followok
 if executeprocessed=true then @mainloopnpc ; it has been done

.getfromuser
 stacöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööönVERBvarsAREverbVARS
 AGAINVERB=VERB
 AGAINNOUN1=NOUN1
 AGAINNOUN2=NOUN2
 AGAINPREP=PREP
 RETURN
;---
.CHECKIFSCENERYHERE
; given OBJECT as a noun requested by user (relative to NOUNOFFSET)
; see if it is part of a room description, and
; if so, return RESULT=TRUE if in current room
; drop through to return TRUE
;; .sceneryhere
 processed=TRUE
.RETURNTRUE
 RESULT=TRUE
 RETURN

.RETURNFALSE
 RESULT=FALSE
 RETURN
;---
.MARKOBJECT
; mark object as X1
 X2=OBJECTTABLE(otbase)
 IF X2=0 THge 2128 ; would you prefer to use GO instead?

.movenosarc
 GOSUB @PRESENTMULTIPLE ; EXECUTE ACTOR COMMAND

.mlsay
 if verb<>isay then @mainloop
; say by-passes normal presentmultiple, so npcs
; will not move unless we activate them now.
 goto MainLoopNpc1 ; not stored command or follow, so skip interrupt check
 
.mainloopnpc
 gosub @savelist9
 gosub @checkforescape ;checkkbd;>>mike 28/3/88 
 gosub @restorelist9;>>mike 28/3/88 
 if result=true then @getfromuser ; clears stack etc.;>>mike 28/3ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööed=true
 return
;---
.racetrackgotonoun12gc
; note: compiler crashes if 'racetrackgotonoun12getcurrent' is used!
 gosub @npcgetcurrent ; get x1=current action in npcstack
;
;;.racetrackgotonoun12
; current position of racetrack for ACTOR is (NOUN1,NOUN2)
; NPCs current stack entry is npcstack(x1)
; write value back to it
 gosub @getMessageNumber; value=noun1; gosub @valuetimes256; add value,noun2

.racetrackgotovalue
; current position of racetrack for ACTOR is VALUE.
; NPCs current stack entööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööt within list5
; and noun2 has low byte of offset of current instruction
; within list5
 gosub @getMessageNumber ; value=noun1, gosub @valuetimes256, add value,noun2
.DOORTNoun1
; now value is offset of current racetrack instruction
; within list5

 cif allowcheat
  if cheatmode<>2 then doortnotdebug1
  prs "[rt at "
  print value

.doortnotdebug1
 cend


 verb=list5(value)
 add value,c1
 prep=list5(value)
 add value,c1
 noun1=list5(value)
 add value,c1
 noun2=list5(value)
 add value,c1

 cif allowcheat
  if cheatmode<>2 then doortnotdebug
  prs " actor="
  print actor
  prs " command="
  gosub @debugshowcommand

.doortnotdebug
 cend
 if verb=0 then @eptrue
 gosub @npcgetcurrent ; set up x1=current actor command in npcstack
 gosub racetrackgotovalue ; set up new current address

 executeprocessed=false
 if verb=rtConditional then doRtConditional
 if verb=rtActorVaryMessage then doRtActorVaryMessage
 if verb=RtActorSingleMessage then DoRtActorSingleMessage
; if verb=racetracksay then racetrackobeysay
 if verb=racetrackmessage then racetrackobeymessage
 if verb=racetrackgoto then racetrackobeygoto
 if verb=racetrackgosub then racetrackobeygosub
 if verb=racetrackreturn then racetrackobeyreturn
 if noun1<mincollective then @singlepushfifo
 if noun1>maxcollective then @singlepushfifo
 gosub @initfifo
 gosub @setupgdaccess ; push on appropriate order (two parts to command)
 goto @linkonfifocommandqueue
;---
.DoRtConditional
; only execute next instruction if NOUN1 is present
; ValueSave=value
 object=noun1
 gosub @CheckIfPresent
; value=ValueSave
 if result=true then @doortNoun1
 x1=4
 add value,x1 ; skip conditional instruction
;;.DRTC1
 gosub @npcgetcurrent ; get x1=current action in npcstack
 gosub @racetrackgotovalue
 goto @doortNoun1
;---
.DoRtActorSingleMessage
 gosub @PrintActor
 gosub RacetrackObeyMessage
 goto @EpTrue
;---
.DoRtActorVaryMessage
 gosub @PrintActor
 gosub GetMessageNumber
 gosub @specialrtMessage
 goto @VaryMessageDot
;---
.racetrackobeymessage
 gosub GetMessageNumber
 gosub @specialrtmessage
 goto @printM1dot
;---
.GetMessageNumber
 value=noun1
 gosub @valuetimes256
 add value,noun2
 m1=value
 return
;---
;.racetrackobeysay
; value=noun1
; gosub @valuetimes256
; add value,noun2
; m1=value
; goto @actorsays
;---
.racetrackobeygoto
 gosub @racetrackgotonoun12gc
 goto @doobeyracetrack
;---
.racetrackobeygosub
 verb=obeyracetrack
 goto @singlepushfifo
;----
.racetrackobeyreturn
;>>mike 2/4/88 gööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööOTNUMBER
 WORDTYPE=VALUE
; STRIP OFF TOP THREE (WORDTYPE) BITS
 X1=32
.RIL1
 IF VALUE<32 THEN RIL2
 SUB VALUE,X1
 GOTO RIL1
.RIL2
 GOSUB VALUETIMES256
 X1=1
 ADD X1,INDEX
 X2=LINPUT(X1)
 ADD VALUE,X2
; Separate out WORDDYPE = top three0bits
 X2=WORDTYPE
 WORDTYPE=ASCITYPE
 X1=ASCIOFFSET
 IF X2<32 THEN RILRET
 WORDTYPE=VERBTYPE
 X1=VERBOFFSET
 IF X2<64 THEN RILRET
 WORDTYPE=CONJTYPE
 X1=CONJOFFSET
 IF X2<96 THEN RILRET
 WORDTYPE=PREPTYPE
 X1=PREPOFFSET
 IF X2<128 THEN RILRET
 WORDng pending
.eaoverb
 if verb>15 then eaonotdir
 gosub @move
 CommandFinished=true ;>>mike 26/3/88
; executeProcessed will be set here if anything happened
 return ;>>mike 26/3/88
;>>mike 26/3/88 goto @setcommandfinished

.eaonotdir
 if verb=obeyracetrack then @doobeyracetrack
 if verb=IReportProblem then @GDReportProblem
 noun1isgd=false
 if verb=ikill then @eaonotgdnoun1 ; collective
 if verb=ifollow then @gdfollow ;eaonotcollective
 if verb=igdgo then @gdgo
 if noun1<mincollective then eaonotcollective
 if noun1>maxcollective then eaonotcollective
 noun1isgd=true
 gosub @gdnoun1
 if noun1=nullobject then @epfalse ; reached end of range

.eaonotcollective
 object=noun1
 if verb=ifollow then @gdfollow
 if verb=igdgo then @gdgo
 if verb=igdfind then @gdfind
 if verb=igoout then @gdgoout
 if verb=iwaitforperson then @gdwaitforperson
 if verb=iwaitforperiod then @gdwaitforperiod
 if verb=ireturnobject then @returnobject
 if noun1=nullobject then eaononoun1
; check if noun1 is present
 gosub @selectobjectpos
 if verb=itell then eaononoun2

 gosub @checkifaccessible
 if result=true then eaononoun1

 gosub npcneedsobject
 if executeprocessed=true then @eaoret

.eaononoun1
 if noun2=nullobject then eaononoun2
; only acceptable if noun2 is carried...
 if prep<>with then eaochecknotcarried
 if verb=igive then eaochecknotcarried
; lots of commands - like "kill knight with axe" - must
; be carrying noun2 for the command to be obeyed.
 x1=currentpos(noun2)
 hisearchpos=nouncarried ; force object to be carried
 if x1<>actor then needsnoun2
 x1=hicurrentpos(noun2)
 if x1<>0 then eaononoun2
.needsnoun2
 object=noun2
 gosub npcneedsobject
 if executeprocessed=true then @eaoret ; must do verb next turn
 goto eaononoun2

.eaochecknotcarried
; commands like "put xx in cabinet" where noun2
; cannot be carried
 object=noun2
 gosub @checkifpresent
 hisearchpos=nonspecific
 if result=false then needsnoun2

.eaononoun2
;>>mike 28/3/88 if verb=ikill then eaonotgdnoun1
 if noun1isgd=true then eaonotgdnoun1
 commandfinished=true ; once-only verb, or not understood.

.eaonotgdnoun1
; ok, so call the verb!
 gosub @preactorcr
 if verb=iwait then @shortwait
 if verb=ikill then @gdkill
 goto @callverb
;-------
.calcinitialpos
; for object x1
; return x1=initial lo pos, x2=hi initial pos for object x1
; where is initial position?
 add x1,x1
 x2=objectstart(x1)  ; hi initial pos
 add x1,c1
 x3=objectstart(x1) ; lo initial pos
 x1=x2
 x2=16
 goto @x1modx2
;---öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö @printTHEobjectx1
  prs " is trying to find "
  gosub @printTHEobject
  prs " ("
  print object
  prs ")]"
  message cr

.nno1
 cend


 noun1=object ; for benefit of take etc.
; commandfinished=false ; for safety only
 gosub @makelocal
 if executeprocessed=true then npcneedsobjectret
; if commandfinished=true then npcneedsobjectret ; can't find - abort
; didn't follow, so although we were in the same room
; the verb handler must need the object to be carried
; here, commandfinished=falseöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö being done

.nrogotobject
; ACTOR is in the process of returning NOUN1
; to its initial position
; where is initial position?
 x1=noun1
 gosub @calcinitialroom
; OBJECT should go to pos x1, hi pos x2
 if room=x3 then returnobject3 ; we are in the right room!
; move towards room x3
 dest=x3
 goto @gdfollowdest
;
.returnobject3
 if verb<>ireturnobject then roret
; put it back!
 commandfinished=true ; kill 'recover' command
 x1=object
 add x1,x1
 x2=objectstart(x1)
 add x1,c1
 x3=objectstart(x1)
; x3=lo initial pos, x2=hi initial pos
 x1=x2
 x2=16
 gosub @x1modx2
; x1=hi initial pos, x3=lo initial pos
 verb=idrop
 noun2=nullobject
 prep=0
 if x1=0 then @callverb
 verb=iwear
 if x1=worn then @callverb
 verb=iput
 noun2=x3
 prep=x1
 goto @callverb
;---
.makelocal
 gosub @getobjectposx2
; now x2=room where OBJECT is
 executeprocessed=false
 if x2=room then makelocalhere ; take it!
 dest=x2
 gosub @gdfollowdest
 executeprocessed=true ; but don't want to waste time.

.öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö

.crdend
 verb=dir
.crdret
.dontwantfollow
;;.noattack
 executeprocessed=false
;;.oidret
 return
;---
.followdead
 fatalerror=true
;>>mike 28/3/88 executeprocessed=false
;>>mike 28/3/88 commandfinished=true
 object=noun1
;;.objectisdead
 if actor<>user then @ReportProblem ;>>oidret
.printdead
 verb=iam
 gosub @printOBJECTverb
 m1=3560 ; dead
 goto @printM1dot
;---
;>>mike 26/3/88.targetishere
; commandfinished=true
; goto @epfalse
;---
;>>mike 28/3/88.gdfollowcantfind
;>>mike 28/3/88 executeprocessed=false
;>>mike 28/3/88 fatalerror=true
;>>mike 28/3/88 m1=2048 ; i can't find 
;>>mike 28/3/88 gosub @errorm1
;>>mike 28/3/88 object=noun1
;>>mike 28/3/88 gosub @printTHEobject2
;>>mike 28/3/88 gosub @printdot
;>>mike 28/3/88 goto @ReportProblem ;>> goto @epfalse
;---
.gdfollowdoesntexist
 gosub @ReportProblem ;>> return
 executeprocessed=true
 return
;---
.doiwantfollow
; follow someone if appropriate
; return executeprocessed=true if we have followed
;>>mike 28/3/88 ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööowing ; some problem
;;.diwfret
;;.sufret
.gdfindRet
 return
;---
.setupfind
 gosub @stopfollowing

 verb=igdfind
 itword=noun1
 goto @SinglePushFifo ;>>mike 28/3/88 (used by user only)
;>>mike 28/3/88 gosub @npcpushfifo
;>>mike 28/3/88 gosub @linkonfifocommandqueue
;>>mike 28/3/88 gosub gdfind
;>>mike 28/3/88 if commandfinished=false then sufret
;>>mike 28/3/88 goto @intelligentpop
;---
.gdfind
 x4=noun1 ; character to follow
 x6=room
 gosub @setuproomx4 ; return ROOM=position of x4
 ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööor "
  print actor
  prs " is trying to follow "
  print noun1
  message cr
.gdfollownotdebug
 cend

 fatalerror=false
 x4=noun1 ; character to follow
 x6=room
 gosub @setuproomx4 ; return ROOM=position of x4
 if x6<>room then gdfollownothere

;>>specials to Lancelot
.MaybeBoat
; get into boat if here
 x1=hicurrentpos(noun1)
 x2=hicurrentpos(actor)
 if x1=x2 then BoatFalse
; get in or out!
 if x1=0 then BoatOut ;>>mike 15/5/88
 object=currentpos(noun1)
 gosub @CheckIfPresent
 if resuöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö if result=false then @followdead

.gdfollowobject
 dest=room ; destination room just calculated by setuproomx4
 noun1=room
 room=x6 ; restore saved source room
; drop through to  gdfollowdest
;
.gdfollowdest
 if actor<>user then gdfd1
 DestToDescribeExitsIn=dest

 cif L2
; stop player when he meets certain important people...
 if room<>106 then NotElm
 x1=currentpos(lady)
 if x1=room then EmergencyStopFollow
.notElm
 if room<>27 then Not30Knights
 x1=currentpos(ThirtyKnights)
 if x1<>roööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööon are in the same complex
 gosub @tracex1tosynth
 if dest=0 then gdgoerror ; can't find
 if processed=true then @gdfollowgoin
; now x1=synth room in which the destination is based
; store it away in synthdest
 synthdest=x1
 if x1=room then @gdgoin2 ; am outside the complex containing dest

; now trace source room through to synth room
 x1=room
 x6=dest ; compare all rooms with destination in case both
; source and destination are in the same complex
 gosub @tracex1tosynth
 if dest=0 then gdgoerror
 if processed=true then @gdgoout
; now x1=synth room in which the source is based
;
 if synthdest=dest then followdifferentcomplex ; go just outside complex
 if x1<>synthdest then followdifferentcomplex


 cif allowcheat
  if cheatmode=0 then gdgonodebug
  prs "Bug!! - no match during tracex1tosynth. " ;*
.gdgonodebug
 cend

 goto @gdgoout ; bug!!!! - should
; have been matched on one tracex1tosynth or the other
; because they are both in the same complex.
; The only likely explanation is that there are multiple,
; non-connecting paths to the exit.
;
.followdifferentcomplex
; source and destination are NOT in the same complex.
; Therefore, go out.
 if room<minsynthroomminus1 then @gdgoout
;
 destnoun1=noun1
 room=synthdest
 gosub @getxy ; of destination
 noun1=x ; destination x
 noun2=y ; destination y
 gosub @setuproom ; for npc to move again
 gosub @getxy ; current co-ordinate
 goto @gdgoxy
;---
.CantGoThere
.gdgoerror
 if actor<>user then ReportProblem ;>>gdgoerr1öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö
 if severalexits=TRUE then peret2 ; already printed message
 IF wordsoutput>2 THEN PERET2
 MESSAGE 11 ; ONLY VISIBLE EXIT IS
.PERET2
 GOSUB @OUTWORDnone ; flush bufer
 if wanttoprintand=FALSE then peret
 message dot
 wanttoprintand=FALSE
.PERET
 RETURN
;---
; Print list of objects in specified position..
;
;---
.GETNEXTOBJECT
; RETURN OBJECT=OBJECT FOUND
;    SEARCHPOS=ROOM OR CONTAINER WHERE FOUND
;  HISEARCHPOS=TYPE OF CONTAINMENT (=0 FOR ROOMS)
;
; BEFORE FIRST CALL, GOSUB INITGETOBJ room=currentUserRoom then GDReportProblem1 ; also pops the command

 gosub @IntelligentPop
 verb=ireportProblem
 noun2=problemObject ; save problem object for report
 prep=0
 fatalerror=false
 commandfinished=false
 executeprocessed=true
 goto @SinglePushFIFO ; gosub, return
;---
.GDReportProblem
 noun1=user
 gosub @GDFollow
 noun1=noun2 ; set up problem object for report
 if executeProcessed=False then GdReportProblem1
 commandfinished=false
 return ;=true then GDReportProblemRet ; still oööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööe necessary -
; occasionally, unsuccessful follow commands leave ProblemObject=38
; when they fail. Dunno Why!

 m1=3190 ; I couldn't do what you asked with
 gosub @PrintM1 ;&&&
 object=noun1 ;&&
 gosub @PrintTheObject ;&&
 m1=quote ;&&
 gosub @Printm1 ;&&
 gosub @PrintDot ;&&

.GdReportProblem3
.GdRPEnd
 gosub @IntelligentPop ;>>NPCPOP
 goto @SetCommandFinished

;---
.gdfollowgoin
; am on a goal-directed go/follow
; tracing along the OUT pointers from dest has come across
; the current location. The last move was in direction DIR,
; from room FROM,
; reverse direction....
 x1=dir
 add x1,startreversaltable
 dir=list5(x1)
 gosub @preactorcr
 verb=dir
 gosub @move ;callverb
 if commandfinished=true then ffret ;>>>>>>>> special to gnome
 if FatalError=True then @gdgoerror ;>>mike 14/2/88

; if executeProcessed=false then @gdgoerror ;>>mike 9/2/88
; if room>minsynthroomminus1 then @gdgoerror ; move failed, so abort
;>>mike 28/3/88 processed=true
 if room=noun1 then @followjustfinished ; reached destination
.ffret
 return
;---
.gdgoin2
; are being asked to go 'IN' when in a grid location
 dir=ivin
 gosub @preactorcr
 verb=dir
 gosub @move ;callverb
 if executeProcessed=false then @Gdgoerror ;>>mike 9/2/88
;>>mike 9/2/88	 if room>minsynthroomminus1 then @gdgoerror ; move failed, so abort
 processed=true
 if room=noun1 then @followjustfinished ; reached destination
 return
;---
.gdgoout
 if room>minsynthroomminus1 then @followjustfinished ; we must have arrived
; ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööd room.
;
;; first of all, increment the boredom counter for all npcs...
; gosub increaseboredom

;>>removed for L2 lastuserroom=lastroom
; activationsremaining=maxactivations
;; do npc movement for the room where the user is NOW
 actor=user
 gosub @setuproom
 currentuserroom=room
; gosub npcactionsroom
;
; if againverb>maxdirection then npcanotmove
;; user has just moved, so give the npcs in the room he was
;; just in a crack of the whip (possibly literally!)
; room=lastuserroom
; if room=0 then npcanotmove
; gosub npcactionsroom
; if activationsremaining>negative then npcaend
;
;.npcanotmove
; now go through all npcs to see which are getting impatient.
; For each npc, we have npccurrent(boredomoffset) which
; gives the number of turns since it was last activated
; And npcinitial(patienceoffset) which gives the number of
; turns it is prepared to wait.
 actor=2
.npcaloop
 if actor=user then npcanoneedtoactivate
 gosub @setACTORATTRIBUTES
;>>l2; has a high-priority event happeneöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööötionoffset
;>>l2 add x1,actorattributes
;>>l2 npccurrent(x1)=c0 ; clear attention flag
;>>l2 return

;;.npcaloop1
; is npc inactive?
 x1=npccurrent(actorattributes)

 cif AllowCheat
  if cheatMode<2 then nalNoCheat1
  if CheatMode>32000 then nalNoCheat1
  prs " actor=";*
  print actor ;*
  prs ". " ;*
  print x1 ;*
  message space ;*
.nalNoCheat1
 cend

; if x1<128 then npcaLoopActivate
 if x1<64 then npcaLoopActivate
;; if x1<128 then npcaNoNeedToActivate ; failsafe
 gosub @SetupRoom
;; if Room=CurrentUserRoom then Activateit

 cif AllowCheat
  if cheatMode<2 then nalNoCheat2
  if CheatMode>32000 then nalNoCheat2
  prs " room=" ;*
  print room ;*
  prs " cur=" ;*
  print CurrentUserRoom ;*
.nalNoCheat2
 cend

 x1=npccurrent(actorAttributes)
 if room<>CurrentUserRoom then npcANoNeedToActivate
;;.ActivateIt
 npccurrent(actorAttributes)=c0 ; make it permamently active.
 goto npcaactivate ; activate it immediately for quick response

.npcaLoopActivate
; now see if npc iVERBx1 ; print verb, with appropriate ending for an actor of x1
;; verb=x1
 m1printsave=m1
 if verb=iam then pvam
 goto printverbNoEnding
; m1printsave=m1
; m1=verb
; if verb=iHAVE then pvhave
; if verb=iAM then pvam
; gosub @printverbnoending
;; now add appropriate ending, or none for USER
; if x1=user then @pvreturn
; m1=579 ; force printing of existing word, without trailing space
; gosub @printM1
; m1=581 ; verb ending 'es'
; if verb=isearch then pves
; if verb=isetupgo then pves
; if ve!
.npcaactivate
; sub activationsremaining,c1
; if activationsremaining>negative then npcaend
 gosub activatenpc
.npcanoneedtoactivate
 add actor,c1
 if actor<maxnpcplus1 then npcaloop

.npcaend

 actor=user
 gosub @setuproom
 gosub @setACTORATTRIBUTES
 goto @initfifo
;---
;>>mike 28/3/88.npcactionsroom
;>>mike 28/3/88 NoTreasureInRoom=false ; first greedy npc will check
;>>mike 28/3/88 if room=0 then npcaret
;>>mike 28/3/88 roomtoactivate=room
;>>mike 28/3/88 ACTOR=minnpc
;>>mike 28/3/88.anothernpc1
;>>mike 28/3/88 room=roomtoactivate
;>>mike 28/3/88 object=actor
;>>mike 28/3/88 gosub @checkifpresent
;>>mike 28/3/88 if result=false then npcar1
;>>mike 28/3/88; any time to activate it this turn?
;>>mike 28/3/88 sub activationsremaining,c1
;>>mike 28/3/88 if activationsremaining>negative then npcaret
;>>mike 28/3/88 gosub activatenpc
;>>mike 28/3/88.npcar1
;>>mike 28/3/88 add ACTOR,c1
;>>mike 28/3/88 if ACTOR<maxnpcplus1 then anothernpc1
;>>mike 28/3/88.npcaret
;>>mike 28/3/8ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööBUTES
; reset boredom counter
; x1=boredomoffset
; add x1,actorattributes
; x2=npccurrent(x1)
; if x2=0 then aanret ; already activated this turn
; npccurrent(x1)=c0
;
 x1=hitpointoffset
 add x1,actorattributes
 x1=npccurrent(x1)
 if x1=0 then aanret ; dead!

 verb=0
 noun1=nullobject
 noun2=nullobject
 prep=0
; ACTORATTRIBUTES REMAINS SET UP THROUGHOUT PROCESSING OF THE NPC
;
; reduce hatred of current enemy
 x1=hatredoffset
 add x1,actorattributes
 x2=npccurrent(x1)
 if x2=0 then annohate
 sub x2,c1
 npccurrent(x1)=x2
.annohate
 gosub @healactor
;
 processed=false
 gosub @specialactivatenpc
 if processed=true then aanret
 if verb<>0 then @eaoverb ; do it immediately


 gosub decisioncode
 if executeprocessed=true then npcret
; don't want to do any of the useful possibilities - consider random things
;
; maybe it could move?
 gosub @CanActorMove
 if result=false then npcm1
 random x1
 if x1>200 then @npcmove

.npcm1
; nothing else for it, so consider singing of gold...
 random x1
 if x1>160 then @npcgoldsinging

.npcret
.aanret
.DecisionCodeRet
.npcmoveret
 RETURN
;---
.decisioncode
 gosub @amiincombat ; gives result=true if currently fighting someone
 if result=true then @defendMyself
; check for other actions
;
; any orders waiting? (either from previous happenings,
; or from the npc's master)
; (taken out of loop below to avoid variable conflicts etc.
; Probably possible to re-insert with a little thought -
; but only saves one variable)
;


 gosub @npcgetcurrent ; get stack pointer x1 for actor
 add x1,c1
 orderwaiting=npcstack(x1) ; 0 if none
; another form of orders is following someone...
 if orderwaiting<>0 then decidenotfollow
 gosub @checknullaction
 if orderwaiting<>0 then decidenotfollow
 goto DNF1		 ;>>mike 29/3/88

.decideNotFollow	 ;>>mike 29/3/88
; try executing current orders if obedient enough
 x1=obedienceOffset	 ;>>mike 29/3/88
 add x1,ActorAttributes  ;>>mike 29/3/88
 x1=npcInitial(x1) 	 ;>>mike 29/3/88
 if x1=255 then DNF0	 ;>>mike 29/3/88
 random x2	 	 ;>>mike 29/3/88
 if x2>x1 then DNF1	 ;>>mike 29/3/88
.DNF0			 ;>>mike 29/3/88


 gosub @ExecuteAnyOrders ;>>mike 29/3/88
 if executeProcessed=true then DecisionCodeRet ;>>mike 29/3/88

.DNF1
 x1=followoffset
 add x1,actorattributes
 x1=npcCurrent(x1)
 if x1<>0 then @DoIWantFollow ;>>mike 29/3/88
;>>mike 29/3/88 if x1=0 then decidenotfollow
;>>Mike 29/3/88 orderwaiting=ifollow

;>>mike 29/3/88.decidenotfollow
;>>mike 29/3/88 if orderwaiting=0 then epFalse ;>>L2 decidenoorders

;;.decidenoorders
;
; now some high priority events, such as on-going combat...
;
; gosub @amiincombat ; gives result=true if currently fighting someone
; if result=true then @defendMyself
 goto @epfalse

; if result=false then decidenotcombat
; X1=CURRENTPOS(NOUN1) ; but is the enemy here?
; IF X1=ROOM THEN @defendmyself ; yes - so have to attack or run away
; no - so only chase it if nothing better to do
;
; now some high priority events, such as on-going coööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööset up new biggest margin
;>>mike 29/3/88 x6=x1 ; set up new item
;>>mike 29/3/88.decideloop2
;>>mike 29/3/88 add x1,c1
;>>mike 29/3/88 if x1<obedienceoffset then decideloop
;>>mike 29/3/88; only go up to obedienceoffset if there
;>>mike 29/3/88; are some orders waiting - otherwise obedient creatures
;>>mike 29/3/88; would become zombies when they had no orders to obey
;>>mike 29/3/88;
;>>mike 29/3/88 if x1<>obedienceoffset then decideloopnotobedience
;>>mike 29/3/88 if orderwaiting=0 then decideloopnotobedience ; nothing to do!
;>>mike 29/3/88 if cheatmode=false then decideloop ; see if obedient!
;>>mike 29/3/88 x2=255 ; completely obedient in cheat mode
;>>mike 29/3/88 goto decideloopalways
;>>mike 29/3/88
;>>mike 29/3/88.decideloopnotobedience
;>>mike 29/3/88; now x6 is item with biggest margin
;>>mike 29/3/88;; if x6=greedoffset then @doiwanttreasure
;>>mike 29/3/88;; if x6=aggressionoffset then @doiwantattack
;>>mike 29/3/88; if x6=timidityoffset then @runaway
;>>mike 29/3/88 if x6=obedienceoffset then eitherordersorfollow
;>>mike 29/3/88;
;>>mike 29/3/88.lTwoNoOrders
;>>mike 29/3/88 executeprocessed=false ; allow random things to happen
;>>mike 29/3/88;
;>>mike 29/3/88 return
;>>mike 29/3/88;---
;>>mike 29/3/88.eitherordersorfollow
;>>mike 29/3/88 if orderwaiting=ifollow then @doiwantfollow ;following, but no orders
;>>mike 29/3/88 goto @executeanyorders
;---
;;.npcanothermove
;;; do we want another attempt at moving? Decide randomly
;;; (this cuts execution time, and breaub @MerlinRescue
 if result=true then @GetFromUser

 MESSAGE 2241 ; you are dead. You scored
 GOSUB @SCORE
;
.RESTARTORRESTORE
 GOSUB @ABSCANCELINPUT
.ROR1
 MESSAGE 2209 ; type restart or restore
.ror2
 GOSUB DEADCALLVERB
 if value=nullvalue then ror2
; if get back here, option failed
 GOTO ROR1
;---
.DEADCALLVERB
 SUPRESSCHECKING=TRUE
 NOMOREINPUT=FALSE
 GOSUB @GETNEXTWORD
 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 dead=true
 if value=iramsave then @ramsave ; checks for ramload as well.ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööce in the dark says....
; gosub @printM2
; goto ns2
;
;.ns1
; verb=isay
; m1save=m1
; GOSUB @printACTORverb
; m1=space
; gosub @printM1
; m1=m1save
;
;.ns2
; gosub @printQUOTE
; gosub @printM1
; gosub @printQUOTE
; return
;
; print 'a male (female) voice in the distance shouts "something".'
; Or print the person shouting if nearby..
;;.varyactorshouts
;;gosub @getvarym1
;;
;;.actorshouts
;; if descriptionmode<>iverbose then asret
;; forceprinting=true ; even distant things are printed during 'shout'
;; m1save=m1
;; if room=currentuserroom then actorshoutshere
;; x1=actor
;; gosub @conjugatex1
;;; now result=pronoun offset for actor
;; m1=3736 ; start of 'a male voice shouts' type thing
;; add m1,result ; (0..7)
;; gosub @printM1
;; goto ash1
;;
;;.actorshoutshere
;; lastwordprinted=0 ; force printing name (*why is this needed)
;; verb=ishout
;; gosub @printACTORverb
;;
;;.ash1
;; message space
;; message quote
;; m1=m1save
;; gosub @printM1dot ; what actor shouts.öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö @yesorno
; if result=false then cassettechain
; save
; goto @chainparttochain ; allow multiple copies
;
;.cassettechain
; m1=2313 ; put in cassette containing part number
; message m1
; add m1,parttochain ; 2313+1,2,3 are names of games
; message m1
;
;.diskchain
;; chain in "PARTTOCHAIN"
; x1=200
; gosub waitpic ; kill any picture which is currently loading
; x1=11
; list9(0)=x1
; list9(1)=parttochain
;
;
;; Please leave this code in (commented out)...
;;
;;; pass data to part 2 in f x1=npcstackbase
 npcstack(x1)=c0 ; unlink demo pointer from chain 
 freespaceptr=2 ; number of current stack entry

; and set up pointers for npccurrent of the default
; actions for each npc
 ACTOR=1
.ins1
 gosub @setACTORATTRIBUTES
 x1=npcptroffset
 add x1,actorattributes
 npccurrent(x1)=c0 ; default to no action
 add ACTOR,c1
 if ACTOR<maxnpcplus1 then ins1
 goto @specialinitnpcs
;---
.MakeObjectASlave
 gosub MakeObjectObedient
 x1=followOffset
 add x1,x4
 npccurrent(x1)=c1 ; user
 return
;---
.makeobjectobedient
; make OBJECT obedient to USER
 gosub @setX4toOBJECTATTRIBUTES
 x1=masteroffset
 add x1,x4
 npccurrent(x1)=c1 ; user
 return
;---
.follow
; set up npccurrent(npc attributes + 1)= person to follow
;>>mike 28/3/88 if actor<>user then follownotuser
;>>mike 6/2/88 if noun1>maxpeople then @setupfind
;
;
;>>mike 28/3/88.follownotuser
;
 x1=followoffset
 add x1,ACTORATTRIBUTES
 npccurrent(x1)=noun1
;>>mike 28/3/88 gosub @doiwantfollownoun1 ;<<<gosub doiwantfollowöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööör to block of last command given

.initfifook
 commandstolink=freespaceptr ; pointer to first command given
 return
;---
.linkonfifocommandqueue
; link on the queue which has been built up.
; The first command to be executed is at COMMANDSTOLINK
; and the last is at lastunlinkedcommand
 gosub @setACTORATTRIBUTES ;* maybe avoids bugs?


 cif allowcheat
  if actor=initfifoactor then lifcq1
  if cheatmode=0 then lifcq1
  message cr ;*
  prs "[err1:" ;*
  print actor ;*
  prs "/" ;*
  print ööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööa complete fifo push, without the extra facility
; of being able to give multiple commands which
; are executed in the order they were given
 gosub @initfifo
 gosub npcpushfifo
 goto @linkonfifocommandqueue
;---
.npcpushfifo
; for npc ACTOR, add a new action to the end of its 'pending
; action' queue, such that it will be the last to be executed.
; i.e. FIFO
;
; find some free space
 if lastunlinkedcommand=0 then npffirstcommand
 x1=lastunlinkedcommand
 gosub npcgetoffset
 npcstack(x1)=freespaceptr ; link on new command
 if lastunlinkedcommand<highwater then npffirstcommand ;*
 highwater=lastunlinkedcommand ;*

.npffirstcommand
 lastunlinkedcommand=freespaceptr

; and push command in...
; and make freespace ptr crawl along its linked list
 x1=freespaceptr
 gosub npcgetoffset ; find npcstack offset in x1, from x1=number
; now x1=position in npcstack of free space
;
 x3=npcstack(x1) ; move along freespace chain
 if x3=0 then @npcpusherror ; no free space!
 freespaceptr=x3
; x1=oföööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö x1,x1
 add x1,x2
 x2=npcstackbase
 add x1,x2
 return
;---
.intelligentpop
; pop off current command. If it had a goal directed
; noun1, pop off both parts of it.
 gosub @npcgetcurrent
 x2=3 ; offset for noun1
 add x1,x2
 x2=npcstack(x1) ; x2=noun1
 if x2<mincollective then npcpop
 if x2>maxcollective then npcpop
 gosub npcpop
; drop through to npcpop for second part of gd command

.npcpop
; Only use this if you are sure you know what you are doing -
; normally use intelligentpop

; npc is to stop doing its current action, and climb to next
; on its chain. The top action (the default one) is never deleted
;
; return x3=0 if pop error occured
 gosub @npcgetcurrent
 x2=npcstack(x1) ; number of command to execute after this one
; and add this element as the current element in the free space chain
 x4=npcptroffset
 add x4,actorattributes
 x3=npccurrent(x4)
 if x3=0 then npcpoperror ; no current command on stack
 npccurrent(x4)=x2 ; make element above it current action for npc

 öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö
.stopfollowing
 gosub @setACTORATTRIBUTES
 x1=followoffset
 add x1,actorattributes
 npccurrent(x1)=c0 ; stop following
 return
;---
;---
.preactorcr
 if actor<>user then pacret
 message cr
.pacret
 return
;---
;-------
;---
.tracex1tosynth
; trace from room x1 back to the synthesised room number
; return x1=synth room number
; if any room=x6 on the way, return with processed=true
; and dir=direction of last move
; before we encountered x6
 processed=false
 if x1=x6 then txtsfound
 if x1>minsynthroomminus1 then txtsret

 cif AllowCheat
  if cheatMode<>2 then NotTXCheat
  print x1
  message space
.NotTXCheat
 cend

 gosub @getfloorpointer ; in x2 for room x1
 dir=list5(x2)
 from=x1
 gosub @checkexit ; exit x1 x3 x4 x5 ; room dir status dest
 if dest=0 then txtsret ; in for safety only
 x1=dest
 goto @tracex1tosynth
;---
.txtsfound
; have found a match with x6
; i.e. both source and dest for the move are in
; the same complex
 processed=true
.txtsret
 return
;---
 cif allowcheat

.debugshowstack ;*
  message cr
  prs "Command queues are: (return to stop, space to step if looping)"
  actor=1
.debugstack1
  message cr
  object=actor
  forceprinting=true
  gosub @printTHEobject
  message colon
  gosub @setACTORATTRIBUTES
  gosub @npcgetcurrent ; set up x1=position in npcstack
.debugstack2
; of current command
  x2=npcstack(x1) ; pointer to next
  add x1,c1
  verb=npcstack(x1)
  add x1,c1
  prep=npcstack(x1)
  add x1,c1
  noun1=npcstack(x1)
  addöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö m1
.dssnoverb
  prs "("
  print verb
  prs ") "
;
  if prep=0 then dssnoprep
  if verb>200 then dssnoprep
  m1=1600
  add m1,prep
  message m1
.dssnoprep
  prs "("
  print prep
  prs ") "

  if noun1=nullobject then dssnonoun1
  if noun1=0 then dssnonoun1
  if verb>200 then dssnonoun1
  m1=300
  add m1,noun1
  message m1
.dssnonoun1
  prs "("
  print noun1
  prs ") "

  if noun2=nullobject then dssnonoun2
  if noun2=0 then dssnonoun2
  if verb>200 then dssnonoun2
  m1=300
  add m1,noun2
  message m1
.dssnonoun2
  prs "("
  print noun2
  prs "), "
  return



 cend


;---
;---
;>>mike 28/3/88.gdkilldead
;>>Mike 28/3/88; object=noun1 here.
;>>Mike 28/3/88 commandfinished=true
;>>Mike 28/3/88 goto @printdead ; object is dead (gosub,return)
;---
;---
.kill
; initiate a goal-directed kill
 if actor<>user then gdkill
 if noun1=nullobject then @TVnoOBJECTerror ;>>mike 29/6/88
;>>mike 28/3/88 if noun1>maxNpc then @silly ;>>mike 6/2/88
;>>mike 28/3/88  object=nub @checkifpresent
 if result=true then gdwaitend ; it's arrived
 goto gdstillwaiting
;---
.gdwaitforperiod
; noun1 is period to wait for
; this command is always executed off the command queue
 if noun1=0 then @intelligentpop ; time up
; decrement period on stack
 gosub @npcgetcurrent
 add x1,c3 ; find noun1 offset
 x2=npcstack(x1)
 sub x2,c1
 if x2>negative then gdwaitend ; time up
 npcstack(x1)=x2
.gdstillwaiting
;>>L2 x1=attentionoffset
;>>L2 add x1,actorattributes
;>>l2 x1=npccurrent(x1)
;>>l2 if x1<>0 then @handleinterruption

;;.gdwfpret
 return
;---
;.gdwaituntiltime
;; this command is always executed from the command queue
; if noun1>hour then gdstillwaiting ; still waiting
; if noun2>minute then gdstillwaiting ; still waiting
; if actor<>user then gdwaitend
;; gosub displaytime
;; have reached target time
.gdwaitend
 executeprocessed=false ; nothing useful done
 goto @intelligentpop
;---
.SHORTWAIT
; wait for a single turn
 executeprocessed=true ; make it take time
 return ;>>gnome
;>>gnome M1=2155 ; time passes
;>>gnome goto @nointerestm1
;---
.YESORNO
 IF ACTOR<>USER THEN YONNO ; NPCs always decline to take risks
 NOMOREINPUT=FALSE
;
 SUPRESSCHECKING=TRUE
 GOSUB @GETNEXTWORD
.YON1
 IF EOL=TRUE THEN @YESORNO
 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 IF VALUE=ivYES THEN yonYES
 IF VALUE=iWHY THEN yonYES
 IF VALUE=ivNO THEN yonNO
 IF VALUE=iNORTH THEN yonNO

 SEARCHTYPE=VERBTYPE
 GOSUB @CHECKTYPE
 IF VALUE=iOOPS THEN @OOPS
 IF VALUE=iRAMLOAD THEöööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö>0 then @doiwantfollownoun1 ; at the moment, always chases enemy
; lose agression
 x1=EnemyOffset
 add x1,ActorAttributes
 npccurrent(x1)=c0
.aicret
.gdkillRet
 return
;---
;;.diwattackanyonenew
; is there anyone else (i.e. orc) here to attack?
; noun1=user
; object=noun1
; gosub @checkifpresent
; if result=false then @noattack
;; how aggressive is actor?
; random x1
;; x1=random 0..255
; x2=aggressionoffset
; add x2,actorattributes
; x2=npcinitial(x2)
;; x2=aggression %ge
;; x1=random 'feelings' - if between 0 and aggression, charge!
; if x1>x2 then @noattack ; not this time, thankyou
;; want attack
;; initiate an attack
; x4=actorattributes
; gosub @increasehatred ; make attacker hate (orc) a bit
; m1=3330 ; a player! lets kill it! and sim.
; gosub @varysayM1dot
; wanttoprintand=x1 ; we always attack player now, so this is safe
; goto definiteattack

.incombat
; either run away or attack
; x1=timidityoffset
; add x1,actorattributes
; x2=npcinitial(x1)
; random x1
; if x1<x2 then runaway
;;.definiteattack
 if noun1<>user then definiteattack1 ; no shout for attacking others
 random x1
 if x1>100 then definiteattack1
 if descriptionmode<>iverbose then definiteattack1
 wanttoprintand=actor

.definiteattack1
 verb=iattack
; ACTOR wants to attack NOUN1
 goto @callverb
;---
;;.runaway
;;; ACTOR is scared (Ahh..)
;; gosub @canactormove
;; if result=false then @crdret
;; gosub @canactorrandommove
;; if result=false then @crdret
;; gosub @chooserandomdirection
öööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööööö
;;;not needed if object>maxtreasure then gdfindtreasure1
;;; got some treasure!
;;; don't want it if it is carried by actor
;; pos=actor
;; hipos=nonspecific
;; gosub @checkobjectpos
;; if result=true then gdfindtreasure1
;;; got it, so return!
;; return
;;
;;.gdnotreasure
;; NoTreasureInRoom=true
;; return
;
;---
;----
;;.doiwantattack
; for npcs.
; does actor want to start attacking anyone?
; if so, return verb and noun1
; gosub @amiincombat
; if result=true then @defendmyself
; ranen.'
;; x1=actor
;; goto printM1theobjectx1NEXTdot
;;;
;;.printM1theobjectNEXTdot ; e.g 'The impact smashes the OBJECT into pieces.'
;; x1=object
;
.printM1theobjectx1NEXTdot ; e.g 'Unfortunately, the X1 is too high up.'
 gosub printM1
 gosub @printTHEobjectx1
 add m1,c1
 goto printM1dot
;---
; S