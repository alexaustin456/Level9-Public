; Lancelot 3 source, copyright (C) 1988 Level 9 Computing.
;
; AVERB.TXT, fairly standard code to handle ordinary verbs (there 
; is no point in writing code to handle movement; get/drop; examine
; etc. etc. afresh for each game.) You will need to make some changes, 
; adding new verbs and those special cases which can't go elsewhere, 
; and possibly removing verbs, e.g the combat routines if your game 
; is non-violent.
;
BEGIN
;
; Start of game, transferred here directly from APARSE. 
;
.normalSTARTGAME
;.INITALL
;; Because adventures typically consist of several programs, which can 
;; load each other by means of the 'chain' driver call, we can't just 
;; start by initialising everything in sight. If nothing else, this 
;; would destroy all the evidence as to whether the game had just been 
;; started, or whether the player had merely returned to this part in 
;; order to complete a puzzle. However, we must do some neccessary 
;; initialisation. Coping with this situation is very tricky indeed, 
;; and we advise you to keep your hands off. 
;; if thisgame<>GnomeRanger then notchained
;; if parttochain<>constantpartnum then notchained
;; if thispart=1 then notchained
;; must have loaded a saved pos which caused
;; this part to be chained in.
;; thispart=parttochain
;; message space
;; message cr
;; goto @afterrestore
;; 
;; .notchained
;; CLEAR ; clears all variables
;
 x1=0
 c1=1
.clearall
; some of the table cleared here is also cleared by initnpc
 currentpos(x1)=c0 ; must be done else OBJECTTRIGGER fails for OBJECT=0
 add x1,c1
 if x1<npctablesizetozero then clearall


 MESSAGE 2100 ; welcome to game
; initialise some variables which retain their values throughout
; the game
 thisgame=Lancelot
 thispart=constantpartnum
 C1=1
 C2=2
 C3=3
;; c6=6
;; c8=8
;; C10=10
;
 ITWORD=NULLOBJECT ; first object seen
 ITNUMBER=NULLNUMBER
 NOMOREINPUT=TRUE ; have come to end of input line
;; CARRYCAPACITY=NORMALCAPACITY
 GOSUB @INITOBJECTS
;; >>> gosub randomizetreasure
 gosub @initnpcs
 HOUR=10
 day=1
 minute=20
 SOMETHINGPROCESSED=TRUE ; force printing of WHAT NEXT ?
 NORMALDESCRIPTIONMODE=IVERBOSE
 AutoExits=ivoff ; default to exits off
 OOPSPOS=1
;; vandalptr=vandalbase
;
 gosub @initlocations

; now set up variables as pointers to starts
; within segmented lists
 value=list5(0)
 gosub @valuetimes256
 x1=list5(1)
 add value,x1
 startfloorpointers=value

 value=list5(2)
 gosub @valuetimes256
 x1=list5(3)
 add value,x1
 startracetracks=va0 ; room number
.InitDone1
 list7(x1)=x2
 if x1>VisitTableEnd then InitDone2
 add x1,c1
 add x2,c1
 goto InitDone1

.InitDone2
;; clear from VisitTable to VisitTableEnd
;; x1=MeetingTable
;; .InitMeeting1
;; list7(x1)=c0
;; add x1,c1
;; if x1<MeetingTableEnd then InitMeeting1

 gosub @CalcScore


 actor=user
 gosub @setuproom

 object=bors
 gosub @makeobjectobedient

 object=Percival
 gosub @makeobjectobedient

 CurrentRank=2800 ; "Sir"
;; initialscene=1
cif IncludePictures ;>>0 ; room number
.InitDone1
 list7(x1)=x2
 if x1>VisitTableEnd then InitDone2
 add x1,c1
 add x2,c1
 goto InitDone1

.InitDone2
;; clear from VisitTable to VisitTableEnd
;; x1=MeetingTable
;; .InitMeeting1
;; list7(x1)=c0
;; add x1,c1
;; if x1<MeetingTableEnd then InitMeeting1

 gosub @CalcScore


 actor=user
 gosub @setuproom

 object=bors
 gosub @makeobjectobedient

 object=Percival
 gosub @makeobjectobedient

 CurrentRank=2800 ; "Sir"
;; initialscene=1
cif IncludePictures ;>>mike 6-9-88
 x1=1
 gosub @drawpicturex1
cend
; 
;; if P1Score>0 then NoInitialInit ;              >> PETE 13/7/88
;; solved P1/P2
;; check if player really wants to play this part;>> PETE 13/7/88
;; message 2499 ; really want the grail quest?;   >> PETE 13/7/88
;; gosub @YesOrNo ;                               >> PETE 13/7/88
;; if result=true then noInitialInit ;            >> PETE 13/7/88
;; thispart=0 ;                                   >> PETE 13/7/88
;; partToChain=1 ;                                >> PETE 13/7/88 
;; gosub ChainPartToChain ;                       >> PETE 13/7/88 
;
.noInitialInit
 message 2500 ; intro
 message dot
 message BlankLine
 gosub @PrintRoom
 gosub @PrintVisitMessage
 GOTO @CANCELINPUT
;---
.unfasten
 m1=2603 ; tied+gagged
 if noun1=galahad then @PrintM1Dot

.unfastentake
 verb=itake

.GET
.TAKE
; Check for prepositions e.g. GET ON, GET OFF
 IF PREP<>0 THEN TAKEFROM
.TAKEIT
 POS=ACTOR
 HIPOS=CARRIED
 GOTO @MOVEOBJECT
;
.TAKEFROM
; got a preposition e.g. TAKE noun FROM ; or TAKE noun IN etc.
 OBJECT=NOUN1
 POS=NOUN2
 HIPOS=NONSPECIFIC
 GOSUB @CHECKOBJECTPOS
; OBJECT=NOUN1 here
 IF RESULT=FALSE THEN @ITSNOTTHERE
 GOTO TAKEIT
;---

.SIT
.STAND
 lastpossibleverb=0 ; prevent prep being parsed as a verb
 nextverb=0
 IF PREP=ON THEN STANDON
 IF PREP=OFF THEN STANDOFF
 IF PREP=UP THEN STANDUP
 IF PREP=IPIN THEN STANDIN
 IF PREP=IPOUT THEN STANDOUT
; now fix a bug - "get in" or "get out" don't parse the prep
 if prep<>0 then @DontUnderstand
 x1=hicurrentpos(actor)
 prep=ipin
 if x1=0 then standOn ; try getting into a container
 prep=ipout
; GOTO @DONTUNDERSTAND
;---
.STANDOFF
.STANDOUT ; get out (e.g. of boat)
.STANDUP
 X1=HICURRENTPOS(ACTOR)
 IF X1=0 THEN @SILLY

 if room<MinSynthRoom then standOutOk
 if room=123 then standOutOk
 if room=127 then standOutOk
 if room=130 then standOutOk
 m1=2570 ; would have got wet
 if room<>115 then @ActorM1Dot

.standOutOk
 currentpos(actor)=ROOM
 hicurrentpos(actor)=c0
.ReportStand
 noun1=nullobject
 noun2=nullobject
; print "L got out" etc.
;; commandfinished=true ; otherwise, npc's give up (dunno why!)
 executeProcessed=true 
 fatalerror=false
 gosub @PrintActorVerb ;>> goto @done
 m1=PrepOffset
 add m1,Prep
 goto @PrintM1Dot
;
;---
.BOARD ; e.g. boat
.STANDON
.STANDIN
 object=noun1
 if object=boat then standOk
 object=noun2
 if object=boat then standOk
; is the boat here?
 object=boat
 gosub @CheckIfPresent
 if result=true then standOk
 if room=51 then @LieSilly ; "GO CAKES" tries to get into the
; silver plate, and is interpreted as trying to lie with the damosel

;; HIDEST=PREP ; ON, IN ETC.
;; GOTO silly
;---
.LIE
; HIDEST=LIEON
 if noun2=damosel then LieLoveDamosel
 if room=51 then LieLoveDamosel ; e.g. "lie with damosel, lie down"
.LieSilly
 object=noun2
 GOTO @silly

.LieLoveDamosel
 if actor<>user then standOk
 object=damosel
 gosub @checkifpresent
 if result=false then @Silly
 gosub @LoveDamosel
 goto @CancelInput ; kill down from "lie down"
;---
.STANDOK
;; gnome3 gosub @printACTORactiondot
 PROCESSED=TRUE
 HIDEST=PREP
 DEST=OBJECT
 gosub ReportStand
 GOTO @NEWLOCATION
;---
.AttackActorM1Dot
 CommandFinished=true
 goto @ActorM1dot
;---
.ATTACK
 executeProcessed=true ;>>mike 28/3/88
;; >>mike 28/3/88 commandfinished=true ; always terminates in gnome
;; if noun1=iroom then @vandal
.AttackNotDoor

; can't attack women
 x1=noun1
 gosub @Conjugatex1
 m1=2498 ; could not possibly attack a woman
 if result=she then AttackActorM1Dot
 if result=ProperFemale then AttackActorM1Dot

 m1=2607 ; could not cut the bonds
 if noun1=stake then @ActorM1Dot ; couldn't cut bonds

 if noun1<>lions then AttackNotLions
 x1=v1 ; lack of faith
 gosub @Addsin
 m1=2665 ; lack of faith!
 goto CFM1Dot

.AttackNotLions
 target=noun1
 if noun1>maxnpc then atnpc ; assumes nullobject=255
 if noun1<>WoodlandKnight then atNotGreenKnight
 m1=2589 ; but the green knight spared L!
 if NameGiven=2 then CFM1Dot

.atNotGreBLOW
;; 
.ATNPC
;; if noun1<minsceneryobj then atnsceneryobject
;; if noun1<maxsceneryobjplus1 then @vandal
;; 
;; .atnsceneryobject
.collect
.become
.WAKE
.WASTEOFTIME
 IF ACTOR<>USER THEN @NPCNOTUNDERSTOOD
 M1=3160 ; don't bother group
 GOTO @VARYMESSAGEDOT
;---
.PUT
 IF NOUN1=NULLOBJECT THEN @CANTSEEWHAT
 IF NOUN2=NULLOBJECT THEN @CANTSEEWHERE
 OBJECT=NOUN1

 IF PREP=ON THEN PUTON
 IF PREP=UNDER THEN PUTUNDER
 IF PREP=IN THEN PUTIN
 if prep=through then putin

.CANTPUTTHERE
;; iBLOW
;; 
.ATNPC
;; if noun1<minsceneryobj then atnsceneryobject
;; if noun1<maxsceneryobjplus1 then @vandal
;; 
;; .atnsceneryobject
.collect
.become
.WAKE
.WASTEOFTIME
 IF ACTOR<>USER THEN @NPCNOTUNDERSTOOD
 M1=3160 ; don't bother group
 GOTO @VARYMESSAGEDOT
;---
.PUT
 IF NOUN1=NULLOBJECT THEN @CANTSEEWHAT
 IF NOUN2=NULLOBJECT THEN @CANTSEEWHERE
 OBJECT=NOUN1

 IF PREP=ON THEN PUTON
 IF PREP=UNDER THEN PUTUNDER
 IF PREP=IN THEN PUTIN
 if prep=through then putin

.CANTPUTTHERE
;; if actor<>user then cptret
 gosub @actorcantverbnoun1 ; can't put that
 m1=2124              ; there
 goto @printM1dot
;---
.PUTON
; CHECK IF DESTINATION CAN HAVE things put on top of it
 goto cantputthere
;
.PUTOK
 OBJECT=NOUN1
 GOTO MOVEOBJECTPrepNoun2

.PUTIN
 if noun2=boat then putok
.objectwontfit
 GOTO CANTPUTTHERE

.putunder
 goto cantputthere
;---
.ISOBJECTMOVEABLE
; return RESULT=TRUE if OBJECT can be moved
 if object>maxmoveable then @returnfalse
 if object<maxNpcPlus1 then @returnfalse
.iomtrue
 result=TRUE
.IOMRET
.cptret
 RETURN
;---
.MoveObjectPrepNoun2
 pos=Noun2
 hipos=Prep

; Super routine for moving objects about. E.g, putting something inside 
; a bag. Or removing it. It differs from "NEWLOCATION", which is concerned 
; with walking-about-type-movement, primarily in the way that the action 
; is reported. MOVEOBJECT validates the movement before carrying it out.
.MOVEOBJECT
; Move 'OBJECT' to 'POS', 'HIPOS'
; Return RESULT=TRUE if move was successful
 GOSUB ISOBJECTMOVEABLE
 IF RESULT=FALSE THEN @IMMOVABLE
; is the contents already contained by the container (or V-V) ?
 GOSUB @CHECKIFCONTAINED
;
 IF HIPOS=0 THEN MONOTACTOR
; ACTOR to gain this object, check if is able to carry it
; actually this code is now used whenever an object
; goes to a position not on the ground. This
; is to catch people trying to avoid SPECIALTAKES
 IF HIPOS<>WORN THEN MOVEOBJ1
; is it wearable ?
 IF OBJECT<minclothes THEN @cantwear
 if object>maxclothes then @cantwear

.MOVEOBJ1
; Now check if the ACTOR is standing on it or some similar problem
 OBJECTSAVE=OBJECT
 DEST=POS ; save value
 HIDEST=HIPOS ; save it
;
 POS=OBJECT
 HIPOS=NONSPECIFIC
 OBJECT=ACTOR
 GOSUB @CHECKOBJECTPOS
;
 OBJECT=OBJECTSAVE
 POS=DEST ; restore value
 HIPOS=HIDEST ; restore value
 IF RESULT=TRUE THEN @MOVEOBJFAIL
 GOSUB @SPECIALTAKES ; game-specific take messages
 IF RESULT=FALSE THEN @MOVEOBJRET
;
.MONOTACTOR
 X1=CURRENTPOS(OBJECT)
 IF X1<>ACTOR THEN MMNOTLOSE
 X1=HICURRENTPOS(OBJECT)
 IF X1=0 THEN MMNOTLOSE
; ACTOR is to lose object
 IF X1<>WORN THEN MMLOSENOTWORN
; ACTOR is wearing object, if it was specified using EVERYTHING,
; then don't drop it as this could cause embarrasment
 IF noun1isgd=FALSE THEN MMLOSENOTWORN
 if verb=iremove then mmlosenotworn
 RESULT=FALSE
 if actor<>user then @npcnotunderstood
 M1=2134 ; you're wearing
 gosub @printM1
 gosub @printTHEobject
 goto @printDOT

.MMLOSENOTWORN
 GOSUB @SPECIALDROPS
 IF RESULT=FALSE THEN MOVEOBJRET

.MMNOTLOSE
 IF HIPOS=0 THEN MMNL1
 IF POS=OBJECT THEN @CANTPUTTHERE
.MMNL1
; any other special cases ?
;
; is it going to a NPC ?
 if actor=pos then montonpc ; ok for people to take things
 IF HIPOS=0 THEN MONTONPC
 IF POS<minnpc THEN MONTONPC
 IF POS>MAXNPC THEN MONTONPC
; code here is to avoid NPCs having things put on them etc.
; or the statue / bloodworm / bat being given things
; no special cases for giving to NPC, so make it carry it
 IF HIPOS=WORN THEN MONTONPC ; unless it is going to wear it
 HIPOS=CARRIED

.MONTONPC

 FROM=CURRENTPOS(OBJECT)
 HIFROM=HICURRENTPOS(OBJECT)
 CURRENTPOS(OBJECT)=POS
 HICURRENTPOS(OBJECT)=HIPOS
;
; now decribe the move
;
; show ACTOR doing something
; verb is set up
 if verb=ithrow then monodesc
 objectsave=object
 gosub @printACTORactiondot
 object=objectsave

.monodesc
 gosub @specialaftermoveobj
 goto @returnTRUE ; move went just fine!

.MOVEOBJFAIL
 M1=2131 ;  you're on it
 gosub @errorm1

.MOPREVENT
 RESULT=FALSE
.moveobjret
 RETURN
;; ---
;; .SCORE
;; MESSAGE 2240 ; you score
;; 
;; .PRINTSCORE
;; 
;; IF X4<30000 THEN SCORE1 ; failsafe test to prevent negative score
;; X4=0
;; .SCORE1
;; PRINT X4 ; score
;; M1=2249 ; message below lowest rating
;; X1=100 ; size of score categories (max score, 1000, has unique rating)
;; .SCORE2
;; SUB X4,X1
;; ADD M1,C1
;; IF X4<NEGATIVE THEN SCORE2
;; MESSAGE 2242 ; out of 1000 and are a 
;; goto @printM1dot ; rating
;; ---
.POSITIONSHADOWS
; Make objects follow thepear on moving through doors etc.
; GOSUB SETUPROOM
 FROM=ROOM
 HaveSavedOops=false
 GOSUB @SPECIALMOVES

 cif AllowCheat
  if CheatMode=4 then NewMoveNotUser
 cend

 blockedbysm=TRUE
 IF RESULT=FALSE THEN @NLRET
 if actor<>user then NewMoveNotUser
 if HaveSavedOops=true then NewMoveNotuser ;>>mike 23/8/88
 gosub @saveOops

.NewMoveNotUser
 blockedbysm=FALSE
;
.ABSNEWLOCATION
; as for newlocation, but don't do any checking for special
; case code. Use this routine where the move is forcpear on moving through doors etc.
; GOSUB SETUPROOM
 FROM=ROOM
 HaveSavedOops=false
 GOSUB @SPECIALMOVES

 cif AllowCheat
  if CheatMode=4 then NewMoveNotUser
 cend

 blockedbysm=TRUE
 IF RESULT=FALSE THEN @NLRET
 if actor<>user then NewMoveNotUser
 if HaveSavedOops=true then NewMoveNotuser ;>>mike 23/8/88
 gosub @saveOops

.NewMoveNotUser
 blockedbysm=FALSE
;
.ABSNEWLOCATION
; as for newlocation, but don't do any checking for special
; case code. Use this routine where the move is forced, so
; don't want to trip any movement traps
 executeProcessed=true
 if dest=0 then @nlret ;>>mike 8/1/88
 FROM=ROOM
; describe door closing (if there is one)
 if dest=boat then anl2a ;>>special to Lancelot - only affects TO BOAT
 IF HIDEST<>0 THEN ANL2 ; skip checks for moving into container
 GOSUB @CHECKEXIT

.anl2a
 gosub @printleaving
;
.ANL2
 LASTROOM=ROOM
 CURRENTPOS(ACTOR)=DEST
 HICURRENTPOS(ACTOR)=HIDEST
 gosub @closedoor
 roomsave=ROOM
 gosub @setuproom
 gosub @printarrival
; no messages printed between printarrival and printroom please
.NLEND
 x1=hicurrentpos(user) ;>>special to Lancelot3/boat
 if x1=0 then NLEND1
 x2=hicurrentpos(actor)
 if x1<>x2 then NLEND1 ;>>special to Lancelot3/boat
 x1=currentpos(user) ;>>special to Lancelot3/boat
 if x1<>boat then NLEND1
 x2=currentpos(actor)
 if x1<>x2 then NLEND1 ;>>special to Lancelot3/boat
 actorsave=actor ;>>special to Lancelot3/boat
 actor=user ;>>special to Lancelot3/boat
 gosub @SetUpRoom ;>>special to Lancelot3/boat
 gosub @PrintRoom ;>>special to Lancelot3/boat
 actor=actorsave ;>>special to Lancelot3/boat
 goto @aftermove ;>>special to Lancelot3/boat

.NLEND1
 IF ACTOR<>user THEN @AFTERMOVE ; npc doesn't want description
.NLENDPrint
 timeinroom=0
 GOSUB @printROOM
; for user only, print any messages due on first visit
 gosub @PrintVisitMessage
 goto @AfterMove
;---
.PrintVisitMessage
 x1=VisitTableStart
 add x1,Room
 if x1>VisitTableEnd then PVMRet
 x2=List7(x1)
 if x2=0 then NoVisitTableMessage
 list7(x1)=c0 ; prevent printing it again
 x1=1400 ; base for initial visit
 add x1,x2
 gosub SpecialVisitMessage
 message x1
.NoVisitTableMessage
.PVMRet
 return
;---
.SpecialVisitMessage
; about to print message x1
; zero x1 if you don't want to!
 if x1<>1436 then SVMNotSeeRescue
 TimeSinceRescueSeen=1

.SVMNotSeeRescue
 if x1<>1441 then SVMNotMaid
; rescuing maid?
 m1=2612 ; too late for maid
 if TimeSinceRescueSeen>10 then SVMTooLate
 if EctorRescued=true then SVMTooLate
 MaidRescued=true
 x1=scGentlewoman
 gosub @AddScore20
 x1=1441 ; restore x1
 TimeSinceRescueSeen=0 ; prevent her screaming

.SVMNotMaid
 if x1<>1440 then SVMNotEctor
 EctorRescued=true
 m1=2613 ; too late for ector
 if TimeSinceRescueSeen>10 then SVMTooLate
 x1=scEctor
 gosub @AddScore20
 x1=1440 ; restore x1

.SVMNotEctor
 return

.SVMTooLate
 x1=v5 ; fortitude
 gosub @AddSin

 x1=100
 sub GeneralScoreAddition,x1 ; lose points for killing maid
 x1=0 ; don't print normal message
 goto @PrintM1Dot
;---
.printLEAVING
 if verb>15 then NLRet
 verbsave=verb
 if descriptionmode=inone then @dlret
 verb=2521 ; 2571-50 - paddled the boat to the
 x1=hicurrentpos(actor)
 if x1=0 then PLNotInBoat
 x1=currentpos(actor)
 if x1=boat then dl1

.PLNotInBoat
 verb=2461 ; 2511-VerbOffset = "rode" ;>>special to Lancelot
 if actor>MaxMounted then NotOutside
 if from>60 then FromOutside
 if from>49 then NotOutside
.FromOutside
 if dest>60 then dl1
 if dest<50 then dl1
; from outside to inside...
 verb=2463 ; 2513-VerbOffset = "dismounted and went" ; >>special to Lancelot
 goto dl1

.NotOutside
 verb=istruggle
 if dir=iclimb then dl1
 verb=58 ; go

.dl1
; gosub @isactorflying
; if result=false then dl2
; verb=163 ; flew
;
;.dl2
 gosub @printACTORverb ; the npc goes
.printdirectionanddoor
 m1=verboffset ; north-1
 add m1,dir
 gosub @printM1 ; direction
 gosub printdoor

 if actor>MaxMounted then NotMounting
 if dest>60 then ToOutside
 if dest>49 then NotMounting
.ToOutside
 if from>60 then NotMounting
 if from<50 then NotMounting
; from outside to inside...
 m1=2512 ; "and mounted" ; >>special to Lancelot
 gosub @printm1

.NotMounting
 verb=verbsave

 if actor<>user then @printDOT ; print a dot and terminate
 wanttoprintand=user ; followed immediately by description
.desclret
.nlret
 return
;---
.printdoor
 IF DOOR=FALSE THEN DESCLret
 M1=2115 ; through the door
 goto @printM1
;---
.printARRIVAL
; first print description of object
 if descriptionmode=ino
;---
.TICKCLOCK
; add on time a minute at a time
.TCADDMINUTES
 GOSUB @TIMEDEPENDENTCODE
 add timeinroom,c1
.TCRET
.waitret
.OPENDOORRET
.SAYRET
.OPENRET
.throwret
.abnret
.pushret
 RETURN
;---
.pull ; really push in gnome3
.PUSH
 goto @immovable
;---
.OPEN
 if noun1<>generalDoor then OpenNotDoor
 IF DOOROPEN=TRUE THEN ALREADYOPEN
.opendoor
 if room<>56 then openNotChapel
 object=key
 gosub @IsObjectCarried
 m1=2664 ; didn't have the key
 if result=false then @PrintM1Dot
 Chape
;---
.TICKCLOCK
; add on time a minute at a time
.TCADDMINUTES
 GOSUB @TIMEDEPENDENTCODE
 add timeinroom,c1
.TCRET
.waitret
.OPENDOORRET
.SAYRET
.OPENRET
.throwret
.abnret
.pushret
 RETURN
;---
.pull ; really push in gnome3
.PUSH
 goto @immovable
;---
.OPEN
 if noun1<>generalDoor then OpenNotDoor
 IF DOOROPEN=TRUE THEN ALREADYOPEN
.opendoor
 if room<>56 then openNotChapel
 object=key
 gosub @IsObjectCarried
 m1=2664 ; didn't have the key
 if result=false then @PrintM1Dot
 ChapelUnlocked=true
 x1=scExit
 gosub @AddScore20

.openNotChapel
 DOOROPEN=TRUE
 goto @printACTORactiondot

.OpenNotDoor
 if noun1<>tomb then OpenNotTomb
 if TombOpen=True then AlreadyOpen
 gosub @PrintActorActionDot
 TombOpen=true
 target=FoulFiend
 gosub @MakeEnemies ; make the opener and fiend enemies
 currentpos(FoulFiend)=room
 m1=2581 ; a foul fiend emerged!
 goto @printM1Dot

.OpenNotTomb
.DONTNEEDTODOTHAT
 m1=2148 ; you don't need to do that
 goto @errorM1dot
;---
.ALREADYOPEN
 M1=2117 ; already open
 GOTO @errorM1dot
;---
.GIVE
 if room<>37 then giveNotPilgrim
 if noun2<>nullobject then giveNotPilgrim
 noun2=pilgrim

.giveNotPilgrim
 HIPOS=CARRIED
 IF NOUN2=USER THEN GIVENPC
 IF NOUN2<minnpc THEN NOBODYWANTSIT
 IF NOUN2<maxnpcplus1 THEN GIVENPC
 goto nobodywantsit
;; IF NOUN2<>NULLOBJECT THEN NOBODYWANTSIT
;; GOSUB @ANYBODYHERE
;; IF OBJECT=NULLOBJECT THEN NOBODYWANTSIT
;; NOUN2=OBJECT
;; GOTO GIVENPC
;---
.NOBODYWANTSIT
 M1=2141 ; nobody wants it
 GOTO @ERRORM1dot
;---
.GIVENPC
; giving NOUN1 to NPC NOUN2
 IF NOUN2=NULLOBJECT THEN NOBODYWANTSIT
 OBJECT=NOUN1
 pos=noun2
 GOSUB @MOVEOBJECT
 goto @specialaftergive
;---
.THROW
 if room<>130 then throwNotForceFire
 noun2=fire
.throwNotForceFire
 if room<>56 then throwNotForceElemental
 noun2=elemental
.throwNotForceElemental

 if noun2=nullobject then @drop

 if noun2=elemental then ThrowElemental
 if noun2<>fire then throwNotFire
.ThrowElemental
; hipos is zero, unfortunately
; put out fire?
 if object<100 then throwNotChalice
 if object>104 then throwNotChalice
 gosub @EmptyChalice
 if noun2=fire then @HelpExtinguishFire
 goto ThrowAtElemental

.throwNotChalice
 if object<105 then throwNotCup
 if object>109 then throwNotCup
 gosub @EmptyCup
 if noun2=fire then @HelpExtinguishFire

.ThrowAtElemental
; what was thrown?
; OBJECT=100/105,101/106,102/107,103/107 if water, salt water, mead, sand
 m1=2656 ; efffect of throwing sand at the various elementals...
 if object=103 then TAE1
 if object=108 then TAE1
 m1=2653 ; effects of throwing liquids at the various elementals...
.TAE1
 add m1,CurrentElemental
 m1save=m1
 gosub @PrintM1Dot
 if CurrentElemental<>0 then TAENotFire
 if m1save<>2653 then TAENotFire ; liquids only harm fire elemental
.DestroyElemental
; not used for sand elemental
 add CurrentElemental,c1
 m1=2650
 add m1,CurrentElemental
 goto @PrintM1Dot ; print " A xxx elemental appeared"

.TAENotFire
 if CurrentElemental<>1 then TAENotWater ; water elemental
 if m1save=2657 then DestroyElemental

.TAENotWater
.TAERet
 return

.throwNotCup
.throwNotFire

; drop the object...
 pos=room
 hipos=0
 gosub @moveobject
 if result=FALSE then @throwret ; not possible
;; if noun2<minnpc then thrownotnpc
;; if noun2>maxnpc then thrownotnpc
;; throw something at someone - so treat as aggressive
;; object=noun1 here
;; gosub ithits ; print what happens
;; blowstrength=1
;; target=noun2
;; gosub makeenemies
;; goto dodamage
;; 
;; .thrownotnpc
;; drop through to ithits



.ithits
 verb=ihit
;; object=noun1
 gosub @printOBJECTverb ; prints 'the object hits'
 object=noun2
 gosub @printTHEobject2 ; print out him etc.
 goto @printdot
;---
.CHECKIFLIGHT
; Return RESULT=TRUE if room is illuminated
; (either naturally or by objects etc.)
 goto @returntrue
;---
.BRIEF
.VERBOSE
 NORMALDESCRIPTIONMODE=VERB
 GOTO @DONE
;---
.immovable
 if actor<>user then @actorcantverbnoun1dot
 gosub @printTheObject
 m1=3150 ; won't move
 goto @varyERRORM1dot
;
.cut
 m1=2607 ; could not cut the bonds
 if noun1=stake then @ActorM1Dot ; couldn't cut bonds

.squeeze
.badobject
.cantwear
 goto @actorcantverbnoun1dot
;---
.initlocations
; go through and place the special locations in
; appropriate pseudo-random locations..
.drret
 return
;-----------------------------
.shortdesc ; print the short description for ROOM
;; if room<minsynthroomminus1 then descstaticroom
;; gosub @convertroom ; is there a special feature here?
;; if x1=0 th=shortroomdescs
 add x1,room
 message x1
 return
;---
.printROOM
;; picturetodraw=0
 LASTWORDPRINTED=0 ; prevent printing of 'it'
 GOSUB @POSITIONSHADOWS
 if room=DestToDescribeExitsIn then dr1
 if descriptionmode=inone then drret
;
.dr1
 if actor<>user then drret ; never any description for npcs
 GOSUB @CHECKIFLIGHT
 IF RESULT=TRUE THEN DESCROOM1
 if wanttoprintand=FALSE then dr2
 wanttoprintand=FALSE
 message dot ; not linked to previous message
;
.dr2
 MESSAGE 2108 ; It's dark
 LAST=shortroomdescs
 add x1,room
 message x1
 return
;---
.printROOM
;; picturetodraw=0
 LASTWORDPRINTED=0 ; prevent printing of 'it'
 GOSUB @POSITIONSHADOWS
 if room=DestToDescribeExitsIn then dr1
 if descriptionmode=inone then drret
;
.dr1
 if actor<>user then drret ; never any description for npcs
 GOSUB @CHECKIFLIGHT
 IF RESULT=TRUE THEN DESCROOM1
 if wanttoprintand=FALSE then dr2
 wanttoprintand=FALSE
 message dot ; not linked to previous message
;
.dr2
 MESSAGE 2108 ; It's dark
 LASTPICTURE=0
 CLS G ; clear graphics window
 RETURN
;---
.DESCROOM1
 GOSUB @SPECIALactor ; print 'You are..'
 GOSUB @SETUPROOM
;
.ABSDESCROOM
 gosub shortdesc
;
.descroomremainder
 IF DESCRIPTIONMODE<>IBRIEF THEN DESCROOM3A
 if room=DestToDescribeExitsIn then descroom3a ; full desc of destinat
 message dot
 if normalDescriptionMode<>ibrief then descroom3e
 GOTO DESCROOM3C
;
.DESCROOM3A
 X1=LONGROOMDESCS
 ADD X1,ROOM
 MESSAGE X1
.DESCROOM3
 MESSAGE DOT
; gosub @specialdescbeforeexits
; if OnRiver=True then descroom3c
 if AutoExits=ivoff then descroom3c
 GOSUB @PRINTEXITS
;
.DESCROOM3C
 gosub showpicture ; start selected picture drawing.

.descroom3e
 SEARCHPOS=ROOM
 HISEARCHPOS=0
 GOto @PRINTOBJECTS

;; >>mike 8/2/88 GOSUB @DESCactor
;; GOTO @SPECIALDESC
;; ---
.showpicture
;; displaypicture for room PICTURETODRAW
;; this is either a static room number 2..25
;; or a scenery object number 180..200
;; or 255=forest
cif IncludePictures ;>>mike 6-9-88

 x1=2 ; path through forest
 if room=8 then sdrawpicturex1
 x1=3 ; path up to nacien's hermitage
;>>mike 23/8/88 if room=39 then sdrawpicturex1
 if room<29 then sdNotNacienPath
 if room<34 then sdrawpicturex1

.sdNotNacienPath
;; x1=6 ; stone-walled corridor
 x1=7 ; stone-walled room
 if room=56 then sdrawpicturex1 ; antechapel near grail
 if room=50 then sdrawpicturex1 ; vagon castle at start
 x1=18 ; pavillion
 if room=5 then sdrawpicturex1
 x1=19 ; chapel at end of road
 if room=13 then sdrawpicturex1 ; church near start
 if room=38 then sdrawpicturex1 ; white abbey
 x1=21 ; stone cross in the wasteland
 if room=9 then sdrawpicturex1 ; cross near start
 if room=34 then sdrawpicturex1 ; cross in wasteland
 x1=22 ; spring and pool
 if room=41 then sdrawpicturex1 ; maid glade
 if room=40 then sdrawpicturex1 ; ector glade
 x2=currentpos(boat)
 if x2<>room then PictureNotBoat
 x1=24 ; magic boat
 x2=currentpos(user)
 if x2<>boat then sdrawpicturex1
 x1=25 ; view of sea from boat
 goto sdrawpicturex1

.PictureNotBoat
 x1=27  ; light of holy grail shining through door
 if room=54 then sdrawpicturex1
 x1=29 ; holy grail at end
 if room=55 then sdrawpicturex1
cend ; pictures
 return

.sdrawpicturex1
 goto @Drawpicturex1
;---
.CHECKEXIT
 ceroomsave=room
 room=from
 GOSUB ABSCHECKEXIT
 room=ceroomsave
 GOTO @SPECIALEXITS ; Exits conditional on game
;---
.ABSCHECKEXIT
; EXIT ( From FROM diection DIR )
; return DEST, DOOR, EXITVISIBLE
 door=FALSE
 dest=0
 exitvisible=FALSE
 if room<minsynthroomminus1 then fixedexit
;
; is there a fixed exit here? if so, it will override
; any synthesised exits that might otherwise operate
 gosub @convertroom
; now x1=1..25 if any scenery object is here
 if x1=0 then acesynthesised
 x2=minsceneryobjminus1
 add x1,x2
 EXIT x1 DIR STATUS DEST
 if dest>1 then checkexitstatus ; do rest of fixed exit code
; room 1 gives modifiers for synth rooms.
;
.acesynthesised
; ++++ please note: must have done gosub getXY BEFORE calling
 if dir=8 then acenorth
 if dir>2 then acenotnorth
.acenorth
 if y=ymax then acenoexit
.acenotnorth
 if dir=2 then aceeast
 if dir=3 then aceeast
 if dir<>5 then acenoteast
.aceeast
 if x=xmax then acenoexit
.acenoteast
 if dir=6 then acesouth
 if dir=5 then acesouth
 if dir<>4 then acenotsouth
.acesouth
 if y=0 then acenoexit
.acenotsouth
 if dir<6 then acenotwest
 if dir>8 then acenotwest
 if x=0 then acenoexit
.acenotwest
; look at the exit from room 1 to get the destination modifier
 x1=1
 exit x1 dir status dest
 if dest=0 then acenoexit
 add dest,from
 x1=dest
 x2=256
 gosub @x1modx2
 dest=x1
 exitvisible=TRUE
 return
;
.acenoexit
 dest=0
 return
;
.fixedexit ; See if there any fixed exits from here.
 DOOR=FALSE
 EXITVISIBLE=FALSE
 EXIT ROOM DIR STATUS DEST
 if dest=1 then ceret ; room 1 is used to give
; move modifiers for synthesised rooms.
 IF DEST=0 THEN CERET
 if dest<minsceneryobj then checkexitstatus
; find room which scenery object DEST is in - becomes destination room
;---
.parserun
; verb=isetuprun here
 againverb=isetuprun
 goto parsego1
;
.parsego
 againverb=isetupgo
; verb=isetupgo here
.parsego1
; return noun1 as room number of destination
 noun1=nullobject
; treetype=0
; terraintype=0
.gad1
 adjective1=nullobject
 adjective2=nullobject
 treatasfind=FALSE
 gosub getpart
 if gperror=TRUE then baddestination
 if treatasfind=TRUE then parsefindvalue
 if verb=0 then gadnotmove
 if verb<maxdirectionplus1 then gadend ; exit tidily for 'GO EAST'
.ga
;---
.parserun
; verb=isetuprun here
 againverb=isetuprun
 goto parsego1
;
.parsego
 againverb=isetupgo
; verb=isetupgo here
.parsego1
; return noun1 as room number of destination
 noun1=nullobject
; treetype=0
; terraintype=0
.gad1
 adjective1=nullobject
 adjective2=nullobject
 treatasfind=FALSE
 gosub getpart
 if gperror=TRUE then baddestination
 if treatasfind=TRUE then parsefindvalue
 if verb=0 then gadnotmove
 if verb<maxdirectionplus1 then gadend ; exit tidily for 'GO EAST'
.gadnotmove
 if noun1<>nullobject then gadend ; exit tidily for 'go interesting place'
 goto baddestination
;
.gadend
; clean up rest of input - may be useful, intelligent stuff,
; or it may be complete garbage
; Loop until we get a verb
 if nomoreinput=TRUE then gadret
 gosub @getnextword
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then gadend
 gosub @goback ; retrieve verb for later parsing
.gadret
 againnoun1=noun1
 noun2=nullobject
 return
;---
.parsefindvalue
; user entered 'go moveable object'
; treat as find
 if verb<>isetuprun then pfv1
 descriptionmode=inone
;
.pfv1
 verb=isetupfind
 noun1=value
 noun2=nullobject
 prep=0
 return
;---
.baddestination ; a parser error
 gosub @stop
 noun1=nullobject
 verb=0
 goto @cantseewhere
;---
.getparterror
 gperror=TRUE
 return
;---
.getpart
; return noun1 as destination room,
; or verb=direction to move in
; or treetype/terraintype
 gperror=FALSE
 gosub @getnextword
 if eol=TRUE then getparterror
; just possibly, could be a direction
 searchtype=verbtype
 gosub @checktype
 if value=nullvalue then getpart1
 if value=ivto then getpart ; go to ...
 if value>maxdirection then getpart1 ; strange verb
 verb=value
 return
;
.getpart1
 searchtype=adjetype
 gosub @checktype
 if value=nullvalue then getpart2
 adjective1=value
 gosub @checktypemore
 if value=nullvalue then getpart2
 adjective2=value
;
.getpart2
 index=0
.goloop
 searchtype=nountype
 gosub @checktypemore

 if value=nullvalue then getpart ; ignore garbage words here.
 if value>mingarbage then getpart
 if adjective1=nullobject then goloopnoadjective
 if value=adjective1 then goloopnoadjective ; could be right dest
 if adjective2=nullobject then goloopnoadjective
 if value>adjective2 then goloopnoadjective
 if value<>adjective2 then goloop ; can't be right destination
;
.goloopnoadjective
 if value>maxsceneryobj then goloopnotlocationobject
;
.golooptreatasfind
; does object exist in game?
 x1=currentpos(value)
 if x1=0 then goloop
 treatasfind=TRUE
 return
;
.goloopnotlocationobject
; maybe 'go static location'
; if so, extract room number
 if value<700 then goloop ; shortroomdescs-nounoffset
 x1=700 ; shortroomdescs-nounoffset
 noun1=value
 if value<1000 then goloopshortdescs ; longroomdescs-nounoffset
 x1=1000 ; longroomdescs-nounoffset
.goloopshortdescs
 sub noun1,x1
 return
;---
.gdgoxy
 if y<noun2 then gdgonorth
 if y>noun2 then gdgosouth
;; y=y1; so just go east or west
 if x=noun1 then @followfinished ; have arrived at destination, terminate command
 dir=3 ; east
 if x<noun1 then gdgotdir
 dir=7
 goto gdgotdir
;
.gdgosouth
 dir=4 ; south
 if x=noun1 then gdgotdir
 dir=5 ;se
 if x<noun1 then gdgotdir
 dir=6 ;sw
 goto gdgotdir
;
.gdgonorth
 dir=1 ; north
 if x=noun1 then gdgotdir
 dir=2 ;ne
 if x<noun1 then gdgotdir
 dir=8
; fall through to gdgotdir
.gdgotdir
 intendeddirection=dir
 anglefromintended=0
;; >>mike 8/2/88 gdroomsave=room
 gdCurrentSave=currentpos(actor) ;>>mike 8/2/88
 gdHiSave=hicurrentpos(actor) ;>>mike 8/2/88
.gdtrydir
 from=room
 dir=intendeddirection
 gosub adddir
;
 gosub @checkexit
 if exitvisible=FALSE then tryanotherdirection
 if dest<minsynthroomminus1 then tryanotherdirection
;; if dest=126 then tryanotherdirection
;; if dest=125 then tryanotherdirection
;; if dest=118 then tryanotherdirection
 hidest=0
 verb=dir
 commandfinished=FALSE
 gosub @move ; move the npc, describing as appropriate
;
; if a specialmoves trap was activated, we have to abort the
; find. (Because a message will have been printed, so continuing
; would just confuse the player. A better tracking algorithm
; in future games MIGHT be able to get round this)
 if blockedbysm=TRUE then @reportProblem ;>>mike 8/2/88 
;         >>8/2/88 followjustfinished ; something badly wrong.


;; >>mike 8/2/88 if room=gdroomsave then tryanotherdirection ; something went wrong
;; x1=currentpos(actor) ;>>mike 8/2/88
;; if x1<>gdCurrentSave then gdt1
;; x1=hicurrentpos(actorkwise)
 if anglefromintended=2 then tad2a
 add anglefromintended,c1 ; try +1, +2
 goto gdtrydir
;---
.tad2a
 anglefromintended=0
.tad2
; try wheeling round to left
 if anglefromintended=65534 then @cantgothere ; can't cope at present
 sub anglefromintended,c1 ; try -1,-2
 goto gdtrydir
;---
;; .cantgothere
;; if actor<>user then @NpcNotUnderstood
;; m1=3604 ; can't go there from here
;; gosub @printM1dot
;; goto @followfinished
;; ---
.adddir
; do add dir,anglefromintended
; this is comkwise)
 if anglefromintended=2 then tad2a
 add anglefromintended,c1 ; try +1, +2
 goto gdtrydir
;---
.tad2a
 anglefromintended=0
.tad2
; try wheeling round to left
 if anglefromintended=65534 then @cantgothere ; can't cope at present
 sub anglefromintended,c1 ; try -1,-2
 goto gdtrydir
;---
;; .cantgothere
;; if actor<>user then @NpcNotUnderstood
;; m1=3604 ; can't go there from here
;; gosub @printM1dot
;; goto @followfinished
;; ---
.adddir
; do add dir,anglefromintended
; this is complicated because south,southeast are swapped round
; Also must wrap round at north, northwest
;
; first, swap south,southeast
 gosub swapdir
 add dir,anglefromintended
 gosub makedirwithinbounds
; fall through to swapdir ; and swap back again
;
.swapdir
; swap round south, southeast
 if dir<>4 then swapdirnotsouth
 dir=5
 return
;---
.swapdirnotsouth
 if dir<>5 then swapdirret
 dir=4

.swapdirret
 return
;---
.makedirwithinbounds
 if dir<9 then mdwb1
 dir=1
 return
;---
.mdwb1
 if dir>0 then mdwb2
 dir=8
.mdwb2
.diwtret
.mmdret
.teleportret
.ringret
 return
;---
.teleport
 cif allowCheat
; we came here straight from the parser, so set up verb...
 if cheatmode=0 then @nicetry
 verb=iteleport
.allowteleport
 gosub @parsego
 if noun1=nullobject then teleportret
 if verb<>isetupfind then teleporttonoun1
 object=noun1
 gosub @getobjectposx2
 noun1=x2
;
.teleporttonoun1
 dest=noun1
;
.magicmove
 hidest=0
;
.magicmovedest
 if dest=0 then mmnomove
 if dest<2 then @cantseewhere
 currentpos(actor)=dest
 hicurrentpos(actor)=hidest
.mmaftermove
 gosub @setuproom
 gosub @getxy
 if actor<>user then mmdret
 currentuserroom=room
 gosub @printroom
 GOTO @CANCELINPUT
;---
.mmnomove
 cend

 m1=2995 ; you end up where you were
 gosub @printM1dot
 goto @cancelinput ; goto mmaftermove
;---
.noexit
 m1=2114 ; no exit!
 goto @errorM1dot
;---
.dig
 goto @noverb
;---
.forcem1dot
 message m1
 message dot
.snapret
 return
;---
.ring ; ring/play
 if object<>horn then playNotHorn
 gosub @PrintActor
 WindBlowing=true
 m1=2590 ; blew horn, wind sprang up
 gosub @PrintM1Dot
 if room<>56 then PlayHornNotChapel
 x1=currentpos(elemental)
 if x1=0 then PlayHornNotChapel
 m1=2647 ; effects on elemental
 add m1,CurrentElemental
 m1save=m1
 gosub @PrintM1Dot
 if m1save<>2649 then PlayHornNotChapel
 currentpos(elemental)=c0
 m1=2660 ; have faith - go for the grail!
 TempTitle=2678 ; "elemental slayer"
 goto @PrintM1Dot

.PlayHornNotChapel
 return

.playNotHorn
 m1=282 ; no!
 goto @printm1dot
;---
.retaliate
;; .dig
.choose
.plant
 goto @noverb
;-
;---
.drink
 if noun1=ChaliceOfWater then DrinkChalice
 if noun1<>ChaliceOfMead then DrinkNChalice
.DrinkChalice
 gosub @PrintActor
 m1=2628 ; drank
 gosub @PrintM1
 object=noun1
 gosub EmptyChalice
 goto @PrintDot

.DrinkNChalice
 if noun1=CupOfWater then DrinkCup
 if noun1<>CupOfMead then DrinkNCup
.DrinkCup
 gosub @PrintActor
 m1=2628 ; drank
 gosub @PrintM1
 object=noun1
 gosub EmptyCup
 goto @PrintDot

.DrinkNCup
 if room<>37 then drinkNotWell
 m1=2608 ; tried to drink, but was too weak
 if actor=pilgrim then @ActorM1Dot
 m1=2609 ; refused to sully the holy water
 if actor<>user then @ActorM1Dot
 m1=2610 ; water sank away from L
 goto @PrintM1Dot

.drinkNotWell
 if room=4 then @Done ; well
 m1=107 ; bleuch
 goto @printm1dot
;---
.EmptyChalice
 x1=currentpos(object)
 x2=Hicurrentpos(object)
 currentpos(object)=c0
 currentpos(Chalice)=x1
 hicurrentpos(Chalice)=x2
 m1=2524 ; 2624-100
 add m1,Object
 goto @PrintM1
;---
.EmptyCup
 x1=currentpos(object)
 x2=Hicurrentpos(object)
 currentpos(object)=c0
 currentpos(Cup)=x1
 hicurrentpos(Cup)=x2
 m1=2519 ; 2624-105
 add m1,Object
 goto @PrintM1
;---
.NotWaterTight
 gosub @PrintTheObject
 m1=2595 ; not watertight
 if object<100 then NWT1
 if object>109 then NWT1
 m1=2596 ; already full
.NWT1
 goto @PrintM1Dot
;---
.fill
; cup/chalice
 if noun1=Chalice then FillChalice
 if noun1<>cup then NotWaterTight
; fill the cup!
 object=105 ; base for filled cups
 goto Fill1

.FillChalice
 object=100 ; base for filled chalices

.Fill1
 x1=1 ; water
 if room<>37 then FillNotWell
 if actor<>user then Fill2
 m1=2610 ; water sank away from L
 goto @PrintM1Dot

.FillNotWell
; 2=mead
 x1=3 ; sand
 if room=42 then Fill2
 x1=1 ; water
 if room=4 then fill2 ; at stream
 if room<MinSynthRoom then NoWater
; drop through to fill2

.Fill2
 x2=currentpos(noun1)
 x3=hicurrentpos(noun1)
 cTurn=true

 gosub @PrintActor
 m1=2506 ; made sign of cross
 gosub @printM1Dot
; Now special cases for destroying fiends
 if room<>13 then CrossNotPriest
 m1=2507 ; was revealed as a fiend
 object=Priest
 x1=scPriest
 gosub @AddScore20

.CrossObject
 gosub @checkifpresent ; make sure the object is here
 if result=false then CrossRet

 if m1=0 then @DestroyObject
 gosub @PrintTheObject
 gosub @printm1dot
 goto @DestroyObject
;------
.CrossNotPriest
 if room<>5 then CrossNotPavillion
.DTurn=true

 gosub @PrintActor
 m1=2506 ; made sign of cross
 gosub @printM1Dot
; Now special cases for destroying fiends
 if room<>13 then CrossNotPriest
 m1=2507 ; was revealed as a fiend
 object=Priest
 x1=scPriest
 gosub @AddScore20

.CrossObject
 gosub @checkifpresent ; make sure the object is here
 if result=false then CrossRet

 if m1=0 then @DestroyObject
 gosub @PrintTheObject
 gosub @printm1dot
 goto @DestroyObject
;------
.CrossNotPriest
 if room<>5 then CrossNotPavillion
.DestroyPavillion
 m1=2508
 currentpos(bed)=c0
 object=pavillion
 gosub CrossObject
 x1=scDamosel
 gosub @AddScore20
 object=Damosel
 m1=2507 ; was revealed as a fiend
 goto CrossObject

.CrossNotPavillion
 if room<>51 then CrossNotInPavillion
 currentpos(damosel)=c0 ; kill damosel (always in Pavillion)
 pos=51
 hipos=0
 dest=5
 hidest=0
 gosub @possloop ; move everything / everyone out of pavillion
 gosub @setuproom ; we've moved!
 m1=2509 ; pavillion vanished+lancelot tipped out of it
 gosub @printm1
 goto destroyPavillion

.CrossNotInPavillion
; permit crossing etc. when in holy places...
 if room=50 then CrossRet ; vagon castle
 if room=9 then CrossRet ; cross near start
 if room=52 then CrossRet ; cross inside church
 if room=34 then CrossRet ; cross in wasteland
 if room=33 then CrossRet ; Nacien's Hermitage
 if room<53 then CrossNotOk
 if room<57 then CrossRet ; near grail
.CrossNotOk
; make game end if crossed too many times

 GalahadComment=2694
 m1=2537 ; taking name of god in vain
 add NumberFailedCrosses,c1
 if NumberFailedCrosses>10 then @UserDeathM1
.CrossRet
 return
;---
.eat
 if noun1<OneCake then eatNotCake
 if noun1>ThreeCakes then eatNotCake
 x4=currentpos(noun1)
 x5=hicurrentpos(noun1)
 currentpos(noun1)=c0 ; kill the cake just eaten
 sub noun1,c1
;; if noun1<OneCake then eatLastCake
 x1=noun1
 x2=OneCake
 sub x1,x2
 m1=2523 ; eat first cake message +1 to compensate for sub noun1,c1 above
 add m1,x1 ; +0..2
 gosub @Actorm1dot
 if noun1<OneCake then eatLastCake
; make new, smaller number of cakes appear.
 currentpos(noun1)=x4
 hicurrentpos(noun1)=x5
 itword=noun1 ;>>mike 23/8/88
 againNoun1=noun1 ;>>mike 23/8/88
 return

.eatLastCake
 currentpos(tray)=c0 ; kill tray to allow damosel to invite him to bed
 DamoselRandy=true
 TempTitle=2674 ; "the glutton"
 x1=s5
 goto @AddSin
; m1=2523 ; now the best knight in the world
; goto PrintM1Dot

.eatNotCake
 m1=107 ; Yeuch!
 goto @printm1dot
;----
.GENERALBLOW
; given TARGET,ACTOR (WHO IS ATTACKING)
; do an ordinary (non-magical) blow
;
 IF ACTOR=TARGET THEN @mighthurtyourself
;; object=target
;; gosub @isobjectalive
;; if result=true then gbalive
;; if target>maxpeople then @silly
;; m1=3509 ; what harm could a dead body do you?
;; goto @errorm1dot
;; 
;; .gbalive
;; first calculate blow strength
 X1=ATTACKOFFSET
 ADD X1,ACTORATTRIBUTES
 BLOWSTRENGTH=NPCINITIAL(X1)
;; IF WEAPONSTRENGTH<BLOWSTRENGTH THEN GB1
;; BLOWSTRENGTH=WEAPONSTRENGTH
.GB1
;; GOSUB @RANDOMIZEBLOWSTRENGTH
;; DO A GENERALBLOW
;; now do the blow
;; with strength BLOWSTRENGTH
;; see if target dodges
;; OBJECT=TARGET
;; GOSUB @SetX4ToObjectAttributes
;; X1=DODGEOFFSET
;; ADD X1,X4
;; x6=npcinitial(x1)
;; random x1
;; IF X1>X6 THEN GBNDODGE
;; 
;; .describedodge
;; you bet, so print "you attack the klingon"
;; verb=40 ; attack
;; gosub @describeattackverb
;; m1=3517 ; but
;; gosub @reportm1
;; object=target
;; lastwordprinted=object ; force printing of article
;; verb=idodge
;; gosub @objectverb
;; m1=dot
;; goto @reportm1
;; 
;; .GBNDODGE
 GOSUB @DESCRIBEATTACK ; first part of report
 m1=dot
 gosub @Printm1

.gbnnodescription
;; GOSUB @CHECKARMOUR
;; returns X1=object number of armour worn (0 if none)
;; IF X1=0 THEN GBH
;; damage/destroy shield etc.
;; M1=3511 ; blow strikes its
;; IF TARGET<>USER THEN GBSHIELD
;; M1=3510 ; blow strikes your
;; .GBSHIELD
;; gosub @reportm1
;; GOSUB @DESCOBJX1 ; describe armour etc.
;; .gbnodesc
;; IF X1<>SHIELD THEN GBARMOUR
;; SUB SHIELDSTRENGTH,BLOWSTRENGTH
;; IF SHIELDSTRENGTH=0 THEN GBSHATTER
;; IF SHIELDSTRENGTH>NEGATIVE THEN GBSHATTER
;; X2=SHIELDSTRENGTH
;; .GBEND
;; MESSAGE 3525 ; (which has
;; PRINT X2 ; strength of armour remaining
;; MESSAGE 3526 ; hit points left).
;; .GBRET
;; RETURN
;; 
;; .GBSHATTER
;; CURRENTPOS(X1)=C0
;; M1=3514 ; shattering it.
;; goto @reportm1
;; 
.GBH
; target not wearing armour or whatever,
.DODAMAGE
 OBJECT=TARGET
 GOSUB @SetX4ToOBJECTAttributes
 X1=HITPOINTOFFSET HitPoints<>0 then @makeenemies
; drop through to death
 goto targetdeath
;-
.reporthealth
; describe hit points remaining on target
 OBJECT=TARGET
.reporthealthobject
; x1 must be set up (see below in code)
 verb=82 ; you are/it is
 ValueSave=x1 ; preserve position in npcxxx()
 gosub @PrintObjectverb
 if hitpoints=0 then dddead
 x1=npcinitial(ValueSave) ; initial hit points
 x2=10
 gosub @x1divx2
; x1=number of points for each health report division
 x2=x1
 x1=hitpoints
 gosub @x1divx2
 HitPoints<>0 then @makeenemies
; drop through to death
 goto targetdeath
;-
.reporthealth
; describe hit points remaining on target
 OBJECT=TARGET
.reporthealthobject
; x1 must be set up (see below in code)
 verb=82 ; you are/it is
 ValueSave=x1 ; preserve position in npcxxx()
 gosub @PrintObjectverb
 if hitpoints=0 then dddead
 x1=npcinitial(ValueSave) ; initial hit points
 x2=10
 gosub @x1divx2
; x1=number of points for each health report division
 x2=x1
 x1=hitpoints
 gosub @x1divx2
 if x1>0 then printhealth
.dddead
 x1=0 ; dead!
.printhealth
 m1=2560 ; health report
 add m1,x1
 if m1<2570 then PrintHealthPrint
 m1=2569
.PrintHealthPrint
 if m1<>2560 then PrintHealthPrint1
 if hitpoints=0 then PrintHealthPrint1
 m1=2561 ; not quite dead yet
.PrintHealthPrint1
 goto @Printm1Dot
;-

;; .actordeath
;; target=actor
;; 
;; .targetdeath
;; enemies don't hate it any more...
;; lastwordprinted=0
;; commandfinished=true
;; x4=enemyoffset
;; .targetdeath1
;; x1=npccurrent(x4)
;; if x1<>target then targetdeath2
;; npccurrent(x4)=c0
;; .targetdeath2
;; x1=16 ; npcentrysize
;; add x4,x1 ; npc entry size
;; if x4<npctablesize then targetdeath1
;; 
;; 
;; set target to have 0 hit points
;; OBJECT=TARGET
;; GOSUB @GETNPCATTRIBUTES
;; X1=HITPOINTOFFSET ; find hit points
;; ADD X1,X4
;; npccurrent(x1)=c0
;; HIPOS=CARRIED ; only drop carried things, not worn etc.
;; POS=TARGET
;; DEST=ROOM
;; HIDEST=0
;; GOSUB @POSSLOOP ; drop everything
;; actorsave=actor
;; actor=target
;; GOSUB @stop ; don't let it continue with commands !!!
;; actor=actorsave
;; 
;; .resetactor
;; actor=actorsave
;; gosub getactorattributes
;; goto @initfifo
;---
.DESCRIBEATTACK
 gosub @printActor
 m1=2540 ; smote
 gosub @printm1
 object=Target
 goto @printTheObject
;; first part of damage report for ACTOR vs TARGET
;; 
;; now pick out the appropriate verb - from "scratch"
;; through to "pulverise"
;; x1=blowstrength ; (approx 1..40)
;; x2=4 ; ( want 10 divisions, 0..9)
;; gosub @x1divx2
;; if x1<10 then daok
;; x1=9 ; max blow
;; .daok
;; verb=170 ; armed blows
;; if weapon<>nullobject then da1
;; verb=180 ; unarmed blows ( relative to verboffset)
;; .da1
;; add verb,x1 ; appropriate attack verb
;; .describeattackverb
;; noun1=target
;; prep=with
;; noun2=weapon
;; goto @printActorAction
;; ---
;; ---
;; .CHECKARMOUR
;; ; return X1=object number of armour worn by TARGET or X1=0 if none
;; .CAFAIL
;; X1=0 ; no armour found
;; 
;; .CARET
;; RETURN
;; ---
;; ---

.actordeath
 target=actor

.targetdeath
;; enemies don't hate it any more...
 x4=enemyoffset
.targetdeath1
 x1=npccurrent(x4)
 if x1<>target then targetdeath2
 npccurrent(x4)=c0
.targetdeath2
 x1=npcentrysize
 add x4,x1 ; npc entry size
 if x4<npctablesize then targetdeath1


; set target to have 0 hit points (for benefit of NPC.TXT, if nowt else)
 OBJECT=TARGET
 GOSUB @SetX4ToOBJECTAttributes
 X1=HITPOINTOFFSET ; find hit points
 ADD X1,X4
 npccurrent(x1)=c0
 HIPOS=CARRIED ; only drop carried things, not worn etc.
 POS=TARGET
 DEST=ROOM
 HIDEST=0
 GOSUB @POSSLOOP ; drop everything
 actorsave=actor
 actor=target
 GOSUB @stop ; don't let it continue with commands !!!
 actor=actorsave
 currentpos(target)=c0
 if target=user then @userDeath
 return
;; ---
;; ---
;; .REMOVE
;; POS=ACTOR
;; HIPOS=CARRIED
;; GOTO @MOVEOBJECT
;; ---
;; .gameAfterRestore
;; GOSUB @PRINTROOM
;; actor=user
;; gosub @stop
;; GOTO @getfromuser
;; -----
