* Atari ST driver
* Copyright (C) 1986 Level 9 Computing
* M.J.Austin 24/2/88

* recent changes:


* 24/2/88:
*  Minor changes to InitTasks to try to prevent the bug in which
*  the disk light came on, and the palette in the picture was
*  not changed
* routine "MyVBLEvent" added which sets up the colour set
* AFTER the operating system has done its vbl stuff.
* This is in addition to existing palette setup in "CopyCols" in NEWHIRES.S

* 29/4/88 changes to ReturnToGem to try to show mouse pointer always
* and to set user mode on exit.


* note - if 'graphics' is defined elsewhere (as anything),
* the appropriate code will be assembled in here.
* To make this driver public domain, simply
* remove all the code assembled within the 'ifd' instruction

* Some programs need to know which machine they are running
* on (e.g. to allow for different assemblers)
* this is catered for by the following constants
* THIS FACILITY SHOULD BE USED AS LITTLE AS POSSIBLE

ilsize equr d2
ilhighwater equr d3
ilpos equr d4

*!!! opt d+ ; turn on symbol table dump

amiga   equ 1
st      equ 2

computertype    equ st

StartOfDriver

disable_cursor	macro
	addq.w	#1,suspendtaskswap
	move.w	#0,-(sp)
	move.w	#cursconf,-(sp)
	trap	#14
	addq.l	#4,sp
	clr.b	cursor_inuse
	subq.w	#1,suspendtaskswap
	endm

enable_cursor macro
	addq.w	#1,suspendtaskswap
	move.w	#1,-(sp)
	move.w	#cursconf,-(sp)
	trap	#14
	addq.l	#4,sp
	move.w	#3,-(sp)
	move.w	#cursconf,-(sp)
	trap	#14
	addq.l	#4,sp
	move.b	#1,cursor_inuse
	subq.w	#1,suspendtaskswap
	endm
*---
waitkey
 bsr	snooze
 move.b #osrdchdcode,d0
 bsr driver
 tst.b (a6)
 beq.s waitkey
 rts
*---

* character constants

crlf equ 13
cr equ 13
lf equ 10
bs equ 8
eof equ 26
cursorleft equ 2 ;  ^B - Perfect Writer type control keys
cursorright equ 6 ; ^F - used as values generated by cursor keys
cursorup equ 16   ; ^P
cursordown equ 14 ; ^N
pageoff equ 15
helpkey equ 21
quitkey equ 17 ; also = control-Q
autorunkey equ 18
logkey equ 19
undokey equ 20
F1 equ 128 * function key 1
F2 equ 129 * function key 2

true equ $ff

* driver constants

initdcode equ 0
checksumdcode equ 1
oswrchdcode equ 2
osrdchdcode equ 3
inputlinedcode equ 4
savedcode equ 5
loaddcode equ 6
settextdcode equ 7
taskinitdcode equ 8
returntoosdcode equ 9
chainprogramdcode equ 11
randomnumberdcode equ 12

getclockdcode equ 14
;
clgdcode equ 16
linedcode equ 17
filldcode equ 18
chgcoldcode equ 19
finishpicturedcode equ 20

ramsavedcode equ 22
ramloaddcode equ 23
lenslokdisplaydcode equ 25

displayhirescode	equ	32
preloadhirescode	equ	33
testhirescode		equ	34
* equates for BDOS calls (ie Trap #1)

P_TERM_OLD      EQU 0           (should use $4C really)
C_CONIN EQU 1
C_CONOUT        EQU 2
C_AUXIN EQU 3
C_AUXOUT        EQU 4
C_PRNOUT        EQU 5
C_RAWIO EQU 6
C_RAWCIN        EQU 7
C_NECIN EQU 8
C_CONWS EQU 9
C_CONRS EQU $0A
C_CONIS EQU $0B
D_SETDRV        EQU $0E
C_CONOS EQU $10
C_PRNOS EQU $11
C_AUXIS EQU $12
C_AUXOS EQU $13
D_GETDRV        EQU $19
F_SETDTA        EQU $1A
_SUPER          EQU $20
T_GETDATE       EQU $2A
T_SETDATE       EQU $2B
T_GETTIME       EQU $2C
T_SETTIME       EQU $2D
F_GETDTA        EQU $2F
S_VERSION       EQU $30
P_TERMRES       EQU $31
D_FREE          EQU $36
D_CREATE        EQU $39
D_DELETE        EQU $3A
D_SETPATH       EQU $3B
F_CREATE        EQU $3C
F_OPEN          EQU $3D
F_CLOSE EQU $3E
F_READ          EQU $3F
F_WRITE EQU $40
F_DELETE        EQU $41
F_SEEK          EQU $42
F_ATTRIB        EQU $43
F_DUP           EQU $45
F_FORCE EQU $46
D_GETPATH       EQU $47
M_ALLOC EQU $48
M_FREE          EQU $49
M_SHRINK        EQU $4A
P_EXEC          EQU $4B
P_TERM          EQU $4C
F_SFIRST        EQU $4E
F_SNEXT EQU $4F
F_RENAME        EQU $56
F_DATIME        EQU $57

* Base Page Offsets
P_LOWTPA        EQU 0
P_HITPA EQU 4
P_TBASE EQU 8
P_TLEN          EQU $0C
P_DBASE EQU $10
P_DLEN          EQU $14
P_BBASE EQU $18
P_BLEN          EQU $1C
P_ENV           EQU $2C
P_CMDLIN        EQU $80

* Error codes
E_OK            EQU 0
ERROR           EQU -1
EDRVNR          EQU -2
EUNCMD          EQU -3
E_CRC           EQU -4
EBADRQ          EQU -5
E_SEEK          EQU -6
EMEDIA          EQU -7
ESECNF          EQU -8
EPAPER          EQU -9
EWRITF          EQU -10
EREADF          EQU -11
EGENRL          EQU -12
EWRPRO          EQU -13
E_CHNG          EQU -14
EUNDEV          EQU -15
EBADSF          EQU -16
EOTHER          EQU -17

EINVFN          EQU -32
EFILNF          EQU -33
EPTHNF          EQU -34
ENHNDL          EQU -35
EACCDN          EQU -36
EIHNDL          EQU -37
ENSMEM          EQU -39
EIMBA           EQU -40
EDRIVE          EQU -46
ENMFIL          EQU -49
ERANGE          EQU -64
EINTRN          EQU -65
EPLFMT          EQU -66
EGSBF           EQU -67

* BIOS calls (Trap #13) - Atari names are lower case
getmpb          equ 0
bconstat        equ 1
bconin          equ 2
bconout equ 3
rwabs           equ 4
setexc          equ 5
tickcal equ 6
getbpb          equ 7
bcostat equ 8
mediach equ 9
drvmap          equ 10
kbshift equ 11

* Extended BIOS calls (Trap #14)
initmous        equ 0
ssbrk           equ 1
_physbase       equ 2
_logbase        equ 3
_getRez equ 4
_setScreen      equ 5
_setPalette     equ 6
_setColor       equ 7
_floprd equ 8
_flopwr equ 9
_flopfmt        equ 10
midiws          equ 12
_mfprint        equ 13
iorec           equ 14
rsconf          equ 15
keytbl          equ 16
_random equ 17
_protobt        equ 18
_flopver        equ 19
scrdmp          equ 20
cursconf        equ 21
settime equ 22
gettime equ 23
bioskeys        equ 24
ikbdws          equ 25
jdisint equ 26
jenabint        equ 27
giaccess        equ 28
offgibit        equ 29
ongibit equ 30
xbtimer equ 31
dosound equ 32
setprt          equ 33
kbdvbase        equ 34
kbrate          equ 35
_prtblk equ 36
vsync           equ 37
supexec equ 38
puntaes equ 39


* System Variables
proc_lives      equ $380
proc_dregs      equ $384
proc_aregs      equ $3a4
proc_enum       equ $3c4
proc_usp        equ $3c8
proc_stk        equ $3cc
etv_timer       equ $400
etv_critic      equ $404
etv_term        equ $408
etv_xtra        equ $40c
memvalid        equ $420
memcntlr        equ $424
resvalid        equ $426
resvector       equ $42a
phystop equ $42e
_membot equ $432
_memtop equ $436
memval2 equ $43a
flock           equ $43e
seekrate        equ $440
_timr_ms        equ $442
_fverify        equ $444
_bootdev        equ $446
palmode equ $448
defshiftmd      equ $44a
sshiftmd        equ $44c
_v_bas_ad       equ $44e
vblsem          equ $452
nvbls           equ $454
_vblqueue       equ $456
colorptr        equ $45a
screenpt        equ $45e
_vbclock        equ $462
_frclock        equ $466
hdv_init        equ $46a
swv_vec equ $46e
hdv_bpb equ $472
hdv_rw          equ $476
hdv_boot        equ $47a
hdv_mediach     equ $47e
_cmdload        equ $482
conterm equ $484
themd           equ $48e
savptr          equ $4a2
_nflops equ $4a6
sav_context     equ $4ae
_bufl           equ $4b4
_hz_200 equ $4bc
the_env equ $4be
_drvbits        equ $4c4
_dskbufp        equ $4c6
_prt_cnt        equ $4ee
_sysbase        equ $4f2
_shell_p        equ $4f6
end_os          equ $4fa
exec_os equ $4fe

*---------
* Macros ;
*---------

* call the BDOS - requires 1 parameter:
* the function number
call_bdos       macro
		addq.w	#1,suspendtaskswap
                move.w #\1,-(sp)
                trap #1
		subq.w	#1,suspendtaskswap
              endm

bdosmacroerror
bdosmacroiloop
 bra.s bdosmacroiloop

* call the BIOS - requires 1 parameter:
* the function number
call_bios       macro
		addq.w	#1,suspendtaskswap
                move.w #\1,-(sp)
                trap #13
		subq.w	#1,suspendtaskswap
                endm

* call the extended BIOS - requires 1 parameter:
* the function number
call_ebios      macro
		addq.w	#1,suspendtaskswap
                move.w  #\1,-(sp)
                trap    #14
		subq.w	#1,suspendtaskswap
                endm

* print string whose address is given by parameter
*prs macro
* pea \1(pc)
* call_bdos c_conws
* addq.l #6,sp
* endm

macrospsave dc.l 0
suspendtaskswap dc.w 0

*---------------------
* the Program Itself ;
*---------------------


driver
* Standard entry point for all external routines
* Parameter block is pointed to by a6
* all registers preserved
 movem.l d0-d7/a0-a6,-(a7) ; overkill ?
 pea driverret(pc) ; return address from routines
 cmp.b #initdcode,d0
 beq init
 cmp.b #checksumdcode,d0
 beq calcchecksum
 cmp.b #oswrchdcode,d0
 beq driveroswrch
 cmp.b #osrdchdcode,d0
 beq driverosrdch
 cmp.b #savedcode,d0
 beq driversavefile
 cmp.b #loaddcode,d0
 beq driverloadfile
 cmp.b #settextdcode,d0
 beq settext

 cmp.b #taskinitdcode,d0
 beq resetginttask
 cmp.b #inputlinedcode,d0
 beq driverinputline
 cmp.b #returntoosdcode,d0
 beq closedown
 cmp.b #randomnumberdcode,d0
 beq randomnumber

 cmp.b #getclockdcode,d0
 beq getclock
 cmp.b #clgdcode,d0
 beq driverclg

 cmp.b #ramsavedcode,d0
 beq ramsave
 cmp.b #ramloaddcode,d0
 beq ramload
 
 cmp.b #lenslokdisplaydcode,d0
 beq lenslokdisplay
	cmp.b	#displayhirescode,d0
	beq	displayhiresvector
	cmp.b	#testhirescode,d0
	beq	testhiresvector
 rts ; nothing else, so return to driverret (i.e. next line!)
driverret
 movem.l (sp)+,d0-d7/a0-a6
 rts
displayhiresvector
 jmp displayhires

testhiresvector
 jmp testhires
*---
*---
getclock
; return real time clock in list9(hi4,hi3,lo2,lo)
; approx 1/50 second per unit
 move.l realtimeclock(pc),d0
 move.l d0,(a6)
 rts
*---
randomnumber
* return a random word
	addq.w	#1,suspendtaskswap
 move.w #17,-(sp)
 trap #14
 addq.l #2,sp
 move.w d0,(a6)
	subq.w	#1,suspendtaskswap
 rts
*---
lenslokdisplay
* On the screen !!!!
 bsr prs
 dc.b cr,'The code is: [',0
 even
 move.b #oswrchdcode,d0
 bsr driver ; left hand character
 move.b $1(a6),d1
 move.b d1,(a6)
 bsr driver ; right hand character
 bsr prs
 dc.b ']',cr,0
 even
 rts
*---
ramsave
 bsr initram
* copy workspace to ram
 move.l (a6),a0 ; start address
 move.l $8(a6),a1 ; start of destination block
ramsave1
 move.l (a0)+,(a1)+
 cmp.l $4(a6),a0 ; end address
 bls.s ramsave1 ; unsigned <
 rts
*---
ramload
 bsr initram
 move.l (a6),a1 ; start of workspace (destination)
 move.l $8(a6),a0 ; start of save area (source)
ramload1
 move.l (a0)+,(a1)+
 cmp.l $4(a6),a1 ; end address
 bls.s ramload1 ; unsigned <
 rts

*---
initram
** for debugging, print addresses
* movem.l d0-d7/a0-a6,-(sp)
* move.l (a6),a0
* bsr hexlonga0
* move.l $4(a6),a0
* bsr hexlonga0
* move.l $8(a6),a0
* bsr hexlonga0
* move.b #13,d0
* bsr oswrch
* movem.l (sp)+,d0-d7/a0-a6


* (a6).l is start address
 move.l $4(a6),a1 ; end address
* $8(a6).l ; position in save memory
* now see if enough space in save memory
 sub.l (a6),a1 ; get length to save
 add.l $8(a6),a1
* now d1.l=address of end of save memory
* compare with screen address-$1000 to see if enough memory
 move.l screenpointer,a0
 sub.l #$1000,a0
 cmp.l a0,a1
 bhi.s ramoverflow

* ok, so return
 rts
*---
ramoverflow
 move.b #$ff,(a6) ; non-zero, indicating failure
 move.l (sp)+,d0 ; remove return address, return to driver call
 rts
*---
returnzero
 move.b #0,(a6) ; indicate failiure of operation
 rts
*---
closedown
* exit gracefully
 bsr prs
 dc.b cr
 dc.b "Do you really want to leave the game? ",0
 even
closedownloop
	bsr	snooze
 bsr osrdch
 cmp.b #"y",d0
 beq.s cd1
 cmp.b #"Y",d0
 beq.s cd1
 cmp.b #"n",d0
 beq.s noclosedown
 cmp.b #"N",d0
 bne.s closedownloop
noclosedown
 bsr prs
 dc.b cr,0
 even
 clr.b d0 ; avoid returning any values to caller (of osrdch)
 rts
*
cd1
 ifd graphics
  move.b #settextdcode,d0
  bsr killmultitasking
  bsr driver
 endc ; if graphics

 bra returntogem
*---
 ifd graphics
killmultitasking
* is multi-tasking running?
 move.l osvblhandler(pc),d0
 beq.s closenotasks
 move.l d0,$70 ; restore os irq vector
closenotasks
 move.l oshblhandler(pc),d0
 beq.s closenosplit
 move.l d0,$68 ; restore fast vector
closenosplit
* all split screens disabled (if they werew running)
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s closedownhires ; changing to med res from lowres reboots!
* Now set medium resolution,
* so OS will print 80 column text correctly
 move.w #1,-(sp) ; medium resolution
 move.l #-1,-(sp) ; retain physical base
 move.l #-1,-(sp) ; retail logical base
* move.w #5,-(sp) ; set screen
 call_ebios _setscreen
 add.l #12,sp

closedownhires
 lea defaultcolours,a0
 bra setuppalettea0
 endc ; ifd graphics
*------
SafeBreakPoint
 ifd AllowTraps

  movem.l d0-d7/a0-a6,-(sp)
  move.w #1,-(sp) ; med resolution
  move.l #$f8000,-(sp) ; retain physical base
  move.l #$f8000,-(sp) ; retail logical base
* move.w #5,-(sp) ; set screen
  call_ebios _setscreen
  add.l #12,sp
  movem.l (sp)+,d0-d7/a0-a6
  dc.w $4afa
 endc
 rts
*----
defaultcolours
 dc.w $777 ; window background colour - white
 dc.w $700 ; not used by gem - red
 dc.w $060 ; desktop colour (when not covered by windows) - green
 dc.w $000 ; text - black
*---
getscreenaddress
* return address of screen start in a0.l and d0.l
 call_ebios _physbase
 addq.l #2,sp
 move.l d0,a0
 rts
*---
*starttask
* initialse a new task with starting address of (a6).l
* task handles go 0,8,16,24,...
* Thus the task handle is merely the offset in the task
* control block
* structure of task control block
* is:
*tcbentrysize equ 16
*  ;* address of next entry in TCB
*  ;* end address of this entry in table
*  ;* current stack pointer for task
*       (0000 if last value in table)
*  ;    priority (not currently implemented)
*  ;    not currently used
*  ;    not currently used
*  ;    not currently used
*  ...  stack space for task

* stack space required by this new task is $4(a6).l
* move.l $4(a6),d0
* add.l #tcbentrysize,d0 ; d0.l is space required by new task tcb

* first scan through table for an empty space
* lea taskcontrolblock,a0 ; current position in table
*starttask1
* move.l (a0),a1 ; a1 is position of next entry in table
* beq.s lastentry ; last entry in table
* where does this tcb entry end ?
* move.l $4(a0),a2
** is there a gap between this entry and the next ?
* sub.w a2,a1 ; what is the gap between this entry and the next
* cmp.w d0,a1 ; big enough for new tcb entry ?
* bcc.s starttask1 ; unsigned >= 
*
* move.l (a0),a0 ; move to next entry
* bra.s starttask1
*
**lastentry
** (a0) is last entry in table,
* so append this tcb onto the end
*gottcbgap
* there is a gap in the tcb table at tcbentrysize(a0,d1)
* move.w d1,d2
* add.w #tcbentrysize,d2
** d2 is now pointer to vacant entry
** change reference of previous entry to point to it ...
* move.w d2,$4(a0,d1)
* and set up pointer of new entry to point to next
* element in the chain
* move.w d0,$4(a0,d2)
* and set up the stack pointer for it
* 
numswaps
 dc.w 0 ; ??????
 even ;?????
*---

resetginttask
	add.w	#1,suspendtaskswap
 lea gintstacktop(pc),a0

 lea gintstart(pc),a1
 move.l a1,-(a0)
 move.w sr,-(a0)
 lea irqswaptaskend(pc),a1
 move.l a1,-(a0) ; return address from ist1

 movem.l d0-d7/a0-a6,-(a0) ; dummy stack values
 lea taskstackptr,a1
 move.l a0,(a1)
	move.b	#1,drivergraphicsmode
	bsr	hidepointer
	bsr	showpointer
	bsr	scroll_itnow
 subq.w #1,suspendtaskswap
	rts
*---
setsupervisormode
 clr.l -(sp)
 call_bdos _super
 add.l #6,sp
* and check if in supervisor mode
 move.w sr,d0
 and.w #$2000,d0
 beq.s setsupervisormode ; NO! ;+@%*œ^%* operating system!
* d0 = old supervisor stack (See P.113 ST Internals for details)
 rts
*---
 ifd graphics
initialisetasks
* set up stack values for tasks
* the task for the program which called initdcode 
* is automatically set up, so ignore it at present
* first push on a ret address on to fire up the gint task
* first fake a status word as if from an exception vector
* first put system permamently into supervisor mode
 bsr.s setsupervisormode

 bsr resetginttask
* now set up the interrupt vector
* it doesn't matter if interrupts occur during the
* following bit of code ....
* now set up MY VBL interrupt handler routine
 tst.l osvblhandler
 bne.s vblalreadysetup
 move.l $70,d0			; address of OS routine

 lea StartOfDriver,a1
 cmp.l a1,d0
 bcc.s vblsetup2
* already within the driver
* is our record of the osvblhandler ok?
 move.l osvblhandler,d1
 cmp.l a1,d1
 bcs.s vblAlreadySetup * within the os ( I think )
* oh dear!
 lea NullVBL,a0
 move.l a0,d0 * set osvblhandler to just do an rte - for safety

vblsetup2
 lea osvblhandler,a0
 move.l d0,(a0)

 lea irqvblhandler,a0
 move.l a0,$70			; ... and enable my routine
vblalreadysetup
 rts

NullVBL
* security code only
 rte


*---
 endc 				; ifd graphics, just before initialisetasks
snoozeend
 move.w (sp)+,d0
snoozeret
 rts
*---
snooze
 ifd graphics
 move.w d0,-(sp)
 move.b snoozesinceswap(pc),d0
 bne.s snoozeend
 move.w (sp)+,d0

 move.l a0,-(sp)
 lea snoozesinceswap,a0
 move.b #1,(a0) ; prevent further snoozes in this time slot
 move.l (sp)+,a0

 move.w sr,-(sp) ; simulate a irq
 bsr.s ist1
* and remove the sr value
 move.w (sp)+,sr
 endc ; graphics
 rts

*irqswaptask
* have just received a VBL irq
* do a task swap, if needed
* and then jump to (osvblhandler)
* No registers to be corrupted, except sr
* first, reset snoozesinceswap

* move.l a0,-(sp)
*lea snoozesinceswap,a0
* clr.b (a0)
* move.l (sp)+,a0
* bsr.s ist1
irqswaptaskend
 move.l osvblhandler,-(sp)
 rts
*---
ist1
* can't interrupt the OS ;(because it does all sorts of terrible
* things - like non-reentrant code etc.)
 movem.l d0-d7/a0-a6,-(sp) ; from task just finished
 move.b drivergraphicsmode,d0
 beq.s istnoswap ; false, so in text mode, so don't do task swapping
	tst.w	suspendtaskswap
	bne.s	istnoswap
 lea taskstackptr,a0
 move.l (a0),d0 ; stack pointer of other stack
 move.l sp,(a0) ; save stack pointer
* and now do the task swap !!!!
 move.l d0,sp

istnoswap
 movem.l (sp)+,d0-d7/a0-a6 ; restore reggies (for task to start)
istret
 rts
*---
init1
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 clr.b (a0)
*>>19/10/87 lea cursorypos,a0
*>>19/10/87 move.b #24,(a0) ; bottom left is 0,24 here

 lea cyclicwriteptr,a0
 lea cyclicib,a1
 move.l a1,(a0)
 lea cyclicbufferstart,a0
 move.l a1,(a0)
 lea cyclicbufferend,a0
 lea cyclicibtop,a1
 move.l a1,(a0)
 lea cycliccharsused,a0
 clr.l (a0)
 rts
*---
init2
* now before doing anything, clear out the screen
	bsr	hidepointer
**18/10/87	disable_cursor
* and clear it!
	move.l this_screen(pc),a0
	move.l	logpointer,a1
	move.w #$1fff,d0 ; length to clear
	moveq.l #0,d1
cls1
	move.l d1,(a0)+
	move.l	d1,(a1)+
	dbra	d0,cls1
	move.b #12,(a6)
	move.b #oswrchdcode,d0
	bsr driver
	bsr	gotobot
**18/10/87	enable_cursor
	bsr	showpointer

 lea scrolledlines,a0
 clr.b (a0)
* and what screen resolution are we in ?
 call_ebios _getrez ; move.w #4,-(sp)
 addq.l #2,sp
* d0.b = 0 - low resolution, 1 = medium resolution, 2 = high res
 lea screenresolution(pc),a0
 cmp.b #2,d0
 beq.s inithires1
 move.b #0,d0 ; always low res for graphics nowadays

inithires1
 move.b d0,(a0)

 lea screenheight(pc),a0
 move.w #absscreenheight,(a0)
 cmp.b #2,d0 ; hi-res ?
 rts
*---
init
* .initialise
* first, some general purpose initialisation ---

* bsr prs
* dc.b 27,'v' ; automatic overflow on
* dc.b 0
* even
 bsr jjsinit
 bsr init1
 ifd graphics
 bsr initialisetasks
; bsr seterrorvectors ; address error and bus error etc.
 endc ; graphics

 bsr init2
 movem.l d0-d7/a0-a6,-(sp)
 bsr InitScreenMode
 movem.l (sp)+,d0-d7/a0-a6
 ifd graphics
 cmp.b #2,d0
 bne initsplitscreen ; no, so set up med-low res split screen
 endc

 move.w #absscreenheight*2,(a0) ; hi-res height
initret
 rts
*---
*----------------------
seterrorvectors
* set up address error and bus error vectors
* to kill multi-tasking, then jump to os handler
* (or to a debugger if present)
* MUST BE IN SUPERVISOR MODE TO DO THIS

 lea hardwareerrorhandler,a0
 lea oshardwareerrorvectors,a1
 lea $8,a2 ; address of bus error vector (exception 2)
sev1
 move.l (a2),(a1)+
 move.l a0,(a2)+
 cmp.l #$18,a2
 bne.s sev1
 rts
*---
hardwareerrorhandler
* have got a hardware error, for some reason.
* kill multi-tasking and jump to os handler
* move.l d0,-(sp)
* move.l oshardwareerrorvectors,d0
* cmp.l #$18000,d0
* bls.s nodebugginginstalled
* move.l (sp)+,d0
* nasty kludge - always bus error handler:

 move.l oshardwareerrorvectors,-(sp)
 movem.l d0-d7/a0-a6,-(sp)
 bsr killmultitasking
 movem.l (sp)+,d0-d7/a0-a6
 rts ; enter monitor at previously set up return address

*nodebugginginstalled
* move.l (sp)+,d0
* rte
*---
oshardwareerrorvectors
 dc.l 0 ; bus error
 dc.l 0 ; address error
 dc.l 0 ; illegal instruction
 dc.l 0 ; division by zero (!)
 dc.l 0 ; one more for luck (chk instruction)
*---
*------------------------------
initgraphics
* have just switched to graphics mode from text mode
* (screen just cleared)
* set up anything necessary
* at present, just position cursor correctly for
* split screen useage
 lea drivergraphicsmode(pc),a0
 move.b #1,(a0)

	bsr	gotobot
	rts

gotobot
* move cursor to start of bottom line
 lea XCursorPos(PC),a0
 clr.w (a0)
 lea YCursorPos(PC),a0
 move.w #8,(a0)
**19/10/87	bsr	hidepointer
**18/10/87	disable_cursor
**19/10/87 move.b #27,d0
**19/10/87 bsr bdosout
**19/10/87 move.b #'Y',d0
**19/10/87 bsr bdosout ; position cursor
**19/10/87 move.b #32+24,d0
**19/10/87 bsr bdosout
**19/10/87 move.b #32+0,d0
**19/10/87 bsr bdosout ; line 24,column 0
**18/10/87	enable_cursor
**19/10/87	bsr	showpointer
	rts
sendesc
	move.w	d0,-(sp)
	bsr	hidepointer
**18/10/87	disable_cursor
	move.b #27,d0
	bsr bdosout
	move.w (sp)+,d0
	bsr bdosout
**18/10/87	enable_cursor
	bsr	showpointer
 rts
*---
calcchecksum
* calculate checksum of area between (a6).l and $4(a6).l
 move.l (a6),a0
 move.l $4(a6),a1
 sub.l a0,a1 ; get a1=length
 addq.l #1,a1
 move.w a1,d2 ; now d2=length
 move.b #0,d1 ; checksum value
checksum1
 tst.w d2 ; length
 beq.s checksumend
 move.b (a0)+,d0
 add.b d0,d1
 subq.w #1,d2 ; dec length
 bra.s checksum1

checksumend
 move.b d1,(a6)
 rts

*---
autorunsize equ 2000
autorun
* get instructions from disk file
* is there a command file in this directory on the disk?
 bsr prs
 dc.b cr,"Looking for gameplay log on disk - 'LOG.BAT'",cr,0
 even
 move.l a6,-(sp)
 lea logdriverblock,a6
; move.l screenpointer,a0
; sub.l #autorunsize,a0 ; !!!!!!!!??????
 lea AutoRunBlock,a0
 move.l a0,(a6) ; loading address
 move.b #loaddcode,d0
 bsr driver
 move.b (a6),d0
 bne autorunend ; not loaded, so ignore command to start fetching
 bsr prs
 dc.b cr,"Executing instructions in file 'LOG.BAT'",cr,0
 even
 move.l $4(a6),a0 ; end of batch file
 move.b #cr,(a0)+
 move.b #lf,(a0)+

 move.b #eof,(a0)+
 move.b #eof,(a0)+
 move.l (a6),a0
 lea batchptr,a1
 move.l a0,(a1) ; current batch pointer
 lea executingcommandfile,a0
 move.b #1,(a0)
autorunend
 move.l (sp)+,a6
 rts

ardelay
* do a two-second delay, then continue
 move.l #400000,d0
ard1
 subq.l #1,d0
 bne.s ard1
 bra.s bc1 ; get next character from command sequence

autorunagain
* reset batch pointer
;>>mike 23/2/88 move.l screenpointer,a0
;>>mike 23/2/88 sub.l #autorunsize,a0
 lea AutoRunBlock,a0
 lea batchptr,a1
 move.l a0,(a1)

autoruninputline
 lea scrolledlines,a0
 clr.b (a0) ; reset scrolled lines

 move.l batchptr,a0
* copy string into driverbuffer
 move.l a6,a1
bc1
 move.b (a0)+,d0
 cmp.b #lf,d0
 beq.s bc1 ; ignore line feeds
 cmp.b #cr,d0
 beq.s bc2
 cmp.b #eof,d0
 beq autorunagain
 cmp.b #"*",d0
 beq.s ardelay
 move.b d0,(a1)+
 bsr oswrch ; echo it
 bra.s bc1
bc2
* end of string, add terminator
 clr.b (a1)+
 lea batchptr,a1
 move.l a0,(a1)
 move.b #cr,d0
 bra oswrch ; cr at end of input
*---
getfilename
 cmp.b #0,$8(a6) ; check if filename was supplied
 bne gfret
 bsr prs
 dc.b cr,"Filename ? ",0
 even

 addq.l #8,a6 ; put filename at address expected file handling
 bsr inputline
 subq.l #8,a6 ; restore a6
gfret
 rts

driverloadfile
 bsr.s getfilename
* fall through to loadfile
loadfile
	move.w	thisdrive,d0
	cmp.w	#2,d0
	bcc 	loadfilenot_floppy

	addq.w	#1,suspendtaskswap
	move.w	#1,-(sp)
	move.w	#0,-(sp)
	move.w	#1,-(sp)
	move.w	#1,-(sp)
	move.w	thisdrive,-(sp)
	clr.l	-(sp)
	move.l	#thissect,-(sp)
	move.w	#8,-(sp) ; read sector
	trap	#14
	lea	20(sp),sp
 	subq.w	#1,suspendtaskswap
	tst.w	d0
	bne	readerror

loadfilenot_floppy
 bsr openrd
 tst.l d0
 bmi.s readerror
 bsr rdfile
 bsr closefile
 move.b #0,(a6) ; signify load ok
 rts

driversavefile
 bsr getfilename
* fall through to savefile
savefile
 bsr createfile
 tst.l d0
 bpl savefile2
* file does not exist, so have to separately open it
 bsr openwrt
 tst.l d0
 bmi.s writeerror
savefile2
 bsr wrtfile
 tst.l	d0 ; set up by WRTFILE
 bmi.s	writeerror
 bsr closefile
 move.b #0,(a6) ; signify save ok
 rts

readerror
 bsr prs
 dc.b "Read error. ",cr,0
 even
 move.b #1,(a6) ; signify load error
 rts

writeerror
 bsr prs
 dc.b "Save error. ",cr,0
 even
 move.b #1,(a6) ; signify save error
 rts

openrd
 move.w #0,-(sp) ; open for read
open1
 move.l a6,a0 ; a6 is buffer address
 addq.l #8,a0 ; a6 was still buffer address
 move.l a0,-(sp)
 call_bdos f_open
 move.w d0,d4 ; handle
 addq.l #8,sp
 rts

createfile
 move.w #0,-(sp) ; zero attributes for a normal file
 move.l a6,a0 ; buffer address
 addq.l #8,a0
 move.l a0,-(sp)
 call_bdos f_create
 move.w d0,d4 ; handle
 addq.l #8,sp
 rts

openwrt
 move.w #1,-(sp) ; open for write
 bra open1

rdfile
 move.l (a6),-(sp) ; address of where to put it
 move.l #$30000,-(sp) ; max length to read
 move.w d4,-(sp) ; handle(pc),-(sp)
 call_bdos f_read
 add.l #12,sp
 tst.l d0
 bmi readerror
* d0= number of bytes read
 add.l (a6),d0
 move.l d0,$4(a6) ; save end address

 rts

wrtfile
 move.l (a6),-(sp) ; pea buffer(pc) ; address of start of file
 move.l $4(a6),a1 ; end address
 sub.l (a6),a1 ; calc length
 move.l a1,-(sp) ; length
 move.w d4,-(sp) ; handle
 call_bdos f_write
 add.l #12,sp
;
;
;*--------------------
; NOTE... the error return from f_write is NOT in d0 as stated
; in ST INTERNALS.
; Instead, the OS returns d0.l as the length actually written
;*--------------------
;
;
; recalc length, then compare it with d0.l - the
; length the OS actually wrote.
;
 move.l $4(a6),a1 ; end address
 sub.l (a6),a1 ; calc length
 cmp.l a1,d0
 beq.s wrtfileok
 moveq.l #-1,d0 ; return standard error code - i.e. negative
wrtfileok
 rts

closefile
 move.w d4,-(sp) ; handle(pc),-(sp)
 call_bdos f_close
 addq.l #4,sp
 rts

*---

readhex
* given a hex string typed by the user at (a0),
* return d0.l = the equivalent value
* and a0.l = position after number
 movem.l d1-d7/a1-a6,-(sp)
 bsr absreadhex
 movem.l (sp)+,d1-d7/a1-a6
 rts
*---

absreadhex
 clr.l d0
readhex1
 move.l d0,-(sp)
 bsr.s readhexdigit
 move.l (sp)+,d0
 cmp.b #$ff,d1 ; finished ?
 beq.s readhexret
 asl.l #4,d0 ; shift existing digits along to make room
 add.b d1,d0
 bra.s readhex1

readhexdigit
* return in d1.b the value of the hex digit at (a0)
* or #$FF if none there
 move.b #$ff,d1 ; error return
 move.b (a0)+,d0
 bsr converttouppercase
 cmp.b #"0",d0
 bcs.s rhdret ; unsigned <, so return
 cmp.b #"9",d0
 bls.s rhdnumber ; unsigned <=
 cmp.b #"A",d0
 bcs.s rhdret ; unsigned <, so return
* got A-F
 sub.b #"A"-10,d0
 move.b d0,d1
readhexret
rhdret
 rts
rhdnumber
* got 0 - 9
 sub.b #"0",d0
 move.b d0,d1
 rts

*---

hexlonga0
 move.l a0,a2 ; preserve a0
 move.l a0,d0 ; transfer to data for shifts
 lsr.l #4,d0
 lsr.l #4,d0
 lsr.l #4,d0
 lsr.l #4,d0
 move.l d0,a0 ; and back again
 bsr hexworda0
 move.l a2,a0
* drop through to hexworda0

hexworda0
* print hex word in a0. a0 preserved, d0 corrupted
 move.w a0,d0
 lsr.w #8,d0
 bsr hexbyted0
 move.w a0,d0
* drop through to hexbyted0

hexbyted0
* print hex byte d0. d0 corrupted, other registers preserved
 move.b d0,-(sp)
 lsr.w #4,d0
 bsr printhexdigit
 move.b (sp)+,d0
 and #$0f,d0
* branch through to printhexdigit
 
printhexdigit
*given d0.b as a single digit, print it as hex
 movem.l d0-d7/a0-a6,-(sp)
 bsr absprinthexdigit
 movem.l (sp)+,d0-d7/a0-a6
 rts

absprinthexdigit
 and.l #$0000000f,d0 ; remove hi-order rubbish
 cmp.b #10,d0
 blt.s phdnum
 add #"A"-10,d0
 bra oswrch
phdnum
 add #"0",d0
 bra oswrch

printdecimald0
* print d0.l as a decimal number,
* suppressing leading zeros
 tst.l d0
 bne.s printdec1
 move.b #"0",d0
 bra printchar
printdec1
* non-zero number to print
 move.l d0,d2 ; store number somewhere more sensible
 lea numbertable(pc),a1
 move.b #0,d3 ; reset flag
printdec1a
* find the current digit value
 move.l (a1)+,d1 ; get value
 beq.s printdecret ; no more digits possible
* given d2=remainder of number, d1=value of current digit,
* find value
 move.b #"0",d0
printdec2
 sub.l d1,d2
 bcs.s printdec3
 addq.b #1,d0
 move.b #1,d3 ; set leading-zeros flag
 bra.s printdec2
printdec3
 add.l d1,d2
 tst.b d3 ; flag set yet ?
 beq.s printdec1a
 bsr printchar ; oswrch ; printchar
 bra.s printdec1a 

numbertable
 dc.l 1000000000
 dc.l 100000000
 dc.l 10000000
 dc.l 1000000
 dc.l 100000
 dc.l 10000
 dc.l 1000
 dc.l 100
 dc.l 10
 dc.l 1
 dc.l 0

driverprintchar
* very important note.
* this routine is provided so the printdecimal
* routine may run in the driver on its own
* or with new programs
* For the interpreter, and any other programs
* requiring word-wrap, it should be
* replaced with the appropriate routine using SET
* in the source of the other program
* this code should be left present

* note 2: At present SET is not supported
* by genst, Re-enable the label above when it is
 movem.l d0-d7/a0-a7,-(sp)
 bsr oswrch
 movem.l (sp)+,d0-d7/a0-a7
printdecret
readdecret
 rts

readdecimal
* given a decimal number as an ascii string at a0, return
* its value in d0.l
* and a0.l = charcter after the number
 clr.l d0
readdec1
 clr.w d1
 move.b (a0)+,d1
 cmp.b #"0",d1 ; could it be part of a number (stop if not)
 bcs.s readdecend
 cmp.b #"9"+1,d1
 bcc.s readdecend
 sub.b #"0",d1
* multiply existing number by 10 ( 32 bit so can't use mulu d2,d0)
 asl.l #1,d0 ; gives times 2
 move.l d0,-(sp)
 asl.l #2,d0 ; gives times 8
 add.l (sp)+,d0
 add.l d1,d0   ; and add in the new trailing digit
 bra.s readdec1
readdecend
 subq.l #1,a0
 rts
*---
*---
isd0alphanumeric
* return d0.b = 0 if not
 cmp.b #"0",d0
 bcs.s idanfail ; unsigned <
 cmp.b #"9",d0
 bls.s idanret ; unsigned <=
 cmp.b #"A",d0
 bcs.s idanfail ; unsigned <
* do "quick-and-dirty" lower-upper case conversion
 and.b #$DF,d0
 cmp.b #"Z",d0
 bhi.s idanfail ; unsigned >
idanret
 tst.b d0 ; non-zero
 rts
idanfail
 clr.b d0
 rts
*--- 

 
 even
prs
* print string following call, terminated by 0
 move.l a0,-(sp)
 move.l d0,-(sp)
 move.l $8(sp),a0 ; get return address = start address of string
prs1
 move.b (a0)+,d0 ; (a6)
 beq.s prsend
* move.b #oswrchdcode,d0
 bsr oswrch ; driver
 bra prs1
prsend
* make sure it is an even return address
 move.w a0,d0
 btst #0,d0
 beq.s prsend1
 addq.l #1,a0
prsend1
 move.l a0,$8(sp)
 move.l (sp)+,d0
 move.l (sp)+,a0
 rts
*---
addtoinputbuffer
* get a character from OS input char routine
* and stuff it into my own buffer
* this is only necessary because OS has a tendency
* to crash when the input buffer fills with multi-tasking
* going on ( I think it tries to sound a bell or something )

 bsr absgetcharfrombdos
* d0.b = character received
 tst.b d0
* beq.s addtoinputbuffer
 beq.s atibret

* escape pressed ?
 cmp.b #27,d0
 bne.s atibnotescape
* reset input buffer pointers, return zero
 lea driveribuffreadpos,a0
 clr.l (a0) ; 2 bytes each, reset both at once
 clr.b d0
 rts

atibnotescape 

 move.w driveribuffwritepos,d1
 addq.w #1,d1
 cmp.w driveribuffreadpos,d1
 beq.s atibfull
 subq.w #1,d1

 lea driveribuff,a0
 move.b d0,$0(a0,d1)
 addq.w #1,d1
 cmp.w #driveribuffsize,d1
 bne.s atib1
 move.w #0,d1
atib1
 lea driveribuffwritepos,a0
 move.w d1,(a0)
atibfull
atibret
 rts

getcharfromdriveribuff
osrdch
* return d0.b = char from buffer, or 0 if none waiting
 move.b executingcommandfile,d0 ;>>changed for GNOME.
 beq.s osrdchDemo
 clr.b d0
 rts

osrdchDemo
 bsr addtoinputbuffer
 clr.b d0
 move.w driveribuffreadpos,d1
 cmp.w driveribuffwritepos,d1
 beq.s gcfiret ; buffer empty

 lea driveribuff,a0
 move.b $0(a0,d1),d0
 addq.w #1,d1
 cmp.w #driveribuffsize,d1
 bne.s gcfi1
 move.w #0,d1
gcfi1
 lea driveribuffreadpos,a0
 move.w d1,(a0)
gcfiret
 rts


copytoback
	movem.l	a0-a1/d0,-(sp)
	move.l	this_screen,a0
	move.l	logpointer,a1
	move.l	#160*184,d0
	add.l	d0,a0
	add.l	d0,a1
	move.l	#15,d0
	bsr	copylines
	movem.l	(sp)+,a0-a1/d0
	rts

driveroswrch
 move.b (a6),d0
* fall through to oswrch
oswrch
* output character in d0 to screen
* I think all registers are preserved - please modify if not
 movem.l d0-d7/a0-a6,-(sp)
 move.l	d0,-(sp)
 bsr	hidepointer
 move.l	(sp)+,d0
 bsr oswrch1
 bsr	showpointer
 movem.l (sp)+,d0-d7/a0-a6
 rts

oswrch1
 cmp.b #pageoff,d0
 bne.s oswrchnopage
 lea pageingdisabled,a0
 move.b #1,(a0)
 rts

oswrchnopage
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 cmp.b #bs,d0
*>>19/10/87 beq oswrchbs
*>>19/10/87 cmp.b #' ',d0
*>>19/10/87 bcs.s oswrch2 ; unsigned <
*>>19/10/87 addq.b #1,(a0) ; inc cursorxpos
oswrch2
oswrch3
 cmp.b #crlf,d0
 bne absoswrch
*>>19/10/87 clr.b (a0) ; reset x pos
 bsr absoswrch ; print cr
 move.b #lf,d0
* drop through to absoswrch to print lf

absoswrch
 move.w d0,-(sp) ; preserve character just printed
 bsr addtoinputbuffer ; prevent OS crashing on buffer full
 move.w (sp)+,d0


; lea drivergraphicsmode(pc),a0
; tst.b (a0)
; beq absoswrch2
* handle split screen etc.
 cmp.b #lf,d0
 bne absoswrch2
* when in split screen mode, don't do line feeds - 
* just scroll up screen, leaving cursor where it is
*>>19/10/87 move.b cursorypos,d1
*>>19/10/87 cmp.b #24,d1
*>>19/10/87 beq.s dolinefeed
 LEA YCursorPos(PC),A0
 cmp.w #8,(a0)
 bls.s dolinefeed

* not on bottom line, so just move pointer
 subq.w #8,(a0)
 lea Xcursorpos,a0
 clr.w (a0)
 rts

dolinefeed
* on bottom line, so scroll screen
 movem.l d0-d7/a0-a6,-(sp)
 lea scrolldriverbuffer(pc),a6
* first turn off cursor
	bsr	hidepointer
**18/10/87	disable_cursor
	move.w	#1,suspendtaskswap
	bsr	copytoback
* now do the actual scroll
 move.l this_screen(pc),a0
 move.l a0,a1            
 move.l a0,a2
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s scrollhires
	clr.w	d0
	tst.b	drivergraphicsmode
	beq.s	loresall
 	move.w	picy,d0		* find the bottom of graphics window
	mulu.w	#160,d0		
loresall
	add.w	d0,a0
	add.w	d0,a1
	add.w	#160*8,a1
 move.b YScale,d0
 beq.s loresall1
 add.w #160*8,a1 * scroll 16 pels
loresall1
* calculate length to scroll in d0.w
	add.l	#200*160,a2 	* get end of screen
	sub.l	a0,a2 		* subtract start of text window
	move.w	a2,d0 		* length of text window
	sub.w	#160*8-160,d0	* subtract one text line
 move.b YScale,d1
 beq.s scroll1
 sub.w #160*8,d0 * subtract another text line for 16 pel high
	bra.s scroll1

scrollhires
	clr.w	d0
	tst.b	drivergraphicsmode
	beq.s	hiresall
	move.w	picy,d0		* find the bottom of graphics window
	mulu.w	#80,d0		
hiresall
	add.w	d0,a0
	add.w	d0,a1
	add.w	#160*8,a1
 move.b YScale,d0
 bne.s hiresall1
 sub.w #80*8,a1 * only scroll 8 pels when height not doubled
hiresall1
* calculate length to scroll
	add.l	#200*160,a2 	* get end of screen
	sub.l	a0,a2 		* subtract start of text window
	move.w	a2,d0 		* length of text window
 move.b YScale,d1
 bne.s scroll1High
* 8 pixel char
	sub.w	#80*8-80,d0	* subtract one text line
	bra.s scroll1

scroll1High
* 16 pixel high char
	sub.w	#160*8-160,d0	* subtract one text line
scroll1
	lsr.w	#2,d0 * convert length to longs
	sub.w	#1,d0
scroll1b
	move.l (a1)+,(a0)+
	dbra	d0,scroll1b
	move.l	this_screen,a0
* and clear bottom line...
 move.b YScale(PC),d0
 bne.s scroll1bHigh
* characters 8 pixels high
 move.b ScreenResolution,d0
 cmp.b #2,d0
 beq.s scroll1bhires
	add.l	#192*160,a0
* colour lines are wider
	clr.l	d0
	move.w	#319,d1
	bra.s scroll2

scroll1bhires
	add.l	#196*160,a0
	clr.l	d0
	move.w	#159,d1
	bra.s scroll2

scroll1bHigh
* characters 16 pixels high
 move.b ScreenResolution,d0
 cmp.b #2,d0
 beq.s Scroll1bHighHires
* colour...
	add.l	#184*160,a0
	clr.l	d0
	move.w	#639,d1
	bra.s	scroll2

Scroll1bHighHires
	add.l	#384*80,a0
	clr.l	d0
	move.w	#319,d1
scroll2
	move.l d0,(a0)+
	dbra	d1,scroll2	
* now scroll the logical screen
* first copy the information over
	move.l	logpointer,a1
	move.l	a1,a0
 move.b YScale(PC),d0
 bne.s Scroll2High
* 8 pixel high chars
 move.b ScreenResolution,d0
 cmp.b #2,d0
 beq.s Scroll28Hires
* colour mode...
	add.l	#160*8,a0
	move.w	#191,d0
	bsr	copylines
* and now blank out bottom line
	move.l	logpointer,a1
	add.l	#192*160,a1
	clr.l	d0
	move.w	#159,d1
	bra.s scroll2a

Scroll28Hires
	add.l	#80*8,a0
	move.w	#391,d0
	bsr	copylines
* and now blank out bottom line
	move.l	logpointer,a1
	add.l	#196*160,a1
	clr.l	d0
	move.w	#159,d1
	bra.s scroll2a

Scroll2High
* 16 pixel high chars
 move.b ScreenResolution,d0
 cmp.b #2,d0
 beq.s Scroll2HighHires
* colour....
	add.l	#320*8,a0
	move.w	#191,d0
	bsr	copylines
	
* and now blank out bottom line
	move.l	logpointer,a1
	add.l	#184*160,a1
	clr.l	d0
	move.w	#639,d1
	bra.s	scroll2a

Scroll2HighHires
	add.l	#160*8,a0
	move.w	#191,d0
	bsr	copylines
	
* and now blank out bottom line
	move.l	logpointer,a1
	add.l	#192*160,a1
	clr.l	d0
	move.w	#319,d1
scroll2a
	move.l	d0,(a1)+
	dbra	d1,scroll2a	
	clr.w	suspendtaskswap
**18/10/87	enable_cursor
	bsr	showpointer
	movem.l (sp)+,d0-d7/a0-a6

afterlinefeed
* and finally, if have scrolled a complete screen since
* the last input, print '<more>' and wait for a key to enter
* the keyboard buffer
 move.b pageingdisabled,d0
 bne scrollnowait

 lea scrolledlines,a0
 addq.b #1,(a0)
; move.b drivergraphicsmode,d0
; beq.s scrolllinestext
; cmp.b #12,(a0) ; fewer lines available in graphics mode
; bne.s scrollnowait
; bra.s scrollwait

scrolllinestext
 move.b	linestoscroll,d0

 move.b ScreenResolution,d1
 cmp.b #2,d1
 beq.s ScrollLinesTextHires
* in colour mode, YSCALE=1 allows half as many lines to be printed
* before pausing
 move.b YScale,d1
 beq.s ScrollLinesText2
 lsr.b #1,d0
 subq.b #1,d0
 bra.s ScrollLinesText2

ScrollLinesTextHires
* in hires mono mode, YSCALE=0 allows twice as many lines to be printed
* before pausing
 move.b YScale,d1
 bne.s scrollLinesText2
 asl.b #1,d0

scrollLinesText2
 cmp.b (a0),d0 ; lots of lines in text mode
 bcc scrollnowait

 move.w driveribuffreadpos,d1
 cmp.w driveribuffwritepos,d1
 bne scrollnowait ; buffer not empty dont wait

scrollwait
 bsr prs
 dc.b "<More>",0
 even
**19/10/87 lea cursorxpos,a0
**19/10/87 clr.b (a0) ; make it think we're still at start of line
; check for character waiting
 bsr	showpointer


 move.b executingcommandfile,d0 ;>>changed for GNOME.
 beq.s scrollwaitkey
; whilst executing batch file, do 10 second delay.
 move.l #300,d0
scrollWaitDelay
 bsr snooze
 sub.l #1,d0
 bne.s scrollwaitDelay
 bra.s scrollend

scrollwaitkey
	bsr	snooze
	move.w	#2,-(sp)
	call_bios	1
	addq.l	#4,sp
	tst.l	d0
	beq.s	scrollwaitkey
; found a character so throw it away
	move.w	#2,-(sp)
	call_bios	2
	addq.l	#4,sp
scrollend
	bsr	hidepointer
* reset number of lines scrolled since last input
 lea scrolledlines,a0
 clr.b (a0)
* and delete the <more> message
* position cursor at start of line ....
	bsr	gotobot
* and delete to end of screen ....
**19/10/87 move.b #'J',d0
**19/10/87 bsr	sendesc
 bsr prs
 dc.b "           ",0
 even
 bsr gotobot * position cursor at start of line again

scrollnowait
 rts
*---
absoswrch2
 bsr bdososwrch
*>>19/10/87 cmp.b #32,d0
*>>19/10/87 bcs.s absoswrch3
*>>19/10/87 move.b cursorxpos,d1
*>>19/10/87 cmp.b #80,d1
*>>19/10/87 bne.s absoswrch3
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 clr.b (a0)
*>>19/10/87 move.b #cr,d0
*>>19/10/87 bsr absoswrch
*>>19/10/87 move.b #lf,d0
*>>19/10/87 bsr absoswrch
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 clr.b (a0)
*>>19/10/87 bra afterlinefeed
absoswrch3
* move.w d0,-(sp) ; preserve character just printed
* bsr addtoinputbuffer ; prevent OS crashing on buffer full
* move.w (sp)+,d0
 cmp.b #lf,d0
 beq afterlinefeed
 rts


bdosout
 move.l a0,-(sp)
 move.w d0,-(sp) ; this is argument for routine as well as preservation
 call_bdos c_conout
 addq.l #2,sp ; remove function call number etc.
	move.w	(sp)+,d0
	move.l	(sp)+,a0
	rts	

bdososwrch
* print d0.b using OS
* now print it (using os at present)
; cmp.w #13,d0
; beq.s bdososwrchok
; cmp.w #10,d0
; beq.s bdososwrchok
; cmp.w #' ',d0 ; ??? printing only
; bcs.s bdososwrchret ; ??? printing ONLY
;bdososwrchok
;
	movem.l	d0-d2/a0-a2,-(sp)
	bsr	hidepointer
	movem.l	(sp)+,d0-d2/a0-a2



	move.l a0,-(sp)
	move.w d0,-(sp) ; this is argument for routine as well as preservation
;**	call_bdos c_conout
;**	addq.l #2,sp ; remove function call number etc.
 bsr OswrchD0



;	bsr	copytoback
	move.w	(sp)+,d0
 	move.l (sp)+,a0

	movem.l	d0-d2/a0-a2,-(sp)
	bsr	showpointer
	movem.l	(sp)+,d0-d2/a0-a2
	rts
*---
*--------------------------

*--------------
WaitKeyFlashCursor

FastOsrdch
* ++ Cursor ON Phase
* Add a cursor
 BSR InvertCursor
 MOVE.L #$28,D1
 add.l realtimeclock(pc),d1
FastOsrdch1
 MOVEM.L d1-d7/a0-a6,-(sp)
 BSR Osrdch
 MOVEM.L (sp)+,d1-d7/a0-a6
 TST.B D0
 BNE InvertCursor * turn off,ret
 bsr snooze
 move.l realtimeclock(pc),d0
 cmp.l d1,d0
 ble.s FastOsrdch1


* ++ Cursor OFF Phase
* Remove a cursor
 BSR InvertCursor
 MOVE.W #$28,D1
 add.l realtimeclock(pc),d1
FastOsrdch2
 MOVEM.L d1-d7/a0-a6,-(sp)
 BSR Osrdch
 MOVEM.L (sp)+,d1-d7/a0-a6
 TST.B D0
 BNE.S FastOsrdchRet
 bsr snooze
 move.l realtimeclock(pc),d0
 cmp.l d1,d0
 ble.s FastOsrdch2
 BRA.S FastOsrdch

FastOsrdchRet
 RTS
*-------------

*-----------
HInvertCursor
* preserves d0.b!
 MOVE.W D0,-(SP)
 bsr HidePointer
 BSR HCalcCurrentCharAddress
 CLR.W D0
 MOVE.B CharHeight(PC),D0
 MOVE.B YScale(PC),D1
 BEQ.S HInvertCursor1a
 ADD.B D0,D0 * DOuble cursor height

HInvertCursor1a
 CLR.L D1
 MOVE.B BytesPerScreenLine(PC),D1
HInvertCursor1
 EOR.B #$FF,(A0)
 MOVE.B XScale(PC),D2
 BEQ.S HInvertCursor2
 EOR.B #$FF,$1(A0)

HInvertCursor2

 ADD.L D1,A0
 DBRA D0,HInvertCursor1
 bsr ShowPointer
 MOVE.W (SP)+,D0
 RTS
*----------
*GInpt
* LEA GInptDriverBuffer(PC),A6
* MOVE.L A6,A5
* ADD.L #8,A5
* MOVE.L A5,A4 * a4 stays as base
*
*GInpt1
* MOVEM.L A0-A6,-(SP)
* BSR FastOsrdch
* MOVEM.L (SP)+,A0-A6
* CMP.B #quitkey,D0
* BEQ GInptRet **
* CMP.B #13,D0
* BEQ.S GInptEcho **
* CMP.B #10,D0
* BEQ.S GInptEcho **
*
* CMP.B #8,D0
* BNE.S GInptNotBS
** Backspace.
** Anything in buffer?
* CMP.L A4,A5
* BEQ.S GInpt1 * no - ignore
** yes - delete char from buffer
* SUBQ.L #1,A5
** and echo BS
*GInptEcho
* BSR OswrchD0
* BRA GInpt1
*
*GInptNotBS
* CMP.B #cursorleft,D0
* BNE.S GInptNotLeft
** Anything in buffer?
* CMP.L A4,A5
* BEQ.S GInpt1 * no - ignore
** yes - move cursor to left
* BSR RetreatCursor
* BRA GInpt1
*
*GInptNotLeft
* CMP.B #cursorright,D0
* BNE.S GInptNotRight
** At end of buffer yet?
* BSR AdvanceCursor
* BRA GInpt1
*
*GInptNotRight
* CMP.B 40,d0 * #ASC"(",D0
* BNE.S GInptNotToggleWidth
** Get Clear of the old stuff
* MOVE.B #13,D0
* BSR OswrchD0
* MOVE.B #10,D0
* BSR OswrchD0
** and change the size.
* LEA XScale(PC),A0
* EOR.B #1,(A0)
* BSR InitFont
* BRA GInpt1
*
*GInptNotToggleWidth
* CMP.B 41,d0 * #ASC")",D0
* BNE.S GInptNotToggleHeight
** Get clear of the old stuff
* MOVE.B #13,D0
* BSR OswrchD0
* MOVE.B #10,D0
* BSR OswrchD0
** and change the size
* LEA YScale(PC),A0
* EOR.B #1,(A0)
* BSR InitFont
* BRA GInpt
*
*GInptNotToggleHeight
** And things which advance the
** cursor...check for buffer full
* MOVE.L A5,A3
* SUB.L A4,A3
* CMP.W #500,A3
* BHI GInpt1
*
** other control codes are ignored
* CMP.B #31,D0
* BLS GInpt1
** as are >127
* CMP.B #127,D0
* BGT GInpt1
*
** Seems valid, write it to buffer.
* MOVE.B D0,(A5)+
* BSR OswrchD0
* BRA GInpt1
*
*GInptRet
* RTS
**--------------
*SpeedTest EVEN
** MOVE.W #20,D2
*
*SpeedTest0
* BSR InitScreenMode
* MOVE.W #100,D1
*SpeedTest1 EVEN
* MOVE.B #65,D0
*
** And offset alternate frames
* BTST.B #0,D2
* BEQ.S SpeedTest2
* ADDQ.B #1,D0
*SpeedTest2 EVEN
* MOVEM.W D0-D2,-(SP)
* BSR OswrchD0
* MOVEM.W (SP)+,D0-D2
* ADDQ.B #1,D0
* CMP.B #128,D0
* BLS.S SpeedTest2
* DBRA D1,SpeedTest1
** DBRA D2,SpeedTest0
* RTS
*-------
CalcCurrentCharAddress
 MOVE.B ScreenResolution(PC),D0
 CMP.B #2,D0
 BEQ HCalcCurrentCharAddress
 BRA CCalcCurrentCharAddress
*-------------------------------
AdvanceCursor
 MOVE.B ScreenResolution(PC),D0
 CMP.B #2,D0
 BEQ HAdvanceCursor
 BRA CAdvanceCursor
*--------
RetreatCursor
 MOVE.B ScreenResolution(PC),D0
 CMP.B #2,D0
 BEQ HRetreatCursor
 BRA CRetreatCursor
*-------
InvertCursor
 MOVE.B ScreenResolution(PC),D1
 CMP.B #2,D1
 BEQ HInvertCursor
 BRA CInvertCursor
*-------
InitScreenMode
* First load the font!
 lea FontSpace,a0
* lea LoadFontDriverBlock(PC),a6
* move.l a0,(A6)
* move.b #loaddcode,d0
* bsr driver
* move.l (a6),a0
* add.l #$e,a0
 lea FontAddress(PC),a1
 move.l a0,(a1)

* by default, use smallest possible text.
 lea XScale(PC),a0
 clr.b (a0)
 lea YScale(PC),a0
 clr.b (a0)

 MOVE.B ScreenResolution(PC),D1
 CMP.B #2,D1
 BEQ HInitScreenMode
 BRA CInitScreenMode
*-------
InitFont
 MOVE.B ScreenResolution(PC),D1
 CMP.B #2,D1
 BEQ HInitFont
 BRA CInitFont
*------
OswrchD0
 MOVE.B ScreenResolution(PC),D1
 CMP.B #2,D1
 BEQ HOswrchD0
 BRA COswrchD0
*-------
FastOswrch
 MOVE.B ScreenResolution(PC),D0
 CMP.B #2,D0
 BNE COswrch
*
HOswrch
 MOVE.B CharToDraw(PC),D0
HOswrchD0
 CMP.B #13,D0
 BNE.S HOswrchNotCR
 LEA XCursorPos(PC),A0
 CLR.W (A0)
 RTS

HOswrchNotCR EVEN
* CMP.B #10,D0
* BEQ HScrollScreen

HOswrchNotLF EVEN
 CMP.B #8,D0
 BNE.S HOswrchNotBS
 BSR HRetreatCursor
 MOVE.B #32,D0
 BRA HDrawCharD0

HOswrchNotBS EVEN
 CMP.B #32,D0
 BLT.S HOswrchRet
 BSR HDrawCharD0
 BSR HAdvanceCursor
HOswrchRet EVEN
 RTS
*--------
HCalcCurrentCharAddress EVEN
* calculate the memory address of the current cursor position
 move.l screenpointer(PC),a0
 CLR.L D0
 CLR.L D1
 MOVE.W YScreenSize(PC),D0
 SUB.W YCursorPos(PC),D0
* each LINE is 80 pels
 MOVE.B YScale(PC),D1
 BEQ.S HCalcNormalY
 MOVE.W #160,D1
 BRA.S HCalc2

HCalcNormalY EVEN
 MOVE.W #80,D1

HCalc2 EVEN
 MULU D0,D1
 ADD.L D1,A0
 CLR.L D0
 MOVE.B XScale(PC),D0
 BEQ.S HCalcNormal
* Calc for wide chars
 MOVE.W XCursorPos(PC),D0
 LSR.W #2,D0 * 8 pixels per byte
 ADD.L D0,A0
 RTS

HCalcNormal
 MOVE.W XCursorPos(PC),D0
 LSR.W #3,D0 * 8 pixels per byte
 ADD.L D0,A0
 RTS
*---------
HDrawChar EVEN
 MOVE.B CharToDraw(PC),D0

HDrawCharD0 EVEN
*Calculate the address of the font for this char
 CLR.L D1
 MOVE.B D0,D1
 SUB.W #32,D1 * min. char in font
 ASL.W #3,D1 * times 8
* LEA FontSpace(PC),A2
 move.l FontAddress(PC),a2
 ADD.L D1,A2
*
 BSR HCalcCurrentCharAddress
* Now A0.l is address of top left of char.
* and A2.l is address of character pattern

 MOVE.B XScale(PC),D1
 BEQ.S HDrawChar8Wide
HDrawChar16Wide
 MOVE.W #7,D1

HDrawCharLoop EVEN
 MOVE.B (A2)+,D0
* now double every pixel
 CLR.W D2
* assmble the doubled word in D2.w
 MOVE.W #6,D3
HDouble0
 TST.B D0
 BPL.S HDouble1
 OR.W #3,D2

HDouble1
 ROL.B #1,D0
 ROL.W #2,D2
 DBRA D3,HDouble0

* MOVE.b (A2)+,(A0)
 MOVE.W D2,(A0)
 ADD.L #80,A0
 MOVE.B YScale(PC),D3
 BEQ.S HDouble2
 MOVE.W D2,(A0)
 ADD.L #80,A0

HDouble2
 DBRA D1,HDrawCharLoop
 RTS



HDrawChar8Wide
 MOVE.W #7,D1
HDrawChar8Loop EVEN
 MOVE.B (A2),(A0)
 ADD.L #80,A0
 MOVE.B YScale(PC),D3
 BEQ.S HDrawChar2
 MOVE.B (A2),(A0)
 ADD.L #80,A0

HDrawChar2
 ADD.L #1,A2
 DBRA D1,HDrawChar8Loop
 RTS

*---------
HAdvanceCursor
 LEA XCursorPos(PC),A0
 ADDQ.W #8,(A0)
 MOVE.W (A0),D0
 CMP.W XScreenSize(PC),D0
 BLT.S HAdvanceRet
 CLR.W (A0)
 LEA YCursorPos(PC),A0
 CMP.W #8,(A0)
 BLS.S HScrollScreen
 SUB.W #8,(A0)

HAdvanceRet
 RTS
*-------
HRetreatCursor
 LEA XCursorPos(PC),A0
 SUBQ.W #8,(A0)
 MOVE.W (A0),D0
 BPL.S HRetreatRet
 MOVE.W XScreenSize(PC),(A0)
 SUBQ.W #8,(A0)
 LEA YCursorPos(PC),A0
 ADD.W #8,(A0)

HRetreatRet
 RTS
*----------

HScrollScreen
* And scroll screen...
 movem.l d0-d7/a0-a6,-(sp)
 move.b #cr,d0
 bsr absoswrch
 move.b #lf,d0
 bsr absoswrch
 movem.l (sp)+,d0-d7/a0-a6
 rts


* MOVE.B YScale(PC),D0
* BEQ.S HScrollScreen8
* BSR HScrollScreen8
** and drop through to scroll
** another 8 pels for high
** characters.
*
*
*HScrollScreen8
** And scroll screen...
* MOVE.L this_screen(PC),A0
* MOVE.L A0,A1
* ADD.L #640,A1
*
* MOVE.W #392,D0 * lines to scroll
*
*HScrollScreen1 EVEN
*
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
*
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
* MOVE.L (A1)+,(A0)+
*
* DBRA D0,HScrollScreen1
*
* MOVE.W #640,D1
*HScrollScreen2
* MOVE.L #0,(A0)+
* DBRA D1,HScrollScreen2
* RTS

*-----------
HInitScreenMode
 lea YScale(PC),a0
 move.b #1,(a0) * 16 pixel high by default
 MOVE.L this_screen(PC),a0
 MOVE.W #400,D0 * lines to clear

HInitScreen1 EVEN

 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+

 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 MOVE.L #0,(A0)+
 DBRA D0,HInitScreen1

HInitFont
 LEA XCursorPos(PC),A0
 MOVE.W #0,(A0)
 LEA YCursorPos(PC),A0
 MOVE.W #8,(A0)

 LEA XScreenSize(PC),A0
 MOVE.W #640,(A0)
 MOVE.B XScale(PC),D0
 BEQ.S HInitScreen2
 MOVE.W #320,(A0)
HInitScreen2 EVEN

 LEA YScreenSize(PC),A0
 MOVE.W #400,(A0) * whole physical screen, regardless of split etc.
 MOVE.B YScale(PC),D0
 BEQ.S HInitScreen3
 MOVE.W #200,(A0)

HInitScreen3 EVEN
 lea CharHeight(PC),a0
 move.b #8,(a0)

HInitScreen4
 lea BytesPerScreenLine(PC),a0
 move.b #80,(a0)
 RTS
*-------------------------------
CInvertCursor
* preserves d0.b!
 MOVE.W D0,-(SP)
 bsr HidePointer
 BSR CCalcCurrentCharAddress
 CLR.W D0
 MOVE.B CharHeight(PC),D0
 MOVE.B YScale(PC),D1
 BEQ.S CInvertCursor1a
 ADD.B D0,D0 * DOuble cursor height

CInvertCursor1a
 CLR.L D1
 MOVE.B BytesPerScreenLine(PC),D1
CInvertCursor1
 EOR.b #$FF,(A0)
 eor.b #$ff,2(a0)
 MOVE.B XScale(PC),D2
 BEQ.S CInvertCursor2
 EOR.B #$FF,$1(A0)
 eor.b #$ff,$3(a0)

CInvertCursor2
 ADD.L D1,A0
 DBRA D0,CInvertCursor1
 bsr ShowPointer
 MOVE.W (SP)+,D0
 RTS
*-------
COswrch
 MOVE.B CharToDraw(PC),D0
COswrchD0
 CMP.B #13,D0
 BNE.S COswrchNotCR
 LEA XCursorPos(PC),A0
 CLR.W (A0)
 RTS

COswrchNotCR EVEN
 CMP.B #10,D0
 BEQ CScrollScreen

COswrchNotLF EVEN
 CMP.B #8,D0
 BNE.S COswrchNotBS
 BSR CRetreatCursor
 MOVE.B #32,D0
 BRA CDrawCharD0

COswrchNotBS EVEN
 CMP.B #32,D0
 BLT.S COswrchRet
 BSR CDrawCharD0
 BSR CAdvanceCursor
COswrchRet EVEN
 RTS
*--------
CCalcCurrentCharAddress EVEN
* calculate the memory address of the current cursor position
 MOVE.L this_screen(PC),a0
 CLR.L D0
 CLR.L D1
 MOVE.W YScreenSize(PC),D0
 SUB.W YCursorPos(PC),D0
* each LINE is 160 pels
 MOVE.B YScale(PC),D1
 BEQ.S CCalcNormalY
 MOVE.W #320,D1
 BRA.S CCalc2

CCalcNormalY EVEN
 MOVE.W #160,D1
CCalc2
 MULU D0,D1
 ADD.L D1,A0
 CLR.L D0
 MOVE.W XCursorPos(PC),D0
* LSR.W #3,D0 * 8 pixels per byte
*\ AND.W #$FE,D0
*\ ASL.W #2,D0
 MOVE.B XScale(PC),D1
 ASL.W D1,D0 * shift by XScale
 LSR.W #3,D0
 AND.W #$FE,D0
 ASL.W #1,D0
 ADD.L D0,A0
 MOVE.W XCursorPos(PC),D0
 ASL.W D1,D0 * shift by XScale
 BTST #3,D0
 BEQ.S CDC1
 ADDQ.L #1,A0

CDC1
 RTS
*---------
CDrawChar EVEN
 MOVE.B CharToDraw(PC),D0

CDrawCharD0 EVEN
*Calculate the address of the font for this char
 CLR.L D1
 MOVE.B D0,D1
 SUB.W #32,D1 * min. char in font
 ASL.W #3,D1 * times 8
* LEA FontSpace(PC),A2
 move.l FontAddress(PC),a2
 ADD.L D1,A2
*
 BSR CCalcCurrentCharAddress
* Now A0.l is address of top left of char.
* and A2.l is address of character pattern

 MOVE.B XScale(PC),D1
 BEQ.S CDrawChar8Wide
CDrawChar16Wide
 MOVE.W #7,D1
CDrawCharLoop EVEN
 MOVE.B (A2)+,D0
* now double every pixel
 CLR.W D2
* assmble the doubled word in D2.w
 MOVE.W #6,D3
CDouble0
 TST.B D0
 BPL.S CDouble1
 OR.W #3,D2

CDouble1
 ROL.B #1,D0
 ROL.W #2,D2
 DBRA D3,CDouble0

 MOVE.W D2,(A0)
 move.w d2,2(a0)
 ADD.L #160,A0
 MOVE.B YScale(PC),D3
 BEQ.S CDouble2
 MOVE.W D2,(A0)
 move.w d2,2(a0)
 ADD.L #160,A0

CDouble2
 DBRA D1,CDrawCharLoop
 RTS

CDrawChar8Wide
 MOVE.W #7,D1
CDrawChar8Loop EVEN
 MOVE.B (A2),(A0)
 move.b (a2),2(a0)
 ADD.L #160,A0
 MOVE.B YScale(PC),D3
 BEQ.S CDraw2
 MOVE.B (A2),(A0)
 move.b (a2),2(a0)
 ADD.L #160,A0

CDraw2
 ADD.L #1,A2
 DBRA D1,CDrawChar8Loop
 RTS

*---------
CAdvanceCursor
 LEA XCursorPos(PC),A0
 ADDQ.W #8,(A0)
 MOVE.W (A0),D0
 CMP.W XScreenSize(PC),D0
 BLT.S CAdvanceRet
 CLR.W (A0)
 LEA YCursorPos(PC),A0
 CMP.W #8,(A0)
 BLS.S CScrollScreen
 SUB.W #8,(A0)

CAdvanceRet
 RTS
*-------
CRetreatCursor
 LEA XCursorPos(PC),A0
 SUBQ.W #8,(A0)
 MOVE.W (A0),D0
 BPL.S CRetreatRet
 MOVE.W XScreenSize(PC),(A0)
 SUBQ.W #8,(A0)
 LEA YCursorPos(PC),A0
 ADD.W #8,(A0)

CRetreatRet
 RTS
*----------

CScrollScreen
* And scroll screen...
 movem.l d0-d7/a0-a6,-(sp)
 move.b #cr,d0
 bsr absoswrch
 move.b #lf,d0
 bsr absoswrch
 movem.l (sp)+,d0-d7/a0-a6
 rts



* MOVE.B YScale(PC),D0
* BEQ.S CScrollScreen8
* BSR CScrollScreen8
** and drop through to scroll
** another 8 pels for high
** characters.

*CScrollScreen8
 bra dolinefeed

 MOVE.L this_screen(PC),A0
 MOVE.L A0,A1
 ADD.L #1280,A1

 MOVE.W #192,D0 * lines to scroll

CScrollScreen1 EVEN

 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+

 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+

 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+

 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+
 MOVE.L (A1)+,(A0)+

 DBRA D0,CScrollScreen1

 MOVE.W #1280,D1
CScrollScreen2
 MOVE.L #0,(A0)+
 DBRA D1,CScrollScreen2
 RTS

*-----------
CInitScreenMode
 lea YScale(PC),a0
 clr.b (a0)
 MOVE.L this_screen(PC),A0
 MOVE.W #400,D0 * lines to clear
* actually 200 lines of
* 160 rather than 400 of
* 80, but who's counting?
CInitScreen1 EVEN

 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+

 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+
 move.l #0,(A0)+

 DBRA D0,CInitScreen1

CInitFont
 LEA XCursorPos(PC),A0
 MOVE.W #0,(A0)
 LEA YCursorPos(PC),A0
 MOVE.W #8,(A0)
 LEA XScreenSize(PC),A0
 MOVE.W #640,(A0)
 MOVE.B XScale(PC),D0
 BEQ.S CInit1
 MOVE.W #320,(A0)

CInit1
 LEA YScreenSize(PC),A0
 MOVE.W #200,(A0) * whole physical screen, regardless of split etc.
 MOVE.B YScale(PC),D0
 BEQ.S CInit2
 MOVE.W #100,(A0)
CInit2
CInitScreen3 EVEN
 lea CharHeight(PC),a0
 move.b #8,(a0)

CInitScreen4
 lea BytesPerScreenLine(PC),a0
 move.b #160,(a0)
 RTS

XCursorPos DS.W 1 * gives x cursor pos. 0 is leftmost column
YCursorPos DS.W 1 * gives y cursor pos. 0 is bottom row
XScreenSize DS.W 1
YScreenSize DS.W 1 * whole physical screen, regardless of split etc.
 EVEN

CharToDraw DS.W 1
BytesPerScreenLine DS.W 1
CharHeight DS.B 1
BytesPerLine DS.B 1
MinChar DS.B 1
MaxChar DS.B 1
NumChars DS.B 1
XScale DS.B 1
YScale DS.B 1

 EVEN
Debug1 DS.L 1
Debug2 DS.L 1
Debug3 DS.L 1

 EVEN
*----------------------
*>>19/10/87oswrchbs
*>>19/10/87 bra bdososwrch
* (a0).b is cursorxpos
*>>19/10/87 subq.b #1,(a0)
*>>19/10/87 bpl bdososwrch ; nothing special on this occasion
*>>19/10/87 move.b cursorypos,d0
*>>19/10/87 cmp.b #16,d0
*>>19/10/87 beq oswrchbserror
* we are going to move backwards from the start of one line
* to the beginning of the previous one
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 move.b #70,(a0) ; allow plenty of space for positioning commands
* doing backspace at start of line - want to wrap round
* to end of previous line
*
* at present - just position cursor at end of line 23
*>>19/10/87 lea cursorypos,a0
*>>19/10/87 subq.b #1,(a0) ; decrement y pos
*>>19/10/87 move.b #27,d0
*>>19/10/87 bsr bdosout
*>>19/10/87 move.b #'Y',d0
*>>19/10/87 bsr bdosout
*>>19/10/87 move.b (a0),d0 ; y pos
*>>19/10/87 add.b #32,d0 ; for benefit of vt52 emulator
*>>19/10/87 bsr bdosout ; print it
*>>19/10/87 move.b #32+79,d0 ; x pos
*>>19/10/87 bsr bdosout
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 move.b #79,(a0) ; reset because cursor pos command changes pos
*>>19/10/87 move.b #" ",d0 ; delete existing char in last column
*>>19/10/87* (no overflow in operation, so cursor will not move)
*>>19/10/87 bra bdososwrch
* rts
*---
*>>19/10/87oswrchbserror
* can't go any further
*>>19/10/87 move.b #7,d0 ; sound a bell
*>>19/10/87 bsr oswrch
*>>19/10/87 lea cursorxpos,a0
*>>19/10/87 addq.b #1,(a0)
*>>19/10/87 rts
*---
protectedoswrch
* given single character in d0. If invalid, print a dot
 cmp.b #32,d0
 bge oswrch
 move.b #".",d0
 bra oswrch
*---
initinputline
 clr.l (a6) ; destroy any left-overs
 lea currentlineoffset(pc),a0
 clr.w (a0) ; editing current line
 clr.w ilhighwater ; characters in buffer
 clr.w d4
 lea scrolledlines,a0
 clr.b (a0)
 rts
*---
*startlog
** write all commands into a file log from now on
* lea logdriverblock,a6
* bra inputline

startautorunning
 bsr autorun

driverinputline
 move.b executingcommandfile,d0
 bne autoruninputline

inputline
 bsr initinputline
* clr.l (a6) ; destroy any left-overs
* lea currentlineoffset(pc),a0
* clr.w (a0) ; editing current line
* move.w #0,ilhighwater ; characters in buffer

inputline0
* input a string into memory
* starting at a6.l
* terminated by 0
 move.w #0,ilpos
inputline1
 move.w #148,ilsize ; think before making it larger (about editing)
 movem.l d1-d7/a0-a6,-(sp)
 bsr WaitKeyFlashCursor
 movem.l (sp)+,d1-d7/a0-a6
 bsr Snooze

* bsr osrdch
* tst.b d0
* beq.s inputline1
 cmp.b #3,d0
 beq.s tryclose
 cmp.b #quitkey,d0
 bne notclosedown
tryclose
 bsr closedown
 clr.w ilpos ; display from current pos to end
 bsr displayinputline
 bra inputline1

notclosedown
 cmp.b #helpkey,d0
 bne.s nothelp
* put 'help. credits.' into input line buffer
 lea helptext,a0
returnfixedstring
 clr.w ilhighwater ; pointer into table
rfs1
 move.b (a0)+,d0
 beq.s rfsend
 move.b d0,$0(a6,ilhighwater)
 addq.w #1,ilhighwater
 bra.s rfs1

rfsend
 bsr startofinputline ; position cursor at start of input
 clr.w ilpos ; display from current pos to end
 bsr displayinputline
 bra inputlinecr

nothelp
 cmp.b #f1,d0
 bne.s notf1
 lea XScale(PC),a0

ChangeTextSize
 move.l a0,-(sp)
* change text width
 bsr StartOfInputLine
 bsr ClearToEndOfScreen
 move.b #cr,d0
 bsr oswrch
 move.l (sp)+,a0
 eor.b #1,(a0)
 bsr InitFont
 bsr SetupWidth
 bsr DisplayInputLine
 bra inputline1

notf1
 cmp.b #f2,d0
 bne.s notf2
 lea YScale(PC),a0
 bra.s ChangeTextSize

notf2
 cmp.b #undokey,d0
 bne.s notundo
 lea undotext,a0
 bra.s returnfixedstring

helptext
 dc.b "help.",0
 even
undotext
 dc.b "Undo!",0
 even

notundo
 cmp.b #autorunkey,d0
 beq startautorunning
* cmp.b #logkey,d0
* beq startlog

 cmp.b #cr,d0
 beq inputlinecr
 cmp.b #bs,d0
 beq inputlinebs
 cmp.b #$7F,d0 ; delete key
 beq inputlinedelete

 cmp.b #cursorleft,d0
 beq moveleft
 cmp.b #cursorright,d0
 beq moveright
 cmp.b #cursorup,d0
 beq moveup
 cmp.b #cursordown,d0
 beq movedown
* filter out control codes
 cmp.b #32,d0
 blt inputline1
* ordinary character - check if space in buffer
 cmp.w ilsize,ilhighwater
 bhi inputlinebell ; unsigned >
* shift up following characters in buffer to make space
 move.w d0,-(sp)
 move.w ilhighwater,d1
insertchar1
 move.b 0(a6,d1),d0
 move.b d0,1(a6,d1)
 cmp.w d1,ilpos
 beq.s insertchar2
 subq.b #1,d1
 bra.s insertchar1

insertchar2
 move.w (sp)+,d0
 move.b d0,0(a6,ilpos)
 bsr oswrch ; echo character
 addq.w #1,ilpos
 addq.w #1,ilhighwater
 bsr displayinputline
 bra inputline1
*---
inputlinebell
*>>19/10/87 move.b #7,d0
*>>19/10/87 bsr oswrch
 bra inputline1

inputlinedelete
* shift all characters up in buffer
* so as to delete the character after the cursor
* anything to delete after cursor ?
 cmp.w ilhighwater,ilpos
 beq inputline1
 addq.w #1,ilpos ; so that backspace will work as desired
 bra.s ilbs1 ; don't print bs first

inputlinebs
 tst.w ilpos ; anything in buffer to delete ?
 beq inputline1 ; no
 move.b #bs,d0
 bsr oswrch ; echo character
ilbs1
* now shift all characters up in buffer
* so as to delete the character before the cursor
 move.w ilpos,d1
deletechar1
 move.b $0(a6,d1),d0
 move.b d0,-1(a6,d1)
 cmp.w d1,ilhighwater
 beq.s deletechar2
 addq.w #1,d1
 bra.s deletechar1

deletechar2
 subq.w #1,ilpos
 subq.w #1,ilhighwater
 bsr displayinputline
 bra inputline1

moveleft
 tst.w ilpos ; at start of input line ?
 beq inputline1 ; no
* move.b #bs,d0
* bsr oswrch
 bsr RetreatCursor
 subq.w #1,ilpos
 bra inputline1

moveright
 bsr.s mrsub
 bra inputline1

mrsub
 cmp.w ilhighwater,ilpos
 bcc mrsubret ; greater than or equal
*>>19/10/87 move.b 0(a6,ilpos),d0
*>>19/10/87 bsr oswrch ; step cursor on
 bsr AdvanceCursor *>>19/10/87
 addq.w #1,ilpos
mrsubret
 rts
*---
startofinputline
* move to the start of the current input line
 tst.w ilpos ; at start of input line ?
 beq soilret ; yes
 bmi.s soilret
*>>19/10/87 move.b #bs,d0
*>>19/10/87 bsr oswrch
 bsr RetreatCursor * corrupts a0,d0 only
 dbra ilpos,startofinputline
soilret
 rts
*---
movedown
 bsr startofinputline ;>>
 move.w currentlineoffset(pc),d2
 subq.w #1,d2
 bmi inputlinebell
 beq movedownblank ; back to blank line
 bsr findaninputline
 move.w currentlineoffset(pc),d2
 addq.w #1,d2 ; a problem, so put current line back
movedownend
 lea currentlineoffset(pc),a0
 move.w d2,(a0)
 bra inputlinebell

movedownblank
 bsr initinputline
 bsr displayinputline
 bra inputline

moveup
 move.w currentlineoffset(pc),d2
 addq.w #1,d2
 bsr findaninputline
 move.w currentlineoffset(pc),d2
 subq.w #1,d2 ; a problem if get back to here, so reset current line
 bra.s movedownend

findaninputline
* display the d2.w th previously entered line
 lea currentlineoffset(pc),a0
 move.w d2,(a0)

* first find its address
 move.l cycliccharsused,d1
 move.l cyclicwriteptr,a0
 move.l #1,a1
 bsr subcyclic ; skip over terminator of previous input
 subq.w #1,d1 ; chars used

moveup1
 bsr subcyclic
 subq.w #1,d1 ; chars used
 bmi.s moveup1a ; maybe have first line entered
 tst.b (a0)
 bne.s moveup1
moveup1a
* got a terminator, are we at the right message yet ?
 subq.w #1,d2
 beq.s moveupfound
 tst.w d1 ; chars used
 bmi moveupret ; out of previous lines
 bra.s moveup1

moveupfound
* have found the wanted previous line
* which starts at a0.l+1
 bsr inccyclic ; addq.l #1,a0
* first, position cursor at start of current input line
 bsr startofinputline

* copy it into the buffer for editing
 move.w #-1,ilpos
moveup2
 addq.w #1,ilpos
 move.b 0(a0,ilpos),d0
 move.b d0,0(a6,ilpos)
 bne.s moveup2
 move.w ilpos,ilhighwater
 clr.w ilpos
 bsr displayinputline
* ok, so strip off return address
* and edit the line
* see moveup,movedown routines for why
 move.l (sp)+,d0 ; pop off unwanted return address
 bra inputline0
moveupret
 rts
*---
inputlinecr
* terminate and return
* move to bottom of screen
*>>19/10/87 lea YCursorpos,a0
*>>19/10/87 move.b #8,(a0)
*>>19/10/87 lea XCursorPos,a0
*>>19/10/87 clr.w (a0)
 bsr gotobot * goto the bottom left of the screen
*>>19/10/87 move.b cursorypos,d0
*>>19/10/87 cmp.b #24,d0
*>>19/10/87 beq.s il0
*>>19/10/87 move.b #cr,d0
*>>19/10/87 bsr oswrch
*>>19/10/87 bra.s inputlinecr
*>>19/10/87il0
 move.b #cr,d0
 bsr oswrch

storeinputline
* store it in a cyclical buffer
 move.b #0,0(a6,ilhighwater) ; add a terminator
 tst.w ilhighwater
 beq.s ilret ; blank line, don't store it
ilcr1
* enough space ?
 move.l cycliccharsused,d0
 add.w ilhighwater,d0
* how much space available in cyclic buffer ?
 move.l cyclicbufferend,d1
 sub.l cyclicbufferstart,d1
 cmp.w d1,d0
 bcs.s ilcr3
* no, so remove chars from buffer until 0 (eol) reached
ilcr2
 bsr removecharcyclicbuffer
 tst.b d0
 bne.s ilcr2
 bra.s ilcr1

ilcr3
* enough space available now, so go through and write in
* this input line
 move.w #0,ilpos ; pointer to buffer
ilcr4
 move.b 0(a6,ilpos),d0
 bsr putcharcyclicbuffer
 addq.w #1,ilpos
 tst.b d0
 bne.s ilcr4
ilret
 rts
*------
subcyclic
* do cyclic subtraction: a0:=a0-a1
 sub.l a1,a0
 cmp.l cyclicbufferstart,a0
 bcc.s scret ; unsigned >= - still within buffer
 sub.l cyclicbufferstart,a0 ; get (negative) offset from buffer start
 add.l cyclicbufferend,a0 ; and add it to the buffer end
* to give a0.l = pos in buffer
scret
 rts
*---
removecharcyclicbuffer
* get oldest char from cyclical buffer in d0.b
 move.l cyclicwriteptr,a0
 move.l cycliccharsused,a1
 bsr subcyclic ; a0:=a0-a1
 move.b (a0),d0
 lea cycliccharsused,a0
 subq.l #1,(a0)
 rts
*---
inccyclic
* a0.l:=a0.l+1
 addq.l #1,a0
 cmp.l cyclicbufferend,a0
 bcs.s ic1
 move.l cyclicbufferstart,a0
ic1
 rts
*---
putcharcyclicbuffer
* write char d0.b into cyclical buffer
* at (cyclicwriteptr).l
 move.l cyclicwriteptr,a0
 move.b d0,(a0)
 bsr inccyclic
 lea cyclicwriteptr,a1
 move.l a0,(a1)
* and inc number of chars used in buffer
 lea cycliccharsused,a0
 addq.l #1,(a0)
 rts
*---
displayinputline
* now echo input line from current pos to end of buffer
* save cursor pos
* move.w XCursorPos(PC),-(sp)
* move.w YCursorPos(PC),-(sp)
 move.w ilpos,d1
dil1
 cmp.w d1,ilhighwater
 beq.s dil2
 move.b 0(a6,d1),d0
* check the character is printable...
 and.l #$000000FF,d0
 cmp.w #32,d0
 bcs.s dilNonPrinting
 cmp.w #128,d0
 bcc.s dilNonPrinting

 bsr oswrch
dilNonPrinting
 addq.w #1,d1
 bra.s dil1

dil2
 bsr ClearToEndOfScreen
* restore cursor pos
* lea YCursorPos(PC),a0
* move.w (sp)+,(a0)
* lea XCursorPos(PC),a0
* move.w (sp)+,(a0)
 move.w ilhighwater,d1
 sub.w ilpos,d1
dil3
 tst.w d1
 beq.s dilret
 bsr RetreatCursor
 dbra d1,dil3
dilret
 rts
* and clear to end of screen
*>>19/10/87 move.b #'J',d0
*>>19/10/87 bsr sendesc
*
ClearToEndOfScreen
 bsr CalcCurrentCharAddress
* zero to end of this character line...
 move.w XScreenSize(PC),d0
 sub.w XCursorPos(PC),d0
 lsr.w #3,d0 * divide by 8 to give no. of characters
 move.b XScale,d1
 beq.s CTEOSNormalWidth
 asl.w #1,d0

CTEOSNormalWidth
 move.b ScreenResolution,d1
 cmp.b #2,d1
 beq.s CTEOSHires
* colour mode has 2 bytes per char
 asl.w #1,d0
* also, if starting on second byte of a word, must clear it specially
 move.w a0,d1
 btst #0,d1
 beq.s CTEOSHires

 move.l a0,-(sp)
 move.w #7,d1
 move.b YScale,d2
 beq.s CTEOS0
 move.w #15,d1
CTEOS0
 move.b #0,(a0)
 move.b #0,2(a0)
 add.l #160,a0
 dbra d1,CTEOS0
 move.l (sp)+,a0

 subq.w #3,d0 * 3 less bytes to clear
 add.l #3,a0
 tst.w d0
 bmi.s CTEOSRet

CTEOSHires
 subq.w #1,d0
* d0.w bytes remain on this char line
* clear all CharHeight of them
 clr.l d1
 move.b CharHeight(PC),d1
 subq.w #2,d1
 move.b YScale(PC),d2
 beq.s CTEOS1
 addq.w #1,d1
 asl.w #1,d1 * double charheight!

CTEOS1
 move.w d0,-(sp)
 move.l a0,-(sp)
CTEOS2
 move.b #0,(a0)+
 dbra d0,CTEOS2
 move.l (sp)+,a0
 clr.l d0
 move.b BytesPerScreenLine(PC),d0
 add.l d0,a0 * move to next line to blank
 move.w (sp)+,d0

 dbra d1,CTEOS1

* Now blank out the area from here on to end of screen
* make a0.l even
 move.l a0,d0
 btst #0,d0
 beq.s CTEOSOK
 move.b #0,(a0)+

CTEOSOK
* calc length remaining to clear in d0.l..
 move.l this_screen,d0
 add.l #(200*160),d0
 sub.l a0,d0
 bmi.s CTEOSRET

CTEOSClear
 move.l #0,(a0)+
 dbra d0,CTEOSClear



* area clear!
CTEOSRET
 rts


*CTEOS1
** calculate how many characters remain on screen...
* move.w XScreenSize(PC),d0
* sub.w XCursorPos(PC),d0
** d0.w is number of pels remaining on line
* lsr.w #3,d0 * get number of characters remaining on current line
* move.w XScreenSize(PC),d1
* lsr.w #3,d1 * get number of characters per line
* move.w YCursorPos(PC),d2
* lsr.w #3,d2 * get number of character lines remaining
* subq.w #1,d2 * number of lines not including the current one
* mulu d2,d1
* add.w d1,d0
* subq.w #2,d0 * 2 less to avoid scrolling screen
* bmi.s CTEOS3
*
*CTEOS1a
** now print d0.w spaces
*
*CTEOS2
* bsr prs
* dc.b " ",0
* even
* dbra d0,CTEOS2
*
*CTEOS3
** area clear!
** restore cursor pos
* lea YCursorPos(PC),a0
* move.w (sp)+,(a0)
* lea XCursorPos(PC),a0
* move.w (sp)+,(a0)
* rts
* --------

converttouppercase
* convert character in d0.b to upper case
 cmp.b #"a",d0
 bcs.s ctucret ; unsigned <
 cmp.b #"z",d0
 bhi.s ctucret ; unsigned >
 sub.b #"a"-"A",d0
ctucret
 rts

converttolowercase
* convert character in d0.b to lower case
 cmp.b #"A",d0
 bcs.s ctlcret ; unsinged <
 cmp.b #"Z",d0
 bhi.s ctlcret ; unsigned >
 add.b #"a"-"A",d0
ctlcret
 rts

*---

driverosrdch
 bsr osrdch
 move.b d0,(a6)
 rts

absgetcharfrombdos
* get character from keyboard in d0
* without waiting or echo (not easy in Gem !)
 call_bdos c_conis ; check if key pending
 addq.l #2,sp
 tst.l d0
 bmi.s osrdchgetkey
* no key waiting, so return 0
 move.b #0,d0
 rts
osrdchgetkey
 call_bdos c_rawcin ; get key from buffer without echo
 addq.l #2,sp
*
* if d0.b=0, the lower byte of the upper word may
* contain a keyboard code for the cursor keys etc.
 tst.b d0
 bne ogkret
 lsr.l #8,d0
 lsr.l #8,d0
 cmp.b #$48,d0
 bne.s ogk1
 move.b #cursorup,d0
 rts
ogk1
 cmp.b #$4b,d0
 bne.s ogk2
 move.b #cursorleft,d0
 rts
ogk2
 cmp.b #$4d,d0
 bne.s ogk3
 move.b #cursorright,d0
 rts
ogk3
 cmp.b #$50,d0
 bne.s ogk4
 move.b #cursordown,d0
 rts
ogk4
 cmp.b #$62,d0
 bne.s ogk5
 move.b #helpkey,d0
 rts
ogk5
 cmp.b #$61,d0
 bne.s ogk6 ; undo key
 move.b #undokey,d0
 rts
ogk6
 cmp.b #$10,d0
 bne.s ogk7 ; alt-Q
 move.b #quitkey,d0
 rts
ogk7
 cmp.b #$13,d0
 bne.s ogk8 ; alt-R
 move.b #autorunkey,d0
 rts

ogk8
 cmp.b #$26,d0
 bne.s ogk9 ; alt-L
 move.b #logkey,d0
 rts

ogk9
* $3b = f1
* $3c = f2
* $3d - f3 ... etc
 cmp.b #$3b,d0
 blt.s ogk10
 add.b #(f1-$3b),d0
 cmp.b #f2,d0
 bgt.s ogk10
 rts

ogk10
 clr.b d0
ogkret
 rts

returntogem
 ifd graphics
  move.b #settextdcode,d0
  bsr killmultitasking
  bsr driver
	bsr	jjsclosedown
 endc ; if graphics

  dc.w $a009 * show mouse
  dc.w $a009 * show mouse
  dc.w $a009 * show mouse
  move.w #0,sr * into user mode
 call_bdos p_term

*----------

 ifnd graphics ; only assembled if graphics has not been defined
settext
setgraphics
driverclg
driverchgcol
line
fill
gintstart
killmultitasking
 rts

 endc

* assemble this stuff anyway, for simplicity:


* constant definitions
screenleft equ 10
screenright equ 630
absscreenheight equ 96
fillspentrylength equ 12
fillspmax equ 2048

hiresscreenleft equ 1 ; 7 ;10
hiresscreenright equ 319 ;2 ; 630/2
hiresabsscreenheight equ 96

lowresscreenleft equ 1
lowresscreenright equ 319 ;312 ; 315 ; 630/2
lowresabsscreenheight equ 96

lowres equ 0
hires equ 2

 even
screenpointer dc.l 0
logpointer	dc.l	0
screenheight dc.w 0
screenresolution dc.b 0
 even
*---

 ifd graphics ; only assembled if graphics has been defined


settext
	clr.b	drivergraphicsmode
	bsr	hidepointer
	bsr	remove_graphics
	bsr	showpointer
	move.b	#24,linestoscroll
	rts
*---
driverchgcol
* only for low res mode
	rts
 even
*---
setuppalette
* set up colour palette
 move.b screenresolution,d0
 cmp.b #hires,d0
 lea monopalette(pc),a0
 beq.s setuppalettea0
 lea lowrespalette(pc),a0
setuppalettea0
 move.l a0,-(sp)
 call_ebios _setpalette ; move.w #6,-(sp)
 addq.l #6,sp
 rts
*--- 
driverclg
	bsr	hidepointer
	lea drivergraphicsmode(pc),a0
	tst.b (a0)
	bne driverclgalready
	bsr initgraphics ; set (drivergraphicsmode)=true etc.
driverclgalready
	bsr	showpointer
	rts

monopalette
* first colour gives white on black text if 0
* or black on white if 1
 dc.w 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

* these colours are defined in form RGB
* see P.57 ST Internals
textbackground equ $000
textforeground equ $666 * Grey text
mouseforeground equ $700 ; red mouseforeground
mousebackground equ $000 ; black fill pattern
gcol0 equ $000 ; 400
gcol1 equ $040
gcol2 equ $004
gcol3 equ $044
nocolour equ $000

lowrespalette
 dc.w textbackground,mousebackground,mouseforeground,textforeground ; 0-3
 dc.w nocolour,nocolour,nocolour,nocolour
 dc.w nocolour,nocolour,nocolour,nocolour
 dc.w gcol0,gcol1,gcol2,gcol3

*---

;addvblevent
;* on entry, a1.l is address of a new vbl event
; move.b #0,d0 ; count of number of entries in vbl queue
; move.l $456,a0 ; get address of array of VBL routines P.238 STInterns
;* now scan list
;addvbl
; tst.l (a0)
; beq.s addvbl2
; addq.b #1,d0 ; number of entries in queue
; addq.l #4,a0
; bra.s addvbl
;addvbl2
;* max number of vbl routines is 8
; cmp.b #8,d0
; bcc vbloverflow  ; unsigned >=
;* set up pointer to my routine
; move.l a1,(a0)
; rts
*---
* SPLIT SCREEN CODE
* See P. 235,237,147 in ST Internals
initsplitscreen
* first, set medium res mode, so OS will print 80 column text correctly
	move.w #1,-(sp) ; medium resolution
	move.l #-1,-(sp) ; retain physical base
	move.l #-1,-(sp) ; retail logical base
* move.w #5,-(sp) ; set screen
	call_ebios _setscreen
	add.l #12,sp

* and set irq mask to disable all interrupts (except NMIs)
	move.b #7,d7
	bsr setirqmask

* now set up MY HBL handler routine
	move.l $68,d0
	lea oshblhandler,a0
	move.l d0,(a0) ; preserve os hbl handler

	lea hblhandler,a0
* move.l a0,$68 ; exception vector for level 2 interrupt (#26)
	move.l a0,-(sp)
	move.w #26,-(sp)
	move.w #5,-(sp)
	trap #13               ; setexec - see P.147 ST Internals
	addq.l #8,sp

* now set interrupt mask to 1 to allow HBL interrupts
	move.b #1,d7
	bsr setirqmask
	bsr	gotobot
	bsr	resetginttask
	rts


;-------
MyVblEvent
* this is called AFTER the OS VBL handler,
* and just resets the palette for the top half of the screen
* This is done because the _setPalette os call
* appears to stop working every so often at random - this
* seems correlated with the floppy disk light staying on permamently - 
* and could be due to a bug in the OS vbl handler, or maybe some table
* getting corrupted. When this bug happen(s)(ed) the rest of the game
* continued to work noramlly, but the palette was not updated

; tst.b drivergraphicsmode
; beq.s mvenosplit ; don't do split screen
; move.b screenresolution,d0
; cmp.b #hires,d0
; beq.s mvenosplit
	lea	ColorMap,a0 * don't change text colours
	move.l	#$ff8240,a1
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+

	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+

	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+

	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+


mveNoSplit
 rts
;------------
* the following code is very useful for playing around
* with the split screen and removing flicker - so LEAVE IT IN !!!

iloop
 ifd AllowTraps

  lea driverbuffer(pc),a6
  addq.l #1,$7e000
  bsr waitkey
  cmp.b #" ",(a6)
  beq.s iloop
  move.b (a6),d0
  move.w d0,-(sp)

  move.b midsplitpos,d0
  bsr hexbyted0
  move.b #" ",(a6)
  move.b #oswrchdcode,d0
  bsr driver
  move.b lowsplitpos,d0
  bsr hexbyted0
  move.b #$0d,(a6)
  move.b #oswrchdcode,d0
  bsr driver

  move.w (sp)+,d0
  cmp.b #"1",d0
  bne.s adjustnotleft
  subq.b #1,lowsplitpos
  bra.s iloop
adjustnotleft
  cmp.b #"2",d0
  bne.s adjustnotright
  addq.b #1,lowsplitpos
  bra.s iloop
adjustnotright
  cmp.b #"3",d0
  bne.s adjustnotup
  subq.b #1,midsplitpos
  bra.s iloop
adjustnotup
  cmp.b #"4",d0
  bne.s iloop
  addq.b #1,midsplitpos
 endc

 bra.s iloop

*---
splitmargin equ 6
normalvblhandler
	dc.l 0
midsplitpos
	dc.b $Be ; middle address of low-to hi res split
lowsplitpos 
	dc.b $80-testpos
	even

hblhandler
* executed in supervisor mode
* This is an interrupt routine - preserve all registers
	move.w d0,-(sp)
	move.b	midsplitpos(pc),d0
	cmp.b $ff8207,d0
	bls.s csrte
	sub.b #splitmargin,d0
	cmp.b $ff8207,d0
	bcs.s tohires
csrte
	move.w (sp)+,d0
	rte			; no action at the moment

tohires
	move.w #$2700,sr ; supervisor mode, nmis only
	movem.l	a0-a1,-(sp)
* first wait for SPLITMARGIN pages of memory to be displayed
tohiresa
	move.b $ff8207,d0
	cmp.b midsplitpos(pc),d0
	bcs.s tohiresa
	move.l	#$ff8209,a0
	move.b	lowsplitpos,d0
tohires1
* now wait for the scanning beam to go off-screen
	cmp.b (a0),d0
	bcc.s tohires1 ; unsigned >
tohires2
	move.b #1,$ff8260 ; 640x200, 4 col - for text
	lea	lowrespalette,a0
	move.l	#$ff8240,a1
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0)+,(a1)+
	move.w	(a0),(a1)
	movem.l	(sp)+,a0-a1
	move.w (sp)+,d0
	rte

irqvblhandler
* vertical blank interrupt
	movem.l	a0-a1,-(sp)
 move.w d0,-(sp)

 lea realtimeclock(pc),a0
 addq.l #1,(a0) ; increment real time clock

 tst.b drivergraphicsmode
 beq.s ivhnosplit ; don't do split screen
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s ivhnosplit
	tst.w	changescreen
	beq.s	nochange
	move.w	midsplitposbuf,midsplitpos
	clr.w	changescreen
nochange
	move.b #0,$ff8260 ; 320x200, 16 col - for graphics
 bsr MyVBLEvent
;	lea	ColorMap,a0
;	move.l	#$ff8240,a1
;	move.w	(a0)+,(a1)+
;	move.w	(a0)+,(a1)+
;	move.w	(a0)+,(a1)+
;	move.w	(a0),(a1)
ivhnosplit
	tst.w	pointerinuse
	bne.s	testg3
	tst.b	intflag
	beq.s	testg3
	bsr	hidepointer
	bsr	showpointer
	clr.b	intflag
testg3
 move.w (sp)+,d0
 lea snoozesinceswap,a0
 clr.b (a0)
 movem.l (sp)+,a0-a1
 bsr ist1
 move.l osvblhandler,-(sp)
 rts

;; now call the os
; movem.l d0/a0-a1,-(sp)
;  lea MyRetAddress,a0
;  move.l a0,-(sp)
;  move.w sr,-(sp) * dummy sr
;  move.l osvblhandler,-(sp)
;  rts
;MyRetAddress
; bsr MyVblEvent
; movem.l (sp)+,d0/a0-a1
; rte
*---
setirqmask
* this routine must be executed in supervisor mode
* d7.b = new irq mask
* (bottom three bits of status register)
 and.w #7,d7
 asl.w #8,d7
 move.w sr,d0
 and.w #$f8ff,d0
 or.w d7,d0
 move.w d0,sr
 rts
*---
callsupera0
* this routine executes subroutine at a0.l in supervisor mode
 move.l a0,-(sp)
* move.w #38,-(sp)
 call_ebios supexec
 addq.l #6,sp
 rts
*---
vbloverflow
 ifd AllowTraps
  bsr prs
  dc.b "Fatal error - VBL overflow. Press a key to return to gem",cr,0
  bsr waitkey
 endc

 bra returntogem

 endc ; graphics only section of driver
*---
conditionalbreakpoint
* do a breakpoint if cr pressed

 ifd AllowTraps


  movem.l d0-d7/a0-a6,-(sp)
cb1
   bsr absgetcharfrombdos
   tst.b d0
   beq.s cb1
   cmp.b #13,d0
   bne.s cbend
   dc.w $4afa
cbend
  movem.l (sp)+,d0-d7/a0-a6


 endc

 rts
*---
* graphics workspace
x1 dc.w 0
y1 dc.w 0
x2 dc.w 0
y2 dc.w 0
storedsp dc.l 0
colour dc.b 0
optioncolour dc.b 0
drivergraphicsmode dc.b 0
hioptioncolour dc.b 0
looptioncolour dc.b 0
locolour dc.b 0
hicolour dc.b 0

 even
snoozesinceswap dc.b 0
*>>19/10/87cursorxpos dc.b 0
*>>19/10/87cursorypos dc.b 0
scrolledlines dc.b 0
pageingdisabled dc.b 0
 even
cyclicwriteptr dc.l 0
cyclicbufferstart dc.l 0
cyclicbufferend dc.l 0
cycliccharsused dc.l 0
currentlineoffset dc.w 0
*cyclicib
* ds.b 4000
*cyclicibtop

 even
realtimeclock dc.l 0
oshblhandler dc.l 0
osvblhandler dc.l 0
taskstackptr dc.l 0
newtaskstackptr dc.l 0
* ds.b 1024 ; probably over the top
*gintstacktop
* ---
driveribuffreadpos dc.w 0
driveribuffwritepos dc.w 0
driveribuffsize equ 4096

*driveribuff
* ds.b driveribuffsize
*---

 even
logdriverblock
 dc.l 0
 dc.l 0
 dc.b "LOG.BAT",0
 even

;LoadFontDriverBlock
; dc.l 0
; dc.l 0
; dc.b "8x8.FNT",0

FontAddress dc.l 0
batchptr dc.l 0
executingcommandfile dc.b 0
 even

scrolldriverbuffer
 dc.l 0

;driverbuffer
; ds.b 40

*FontSpace
* DS.B 92*8
* even                  GEMDOS likes even length files



