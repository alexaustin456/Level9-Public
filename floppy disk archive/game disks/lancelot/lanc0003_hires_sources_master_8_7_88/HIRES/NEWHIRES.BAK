* NEWHIRES.S

* Copyright (C) 1988 Level 9 Computing

* This source contains the calls to actually load a picture.
* see gint.s for the sliding split screen code.

* By: John Jones Steele 1987
* Hacked around by: Michael Austin 1987/1988

* Late changes:
* compressed picture code: "CompressedLoadDisplay" added
* small change in copycols to prevent illegal palette values getting throug

NHSnooze jmp snooze

loadsect	macro
	addq.w	#1,suspendtaskswap
	 move.w	#1,-(sp)
	 move.w	#1,-(sp)
	 move.w	ttrack,-(sp)
	 move.w	tsect,-(sp)
	 move.w	thisdrive,-(sp)
	 clr.l	-(sp)
	 move.l	#thissect,-(sp)
	 move.w	#8,-(sp)
	 trap	#14
	 lea	20(sp),sp
	subq.w	#1,suspendtaskswap
	endm

reads	macro
	movem.l	d0-d7/a0-a6,-(sp)
	move.l	#\1,a0
	move.l	#\2,d0
	bsr	readmysect
	movem.l	(sp)+,d0-d7/a0-a6
	endm

readsreg	macro
	movem.l	d0-d7/a0-a6,-(sp)
	move.l	#\1,a0
	move.l	\2,d0
	bsr	readmysect
	movem.l	(sp)+,d0-d7/a0-a6
	endm

readf	macro
	addq.w	#1,suspendtaskswap
	 move.l	#\1,-(sp)
	 move.l	#\2,-(sp)
	 move.w	\3,-(sp)
	 move.w	#$3f,-(sp)
	 trap	#1
	 lea	12(sp),sp
	subq.w	#1,suspendtaskswap
	endm
	
readfreg	macro
	addq.w	#1,suspendtaskswap
	 move.l	#\1,-(sp)
	 move.l	\2,-(sp)
	 move.w	\3,-(sp)
	 move.w	#$3f,-(sp)
	 trap	#1
	 lea	12(sp),sp
	subq.w	#1,suspendtaskswap
	endm
	
readfp	macro
	addq.w	#1,suspendtaskswap
	 move.l	\1,-(sp)
	 move.l	#\2,-(sp)
	 move.w	\3,-(sp)
	 move.w	#$3f,-(sp)
	 trap	#1
	 lea	12(sp),sp
	subq.w	#1,suspendtaskswap
	endm
	
seekf	macro
	addq.w	#1,suspendtaskswap
	 move.w	#0,-(sp)
	 move.w	\1,-(sp)
	 move.l	#\2,-(sp)
	 move.w	#$42,-(sp)
	 trap	#1
	 lea	10(sp),sp
	subq.w	#1,suspendtaskswap
	endm

trycache
	tst.w	no_caches
	bne.s	ok_cache
	rts
ok_cache
	addq.w	#1,cachenumber	* increment the number of times thr
	move.w	no_caches,d7		* go look at them
	subq.w	#1,d7
	lea	cache,a0		* cache array
tryagain
	move.l	(a0)+,a1		* first cache pointer
	cmp.w	(a1),d0
	beq.s	foundcache
	dbra	d7,tryagain		* look again
	clr.l	d7			* flag nothing done
TryCacheRet 
	rts
foundcache
	move.w	cachenumber,2(a1)
* now load the cache'd picture in
	lea	4(a1),a1		* address of cache itself
	move.b UseCompressedGraphics,d0
	bne TryCacheRet

	lea	colormap2,a0
	move.w	#31,d7
floop1	move.b	(a1)+,(a0)+
	dbra	d7,floop1
	move.l	(a1)+,xsize
	move.l	(a1)+,ysize
	move.w	(a1)+,maskleft
	move.w	(a1)+,maskright
* now set up registers for picture load
	move.l	ysize,d1
	subq.l	#1,d1
	move.l	fbuffer,thisbuffer
	add.l	#(200-lines)*160,thisbuffer
	clr.l	d0
	move.w	4(a6),d0
	move.w	d0,yoffset
	mulu	#160,d0
	add.l	d0,thisbuffer
	move.w	2(a6),d0
	move.w	d0,xoffset
	lsr.w	#1,d0			* /8*4 for word boundary
	add.l	d0,thisbuffer
	add.l	d0,a1
lbitmap
	move.l	a1,-(sp)
	move.l	xsize,d2
	subq.l	#1,d2
	move.l	thisbuffer,a3
lal1	move.w	(a1)+,(a3)+
	dbra	d2,lal1
	move.l	thisbuffer,a0
	move.l	(sp),a1
	move.w	maskleft,d3
	move.w	maskright,d4
	move.w	d3,d5
	move.w	d4,d6
	not.w	d5
	not.w	d6
* do first (special) words
	move.w	#3,d0
llp1
	move.w	(a1)+,d7
	and.w	d3,d7
	and.w	d5,(a0)
	or.w	d7,(a0)+
	dbra	d0,llp1
	move.l	xsize,d2
	subq.w	#4,d2
llp2
	subq.w	#4,d2
	beq	llastword
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	bra.s	llp2
llastword
* now special last words
	move.w	#3,d0
llp3
	move.w	(a1)+,d7
	and.w	d4,d7
	and.w	d6,(a0)
	or.w	d7,(a0)+
	dbra	d0,llp3
	add.l	#160,thisbuffer
	move.l	(sp)+,a1
	add.l	#160,a1
	dbra	d1,lbitmap
	move.w	#1,d7			* signal work done
	rts

FindOldestCache
* first look if picture d5.w already there - also find oldest cache
 move.l #0,a4
	lea	cache,a2
;	move.w	(a6),d5
	move.w	#65535,d6
	move.w	no_caches,d7
	subq.w	#1,d7
sloop1	move.l	(a2)+,a3		* get next pointer
	cmp.w	(a3),d5			* is this the picture
	bne.s	sagain			* no try again
	move.w	cachenumber,2(a3)	* update counter
	move.l #0,a4 * already present in cache
	rts
sagain	cmp.w	2(a3),d6		* find the oldest cache
	bcs.s	sag2
	move.l	a3,a4
	move.w	2(a3),d6
sag2	dbra	d7,sloop1
	rts * returns a4.l=oldest cache.
;-----
* save the current picture in the cache
savecache
	tst.w	no_caches
	bne.s	saveoo
SaveCacheRet
	rts
;---
saveoo
	move.w StoredPictureNumber,d5
	bsr FindOldestCache
	move.l a4,d7 * already present? Or caches disabled?
	beq.s SaveCacheRet
* we now have a pointer to the oldest cache in a4
	move.w	d5,(a4)+
	move.w	cachenumber,(a4)+
	lea	colormap2,a3
	move.w	#31,d7
sloop1a	move.b	(a3)+,(a4)+
	dbra	d7,sloop1a
	move.l	xsize,(a4)+
	move.l	ysize,(a4)+
	move.w	maskleft,(a4)+
	move.w	maskright,(a4)+
* now set up registers for picture load
	move.l	ysize,d1
	subq.w	#1,d1
	move.l	fbuffer,a5
	add.l	#(200-lines)*160,a5
	clr.l	d2
	move.w	yoffset,d2
	mulu	#160,d2
	add.l	d2,a5
	move.w	xoffset,d2
	lsr.w	#1,d2			* /8*4 for word boundary
	add.l	d2,a5
	add.l	d2,a4
sbitmap
	move.l	a4,-(sp)
	move.l	xsize,d2
	subq.w	#1,d2
	move.l	a5,a3
sal1	move.w	(a3)+,(a4)+
	dbra	d2,sal1
	add.l	#160,a5
	move.l	(sp)+,a4
	add.l	#160,a4
	dbra	d1,sbitmap
	rts

displayhires
	lea	gint_buffer,a0
	move.l	(a6),(a0)
	move.l	4(a6),4(a0)
	move.l	8(a6),8(a0)
	move.w	(a6),this_picture
	tst.b	textmode
	beq.s	nodisplay
	jsr	resetginttask
nodisplay
	rts

testhires
	move.w	fflag,(a6)
	rts

do_display
	move.w	(a6),fflag		* currently working on this file
* first check we closed down clean last time
	tst.w	handle
	beq.s	go_go_go
	bsr	trueend
go_go_go
	tst.b	screenresolution	* see if hires
	beq.s	notback			* if so copy last undithered
	move.l	fbuffer,a0		* picture back to file buffer
	move.l	screenpointer2,a1	* use the 2nd screen as buffer
	move.w	#7999,d0		* as it isn't used in hires
h_loop1	move.l	(a1)+,(a0)+
	dbra	d0,h_loop1
notback
	clr.l	d0
	move.w	(a6),d0
	lea StoredPictureNumber,a0
	move.w d0,(a0)
* picture in cache?
	bsr	trycache
	beq.s NotInCache
* now a1.l = the start of the actual cache data itself
* - i.e. not the cache header (2 words - pic number, and cache num)
* using squashed pictures?
	move.b UseCompressedGraphics,d0
	beq dodiss * not compressed - just dissolve it in.
	bra LoadCompressedFromCache

NotInCache
* no - load it from disk
* work out filename...
	lea	filename,a0
	bsr	makedecimald0
* using squashed pictures?
 move.b UseCompressedGraphics,d0
 beq.s DontUseCompressed
* add '.squ' onto filename
 lea filename,a0
AddSqu1
 move.b (a0)+,d0
 bne.s AddSqu1
 subq.l #1,a0
 move.b #'.',(a0)+
 move.b #'S',(a0)+
 move.b #'Q',(a0)+
 move.b #'U',(a0)+
 move.b #0,(a0)+

DontUseCompressed
* try to read a sector to test if disc still in drive
	move.w	thisdrive,d0
	cmp.w	#2,d0
	bcc	not_floppy
	addq.w	#1,suspendtaskswap
	 move.w	#1,-(sp)
	 move.w	#0,-(sp)
	 move.w	#1,-(sp)
	 move.w	#1,-(sp)
	 move.w	thisdrive,-(sp)
	 clr.l	-(sp)
	 move.l	#thissect,-(sp)
 	 move.w	#8,-(sp) ; floprd
 	 trap	#14
 	 lea	20(sp),sp
	subq.w	#1,suspendtaskswap
	tst.w	d0
	bne	freaderror
wack	bsr	try10times
	tst.w	d0
	bne	freaderror
not_floppy
	move.l	#dirbuff,-(sp)
	call_bdos	D_SETPATH
	addq.l	#6,sp
	tst.w	d0
	bne	freaderror

	addq.w	#1,suspendtaskswap
	 move.w	#0,-(sp)	*read
	 move.l	#filename,-(sp)
	 move.w	#f_open,-(sp)
	 trap	#1
	 add.l	#8,sp
	subq.w	#1,suspendtaskswap
	tst.w	d0
	bmi	filereaderror
okopenedit
	move.w	d0,handle
	bsr	NHsnooze

* using squashed pictures?
 move.b UseCompressedGraphics,d0
 beq DisplayUnCompressed
* code unique to compressed pictures...
* now set up registers for picture load
	move.w StoredPictureNumber,d5
	bsr FindOldestCache * returns a4.l as start of it
 move.w d5,-(sp)
  move.l a4,-(sp)
* and pass address for actual picture data to load routine...
   add.l #4,a4
   lea CompressedCacheAddress,a0
   move.l a4,(a0)
   lea UseCompressedCache,a0
   clr.b (a0) * also saves picture in cache
   bsr SetUpForCompressedLoad
   bsr CompressedLoadDisplay

;  tst.b	first
;  bne.s	GotPic1
;* for first picture (i.e. title screen), have to copy cols over
;  bsr	copycols
;  move.b #1,first
;GotPic1

* write header into cache...
  move.l (sp)+,a4
 move.w (sp)+,d5
 tst.b d0
 bne CacheError * problem with load or decompression - do not init cache
 move.w d5,(a4)+
 move.w cachenumber,(a4)+
 bra dodiss1

CacheError
 move.l #0,(a4)+
 bra FReadError * problem with load or decompression - void cache
;---
LoadCompressedFromCache
* now set up registers for picture load
* from cache starting at a1.l ( actual cache, not the header)
* ( the cache header is at -4(a1.l)
 move.l a1,-(sp)
  lea CompressedCacheAddress,a0
  move.l a1,(a0)
  lea UseCompressedCache,a0
  move.b #1,(a0)
  bsr SetUpForCompressedLoad

; Check Checksum for picture in cache...
  move.l a1,-(sp)
   move.w (a1)+,d0 * length of compressed pic.
   sub.w #3,d0 * subtract length and checksum, -1 for dbra
   clr.b d1
CC1
   add.b (a1)+,d1
   dbra d0,CC1
   move.b (a1),d0 * stored value of checksum
  move.l (sp)+,a1
  cmp.b d0,d1
  beq.s CacheOk

  move.l (sp)+,a1
 clr.l -(a1) * void cache (allowing for header)
 bra fReadError * void cache, but don't clear screen

CacheOk
  bsr CompressedLoadDisplay
 move.l (sp)+,a1
 tst.b d0
 beq dodiss1 * picture load was ok
 clr.l -(a1) * void the cache ( allowing for the header)

 bra FReadError * problem with load or decompression - void cache
;-------
SetUpForCompressedLoad
	move.l	ysize,d1
	subq.l	#1,d1
	move.l	fbuffer,thisbuffer
	add.l	#(200-lines)*160,thisbuffer
	clr.l	d0
	move.w	4(a6),d0
	move.w	d0,yoffset
	move.w	2(a6),d0
	move.w	d0,xoffset

	move.l thisbuffer,a0
	rts

;-------- Code for non-compressed picture files...
DisplayUnCompressed
* now set up registers for picture load
*
* Format of disk file
* 32 bytes colormap
* sizex long - no of words in all plane across
* sizey long - no of lines in file
* maskleft word - left mask
* maskright word - right mask
* data
*
	readf	colormap2,32,handle
	tst.w	d0
	bmi	freaderror
	bsr	NHsnooze
	readf	xsize,4,handle
	readf	ysize,4,handle
	readf	maskleft,2,handle
	readf	maskright,2,handle
	tst.w	d0
	bmi	freaderror
	bsr	NHsnooze
* now set up registers for picture load
	move.l	ysize,d1
	subq.l	#1,d1
	move.l	fbuffer,thisbuffer
	add.l	#(200-lines)*160,thisbuffer
	clr.l	d0
	move.w	4(a6),d0
	move.w	d0,yoffset
	mulu	#160,d0
	add.l	d0,thisbuffer
	move.w	2(a6),d0
	move.w	d0,xoffset
	lsr.w	#1,d0			* /8*4 for word boundary
	add.l	d0,thisbuffer
; Load in the bit map data
dobitmap
	move.l	xsize,d2
	movem.l	d1-d4,-(sp)
	lsl.w	#1,d2		* change words to bytes
	readfreg	scr_buffer,d2,handle
	movem.l	(sp)+,d1-d4
	tst.w	d0
	bmi	freaderror
	bsr	testend
	tst.l	d7
	bne	trueend
	move.l	thisbuffer,a0
	move.l	#scr_buffer,a1
	move.w	maskleft,d3
	move.w	maskright,d4
	move.w	d3,d5
	move.w	d4,d6
	not.w	d5
	not.w	d6
* do first (special) words
	move.w	#3,d0
flp1
	move.w	(a1)+,d7
	and.w	d3,d7
	and.w	d5,(a0)
	or.w	d7,(a0)+
	dbra	d0,flp1
	subq.w	#4,d2
flp2
	subq.w	#4,d2
	beq	lastword
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	bra.s	flp2
lastword
* now special last words
	move.w	#3,d0
flp3
	move.w	(a1)+,d7
	and.w	d4,d7
	and.w	d6,(a0)
	or.w	d7,(a0)+
	dbra	d0,flp3
	bsr	do_scroll
	bsr	NHsnooze
	bsr	NHsnooze
	add.l	#160,thisbuffer
	dbra	d1,dobitmap
	addq.w	#1,suspendtaskswap
	 move.w	handle,-(sp)
	 move.w	#$3e,-(sp)
	 trap	#1
	 addq.l	#4,sp
	 clr.w	handle		* cleaned up tidy
	subq.w	#1,suspendtaskswap
	tst.b	first
	bne.s	dodiss
	bsr	copycols
	move.b	#1,first
; picture is in cache and may now be displayed
dodiss
	bsr	savecache
;------ END OF CODE for non-compressed bitmapped pictures


dodiss1
* common for compressed AND non-compressed code
	tst.b	screenresolution
	beq.s	no_stipple
	move.l	fbuffer,a0		* picture back from file buffer
	move.l	screenpointer2,a1	* use the 2nd screen as buffer
	move.w	#7999,d0		* as it isn't used in hires
h_loop2	move.l	(a0)+,(a1)+
	dbra	d0,h_loop2
	bsr	stipple
no_move
no_stipple
	addq.w	#1,suspendtaskswap
	 move.l	fbuffer,a1
	 add.l	#199*160,a1
	 move.w	#39,d0
nostp2	 clr.l	(a1)+
	 dbra	d0,nostp2
	 bsr	dissolve
	 bsr	scroll_itnow
	 move.w	(a6),old_picture
	 clr.w	(a6)
	subq.w	#1,suspendtaskswap
	bra.s	freaderror
filereaderror
	bra	trysecondside
freaderror
	clr.w	fflag
	moveq.l	#0,d0
	rts
trueend
	addq.w	#1,suspendtaskswap
	 move.w	handle,-(sp)
	 move.w	#$3e,-(sp)
	 trap	#1
	 addq.l	#4,sp
	subq.w	#1,suspendtaskswap
	move.l	d7,d0
	rts
testend
	movem.l	d0-d2/a0-a2,-(sp)
	move.l	#0,d7
	movem.l	(sp)+,d0-d2/a0-a2
	rts

trysecondside
; lets try to read the directory sector for side b
	tst.w	doubledisk
	beq	freaderror
	move.w	#$19,-(sp)
	addq.w	#1,suspendtaskswap ;>>mike 14/7/87
 	 trap	#1
	 addq.l	#2,sp
	subq.w	#1,suspendtaskswap ;>>mike 14/7/87
	move.w	d0,thisdrive
	cmp.w	#2,d0
	bcc	freaderror		; if not A or B
	move.w	#10,d7
tryitagain2
	move.w	#1,-(sp)
	move.w	#1,-(sp)
	move.w	#0,-(sp)
	move.w	#1,-(sp)
	move.w	thisdrive,-(sp)
	clr.l	-(sp)
	move.l	#dirtrack,-(sp)
	move.w	#8,-(sp)
	addq.w	#1,suspendtaskswap ;>>mike 14/7/87
	 trap	#14
	 lea	20(sp),sp
	subq.w	#1,suspendtaskswap ;>>mike 14/7/87
	tst.w	d0
	beq.s	nofreaderror
	dbra	d7,tryitagain2
	bra	freaderror
nofreaderror
	lea	dirtrack,a0
	move.w	510(a0),d0
	cmp.w	#$1234,d0
	bne	freaderror
	lea	filename,a1
	move.w	#50,d1			; max no of files
try1	movem.l	a0-a1,-(sp)
try2	move.b	(a1)+,d3
	cmp.b	(a0)+,d3
	bne.s	trynot1
	tst.b	-1(a0)
	beq.s	foundfile
	bra.s	try2
trynot1
	movem.l	(sp)+,a0-a1
	add.l	#10,a0
	dbra	d1,try1
	bra	freaderror
foundfile
	movem.l	(sp)+,a0-a1
	move.b	8(a0),ttrack+1
	move.b	9(a0),tsect+1
	loadsect
	clr.w	spoint
	bsr	NHsnooze
	reads	colormap2,32
	bsr	NHsnooze
	reads	xsize,4
	reads	ysize,4
	reads	maskleft,2
	reads	maskright,2
	bsr	NHsnooze
* now set up registers for picture load
	move.l	ysize,d1
	subq.l	#1,d1
	move.l	fbuffer,thisbuffer
	add.l	#(200-lines)*160,thisbuffer
	clr.l	d0
	move.w	4(a6),d0
	move.w	d0,yoffset
	mulu	#160,d0
	add.l	d0,thisbuffer
	move.w	2(a6),d0
	move.w	d0,xoffset
	lsr.w	#1,d0			* /8*4 for word boundary
	add.l	d0,thisbuffer
dobitmap2
	move.l	xsize,d2
	movem.l	d1-d4,-(sp)
	lsl.w	#1,d2		* change words to bytes
	readsreg	scr_buffer,d2
	movem.l	(sp)+,d1-d4
	bsr	testend
	tst.l	d7
	bne	trueend
	move.l	thisbuffer,a0
	move.l	#scr_buffer,a1
	move.w	maskleft,d3
	move.w	maskright,d4
	move.w	d3,d5
	move.w	d4,d6
	not.w	d5
	not.w	d6
* do first (special) words
	move.w	#3,d0
sflp1
	move.w	(a1)+,d7
	and.w	d3,d7
	and.w	d5,(a0)
	or.w	d7,(a0)+
	dbra	d0,sflp1
	subq.w	#4,d2
sflp2
	subq.w	#4,d2
	beq	slastword
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	move.w	(a1)+,(a0)+
	bra.s	sflp2
slastword
* now special last words
	move.w	#3,d0
sflp3
	move.w	(a1)+,d7
	and.w	d4,d7
	and.w	d6,(a0)
	or.w	d7,(a0)+
	dbra	d0,sflp3
	bsr	do_scroll
	bsr	NHsnooze
	bsr	NHsnooze
	add.l	#160,thisbuffer
	dbra	d1,dobitmap2
	bra	dodiss

readmysect
	lea	thissect,a1
	move.w	spoint,d1
	subq.w	#1,d0
rsect1
	cmp.w	#512,d1
	bne.s	getbyte
	move.w	tsect,d2
	addq.w	#1,d2
	cmp.w	#11,d2
	bne.s	getit2
	move.w	#1,d2
	addq.w	#1,ttrack
getit2	move.w	d2,tsect
	clr.w	d1
	movem.l	a0-a1/d0-d2,-(sp)
	loadsect
	movem.l	(sp)+,a0-a1/d0-d2
getbyte	move.b	0(a1,d1.w),(a0)+
	addq.w	#1,d1
	dbra	d0,rsect1
	move.w	d1,spoint
	rts

height		equ	50
swidth		equ	80
rwidth		equ	6
cwidth		equ	7
regwidth	equ	13
mask		equ	$1b00
rowshift	equ	cwidth
colmask		equ	$7f


dissolve
	movem.l	a0-a6/d0-d7,-(sp)
	move.l	#mask,d0
	move.l	d0,d6
	move.l	#rowshift,d7
	move.l	#0,d5
dissloop1
	move.l	d0,d1
	lsr.l	d7,d1
	move.w	d0,d2
	and.w	#colmask,d2
	cmp.w	#height,d1
	bcc.s	nodiss
	cmp.w	#swidth,d2
	bcc.s	nodiss
	tst.b	screenresolution
	beq.s	copylo
	bsr	copybithi
	bra.s	donecopyhi
copylo
	bsr	copybit
donecopyhi
	addq.l	#1,d5
	cmp.l	#2000,d5
	bne.s	nodiss
	movem.l	d0-d2/a0-a2,-(sp)
	bsr	copycols
	movem.l	(sp)+,d0-d2/a0-a2
nodiss	lsr.l	#1,d0
	bhi.s	dissloop1
	eor.l	d6,d0
	cmp.l	d6,d0
	bne.s	dissloop1
dissend
	move.l	hscreen,a1
	add.l	#199*160,a1
	move.w	#39,d0
disend2	clr.l	(a1)+
	dbra	d0,disend2
	movem.l	(sp)+,a0-a6/d0-d7
	rts

copycols
	lea	colormap,a0
	lea	colormap2,a1
	move.w	#15,d0
coloop
	move.w	(a1)+,d1
	and.w #$777,d1 *>>mike 24/2/88
	move.w d1,(a0)+
	dbra	d0,coloop
;	move.l	#colormap,-(sp)
;	addq.w	#1,suspendtaskswap ;>>mike 14/7/87
;	 move.w	#6,-(sp)
;	 trap	#14
;	 addq.l	#6,sp
;	subq.w	#1,suspendtaskswap ;>>mike 14/7/87
	rts

copybit
	move.w	d1,thisrow
	mulu.w	#160*4,d1		* get byte offset of row
	move.w	d2,d3
	and.w	#$fffe,d3
	lsl.w	#1,d3		* add in column offset
	add.w	d3,d1		* d1 now holds byte
	move.w	d3,thiscolumnbyte
	move.l	#$f,d3
	btst	#0,d2
	bne.s	copybit1
	move.l	#$f0,d3
copybit1
	movem.l	d5-d6,-(sp)
	move.w	#3,d5
	move.b	d3,d2
	not.b	d2		* mask off
	move.l	fbuffer,a2
	move.l	hscreen,a1
copybit2
	move.b	0(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,0(a1,d1.w)
	or.b	d4,0(a1,d1.w)
	move.b	1(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,1(a1,d1.w)
	or.b	d4,1(a1,d1.w)
	move.b	2(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,2(a1,d1.w)
	or.b	d4,2(a1,d1.w)
	move.b	3(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,3(a1,d1.w)
	or.b	d4,3(a1,d1.w)
	add.w	#160,d1
	dbra	d5,copybit2
* now put it on the real screen
	move.w	thisrow,d6
	asl.w	#2,d6			**4
	move.w	#200,d5
	sub.w	picy,d5
	sub.w	d5,d6
	bcs	off_screen1
	sub.w	#640,d1
	mulu.w	#160,d6
	move.w	#3,d5
	add.w	thiscolumnbyte,d6
	move.l	fbuffer,a2
	move.l	this_screen,a1
copybit3
	move.b	0(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,0(a1,d6.w)
	or.b	d4,0(a1,d6.w)
	move.b	1(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,1(a1,d6.w)
	or.b	d4,1(a1,d6.w)
	move.b	2(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,2(a1,d6.w)
	or.b	d4,2(a1,d6.w)
	move.b	3(a2,d1.w),d4
	and.b	d3,d4
	and.b	d2,3(a1,d6.w)
	or.b	d4,3(a1,d6.w)
	add.w	#160,d1
	add.w	#160,d6	
	dbra	d5,copybit3
off_screen1
	movem.l	(sp)+,d5-d6
	rts

copybithi
	move.w	d1,thisrow
	mulu.w	#80*8,d1		* get byte offset of row
	move.w	d2,d3
	move.w	d3,thiscolumnbyte
	add.w	d3,d1		* d1 now holds byte
	move.l	fbuffer,a2
	add.w	d1,a2
	move.l	hscreen,a1
	add.w	d1,a1
	move.b	0(a2),0(a1)
	move.b	80(a2),80(a1)
	move.b	160(a2),160(a1)
	move.b	240(a2),240(a1)
	move.b	320(a2),320(a1)
	move.b	400(a2),400(a1)
	move.b	480(a2),480(a1)
	move.b	560(a2),560(a1)
* now put it on the real screen
	move.w	thisrow,d1
	asl.w	#3,d1			**8
	move.w	#400,d5
	sub.w	picy,d5
	sub.w	d5,d1
	bcs	off_screen2
	mulu.w	#80,d1
	add.w	thiscolumnbyte,d1
	move.l	this_screen,a1
	add.w	d1,a1
	move.b	0(a2),0(a1)
	move.b	80(a2),80(a1)
	move.b	160(a2),160(a1)
	move.b	240(a2),240(a1)
	move.b	320(a2),320(a1)
	move.b	400(a2),400(a1)
	move.b	480(a2),480(a1)
	move.b	560(a2),560(a1)
off_screen2
	rts

makedecimald0
* make d0.l as a decimal number at a0.l,
* suppressing leading zeros
	movem.l	a0-a6/d0-d7,-(sp)
	tst.l	d0
	bne.s	makedec1
	move.b	#'0',d0
	move.b	d0,(a0)+
	move.b	#0,(a0)
	movem.l	(sp)+,a0-a6/d0-d7
	rts
makedec1
* non-zero number to make
	move.l	d0,d2			* store number somewhere more sensible
	lea	numbertable,a1
	move.b	#0,d3			* reset flag
makedec1a
* find the current digit value
	move.l	(a1)+,d1		* get value
	beq.s	makedecret2		* no more digits possible
* given d2=remainder of number, d1=value of current digit,
* find value
	move.b	#'0',d0
makedec2
	sub.l	d1,d2
	bcs.s	makedec3
	addq.b	#1,d0
	move.b	#1,d3			* set leading-zeros flag
	bra.s	makedec2
makedec3
	add.l	d1,d2
	tst.b	d3			* flag set yet ?
	beq.s	makedec1a
	move.b	d0,(a0)+
	bra.s	makedec1a	
makedecret2
	move.b	#0,(a0)
	movem.l	(sp)+,d0-d7/a0-a6
	rts

filename	dc.b	'1',0
		ds.b	10
		even
xsize		ds.l	1
ysize		ds.l	1
maskleft	ds.w	1
maskright	ds.w	1
bitmapoffset	ds.l	1
colormap	ds.w	16
colormap2 	ds.w	16
 ds.w 10 * security!
spoint		dc.w	0
thissect	ds.w	256
tsect		dc.w	0
ttrack		dc.w	0
intens		dc.w	0
		dc.w	0 *15
		dc.w	0 *1
		dc.w	0 *2
		dc.w	0 *3
		dc.w	0 *4
		dc.w	0 *5
		dc.w	0 *6
		dc.w	0 *8
		dc.w	0 *9
		dc.w	0 *10
		dc.w	0 *12
		dc.w	0 *13
		dc.w	0 *14
		dc.w	0 *7
		dc.w	0 *11
first		dc.b	0
		even
cachenumber	dc.w	0
handle		dc.w	0
thisrow		dc.w	0
thiscolumnbyte	dc.w	0
thisbuffer	dc.l	0
;scr_buffer	ds.w	160
fflag		dc.w	0
yoffset		dc.w	0
xoffset		dc.w	0

pats		
*0
		dc.b	0
		dc.b	0
* 1
		dc.b	0
		dc.b	0
*2
		dc.b	0
		dc.b	0
*3
		dc.b	0
		dc.b	1
*4
		dc.b	0
		dc.b	2
*5
		dc.b	2
		dc.b	0
*6
		dc.b	1
		dc.b	0
*7
		dc.b	1
		dc.b	2
*8
		dc.b	2
		dc.b	1
*9
		dc.b	3
		dc.b	0
*10
		dc.b	0
		dc.b	3
*11
		dc.b	3
		dc.b	1
*12
		dc.b	3
		dc.b	2
*13
		dc.b	2
		dc.b	3
*14
		dc.b	3
		dc.b	3
*15
		dc.b	3
		dc.b	3

 even
* pre-cursor to divide by 3 table below: to allow the filetype
* to make the whole picture darker in black and white.
 dc.b 0,0,0,0
 dc.b 0,0,0
 dc.b 0,0,0
 dc.b 0,0,0
 dc.b 0,0,0
DivideBy3
* actually divide by (49/15)=3.2666
 dc.b 0,0,0
 dc.b 1,1,1	* 3
 dc.b 2,2,2	* 6
 dc.b 3,3,3	* 9
 dc.b 4,4,4	* 12
 dc.b 5,5,5 	* 15
 dc.b 6,6,6	* 18
 dc.b 6,7,7	* 21
 dc.b 7,8,8	* 24
 dc.b 8,9,9	* 27
 dc.b 9,9,10	* 30
 dc.b 10,10,11	* 33
 dc.b 11,11,12	* 36
 dc.b 12,12,13	* 39
 dc.b 13,13,13	* 42
 dc.b 14,14,14	* 45
 dc.b 15,15,15	* 48
 dc.b 15,15,15,15,15,15,15,15 * to allow for picture being made brighter
 dc.b 15,15,15,15,15,15,15
 even
		
* work out intensities for colormap
getintens
	lea	colormap2,a1
	lea	intens,a0
	move.w	#15,d0
ginloop	move.w	(a1)+,d1		* get colour
	move.w	d1,d2			* get blue component
	and.w	#7,d2
	move.w	d1,d3			* green
	lsr.w	#4,d3
	and.w	#7,d3
	move.w	d1,d4			* red
	lsr.w	#8,d4
	and.w	#7,d4
* approximate intensities with 4*red+2*green+blue
	lsl.w	#2,d4
	lsl.w	#1,d3
	add.w	d3,d2
	add.w	d4,d2
*	lsr.w	#2,d2			* value from 0 to 12
* pick out appropriate scaling/equalization table to use
        LEA	DivideBy3,a3
 clr.l d4
 move.w PictureFileType,d4
 cmp.w #$ffff,d4
 beq.s StandardIntens
* other file types are added to the scaling table pointer
* for all colours except border (14/15)
 cmp.w #1,d0 * border colour?
 ble.s StandardIntens

 ext.l d4
 add.l d4,a3
 add.l #128,a3 * to allow positive as well as negative changes

StandardIntens
	move.b  0(a3,d2),d2 * d2.w has bits 8-15 clear
	move.w	d2,(a0)+
	dbra	d0,ginloop
	rts

*----------------

stipple
; i.e. dither black and white pictures....
	bsr	getintens
	movea.l fbuffer,a3
	lea	intens,a4
	lea	pats,a5
	move.l  #199,d5
sc_loop0
	move.l  d5,-(sp)
	lea     scr_buffer,a2
	move.l  a3,-(sp)
	move.l  #39,d0
sc_loop1
	move.l  (a3)+,(a2)+
	dbra     d0,sc_loop1
	movea.l (sp),a3
	lea     scr_buffer,a2
	move.l  #19,d0
sc_loop1a
	move.l	d0,-(sp)
	move.w  (a2)+,d1
	move.w  (a2)+,d2
	move.w  (a2)+,d3
	move.w  (a2)+,d4
	move.l  #15,d5
sc_loop2
	move.l	d5,-(sp)
	clr.w	d0
	roxl.w  #1,d4
	roxl.w  #1,d0
	roxl.w  #1,d3
	roxl.w  #1,d0
	roxl.w  #1,d2
	roxl.w  #1,d0
	roxl.w  #1,d1
	roxl.w  #1,d0
* colour value now in d0
	asl.w	#1,d0
	move.w	0(a4,d0.w),d0	* intensity offset in d0
	lsl.w	#1,d0
	lsl.l	#2,d6
	move.b	0(a5,d0.w),d5
	or.b	d5,d6
	lsl.l	#2,d7
	move.b	1(a5,d0.w),d5
	or.b	d5,d7
	move.l	(sp)+,d5
	dbra    d5,sc_loop2
	move.l  d7,80(a3)
	move.l  d6,(a3)+
	move.l	(sp)+,d0
	dbra    d0,sc_loop1a
	movea.l (sp)+,a3
	adda.l  #160,a3
	move.l  (sp)+,d5
	dbra    d5,sc_loop0
	rts
;---
beforesavestuff
; set default directory name to root on current drive
	bsr try10times
	move.l	#dirbuff3,-(sp)
	call_bdos	D_SETPATH
	addq.l	#6,sp
	rts
;---
aftersavestuff
	rts
;	addq.l	#6,sp
;	move.l	#dirbuff,-(sp)
;	call_bdos	D_SETPATH
;	addq.l	#6,sp
;	rts
;---
beforeloadstuff
; set default directory name to root on current drive
	bsr try10times
	move.l	#dirbuff3,-(sp)
	call_bdos	D_SETPATH
	addq.l	#6,sp
	rts
;---
afterloadstuff
;	move.l	#dirbuff,-(sp)
;	call_bdos	D_SETPATH
;	addq.l	#6,sp
	rts
;---
try10times
	bsr	last_resort
	move.w	#9,d7
tryloop
;	move.w	thisdrive,-(sp)
;	move.w	#11,-(sp)
;	move.w	#1,-(sp)
;	move.l	#thissect,-(sp)
;	move.w	#0,-(sp)
;	call_bios	rwabs
;	lea	14(sp),sp
	move.l	#dirbuff2,-(sp)
	call_bdos	D_SETPATH
	addq.l	#6,sp
	move.l	#dirbuff,-(sp)
	call_bdos	D_SETPATH
	addq.l	#6,sp
	tst.w	d0
	beq.s	success
	dbra	d7,tryloop
success
	rts
;---
last_resort
* only do this stuff if running off floppy.
* Called from Try10Times - attempts to force the filing
* system to reset the floppy directory.
* Crashes if used on Supra drive, (I think because the
* code below uses an 'unofficial official' call to overcome
* an ST bug. Presumably the Supra people didn't know about it.

 move.w thisDrive,d0
 cmp.w #2,d0
 bcc.s Last_Resort_Ret
	move.w	thisdrive,-(sp)
	move.w	#2,-(sp)
	move.w	#2,-(sp)
	move.l	#0,-(sp) ; buffer address - force disk change ack?
	move.w	#2,-(sp)
	call_bios	rwabs
	lea	14(sp),sp
	move.l	#buff,-(sp)
	call_bdos	F_SETDTA
	addq.l	#6,sp
	move.w	#$10,-(sp)
	move.l	#anything,-(sp)
	call_bdos	F_SFIRST
	addq.l	#8,sp
Last_Resort_Ret
	rts
;---
dirbuff3
	dc.b '\',0
;---
;---
anything	dc.b	'*.*',0
	even
;buff
;	ds.b	44
