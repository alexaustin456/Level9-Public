; MAP.TXT
;
; Copyright (C) 1988 Level 9 Computing
;
; M.J.Austin 7-8-88
;
;---
;::::::::::::::::::::::::
; Map.Txt has now been vastly modified becos of the "3D" fx
; changes are denoted by ";:::::::::" etc
;
; Graeme R.  8/12/88
;::::::::::::::::::::::::
const
 FloorPattern=4 ; white tile. 1is more patterned. 
 WallPattern=104

 var
 DownStairsX DownStairsY
 UpStairsX UpStairsY

 begin

.ClearMap
 x1=0
.CM1
 &Map(x1)=c0
 &RoomMap(x1)=c0
 add x1,c2
 if x1<MapSize then CM1
 UpStairsX=0
 DownStairsX=0 ; don't need to clear y coords, overwritten when stairs placed
 return
;------
;.InitPlayer
;; put player in room...
; x1=PlayerSpriteOffset
; x2=XPosOffset
; add x1,x2
;; x3=4
;; add x3,RoomX
; x3=x
; add x3,c2
; x5=WordScreenXPos
; gosub @InitPlayer1
; add x1,c2 ; yposoffset
;; x3=3
;; add x3,RoomY
; x3=y
; add x3,c2
; x5=WordScreenYPos
;;
;; drop through to InitPlayer1
;;
;.InitPlayer1
;; *16 to convert to pels
; add x3,x3
; add x3,x3
; add x3,x3
; add x3,x3
; sub x3,c4 ; so that head overlap works, even with 8-pixel movement
; &SpriteTable(x1)=x3
; &WordWS(x5)=x3
; return
;---
;::::::::::::::::::::::::::::::
.PatchHoles
; go through map, ensuring there is no connection between the 'non-existent'
; area, and the walkable area. Of course, what the player does with
; wands of digging is his own affair...
 x4=0 ; ptr to map
 x5=ScreenXBlocksTimes2 ; ptr to next row
 x6=ScreenXBlocksTimes2
 add x6,x6
; thus x4,x5,x6 are 3 adjacent rows
.PHLoop
 x2=x5
 &v1=Map(x2) ; current
 if v1<>0 then @PHNotHole
 sub x2,c2
 &x1=Map(x2) ; to left
 if x1=0 then PHNotPatchLeft
 if x1<64 then @PHPatchX2
.PHNotPatchLeft
 add x2,c4
 &x1=Map(x2) ; right of current
 if x1=0 then PHNotPatchRight
 if x1<64 then @PHPatchX2
.PHNotPatchRight
 x2=x4
 &x1=Map(x2) ; above  current
 if x1=0 then PHNotPatchAbove
 if x1<64 then @PHPatchX2
.PHNotPatchAbove
 x2=x6
 &x1=Map(x2) ; below current
 if x1=0 then PHNotPatchBelow
 if x1<64 then @PHPatchX2
.PHNotPatchBelow
 goto PHNotHole

.PHPatchX2 ; x2 is the address of the walkable block adjacent
; to a null block at x5
;::::::::::::::::::::::::::::::
 g1=WallPattern ; 76
 &Map(x5)=g1
;::::::::::::::::::::::::::::::


.PHNotHole
 add x5,c2
 add x4,c2
 add x6,c2

 if x6<MapSize then @PHLoop
 return
;---
.TidyMap
; go through map, putting in the 3D effect etc.
 x4=0 ; ptr to map
 x5=ScreenXBlocksTimes2 ; ptr to next row
.TM1
 &x1=Map(x4)
;::::::::::::::::::::::::
 if x1<64 then TM2 ; not a block, so no processing
 &x1=Map(x5)
 if x1>64 then TM2 ; line below IS a block, so no processing
 x1=WallPattern ;76 ; block with 'front' section
; &Map(x4)=x1
;::::::::::::::::::::::::

.TM2
 add x4,c2
 add x5,c2
 if x5<MapSize then TM1
 return
;---
.SetUpMap

;push level ;****
;code -
; clear
; c1=1
; c2=2
; c3=3
; c4=4
;code +
;pop level ;****
; gosub @ZilchThings
; StraightLength=0
; xDigStep=0
; yDigStep=0
; DigStep=0
; TrialPlacements=0
; RoomX=0
; RoomY=0
; xsize=0
; ysize=0
; size=0
; room=0
; x1=0
; x2=0
; x3=0
; x4=0
; x5=0
; x6=0
; result=false
; UpStairsX=0
; UpStairsY=0
; DownStairsX=0
; DownStairsY=0
; LoopCounter1=0
; LoopCounter2=0

 &MapHiRandomSeed=LongWS(HiLongRandomSeed)
 &MapLoRandomSeed=LongWS(LoLongRandomSeed)

 gosub @ClearMap
; build Map(0..2500) at random.
 xmax=50
 ymax=50
 x=30
 y=20
 TrialPlacements=0
 AttemptedNewRooms=0
 RoomsPlaced=0
 dir=0 ; default initial direction
 size=0 ; should not be necessary
; gosub @InitPlayer

.SUMTryRoom
 gosub @RandomRoomNumber ;  room=1
 push x ; preserve co-ords of corridor end, in case placement fails
 push y
  RoomX=x
  RoomY=y
  gosub @PlaceRoom
 pop y
 pop x
 add TrialPlacements,c1
 if TrialPlacements>500 then @Terminate ;SUMRet ; escape!
 if result=false then DC1 ; couldn't place room - continue digging
 gosub @RecordRoom

; Have we finished drawing the map?
 if RoomsPlaced>14 then @SUMRet

.SUMGetAnExit
; now pick an exit at random, and grow a connection from it...
 gosub @PickExit
 if result=true then SUMGotExit
; couldn't find an exit - try from one of the existing rooms...
.SUMPickNewRoom
 add AttemptedNewRooms,c1
 if AttemptedNewRooms>500 then @Terminate ;* not acceptable in release?
 gosub @PickNewRoom

 if result=true then SUMGetAnExit ; try finding an exit
 goto SUMPickNewRoom ;*

.SUMGotExit
; now dig the corridor...
 StraightLength=0
.DC1
 gosub @SetUpDigStep
 gosub @DigTunnelStep

 add x,xDigStep ; add on step perpendicular to exit
 add y,yDigStep

 gosub @CheckTunnelStep
 if result=true then dcDigOk
 if x4<>0 then BreakIntoRoom ; hit a room, so dig into it.
; can't carry on in current direction - at present, just terminate
 gosub @TerminateCorridor
 goto @SUMPickNewRoom

.BreakIntoRoom
 gosub @SetUpDigStep
 gosub @DigIntoRoom ; like digTunnelStep, but only digs into walls
; (to avoid breaching the continuity of the dungeon)
 goto @SUMPickNewRoom


.dcDigOk
 add StraightLength,c1
 if StraightLength<3 then DC1 ; dig tunnel step
 if StraightLength>20 then sumCFT ; see if we've overrunning
code -
 random x1
code +
 if x1>120 then DC1 ; continue digging tunnel

.SUMCFT
;; gosub @DebugShowMap
 gosub @CheckForcedTermination
 if result=false then @SUMPickNewRoom ; terminated or placed final room
; not forced to terminate - try bunging a room here.
 goto @SUMTryRoom ; try placing room at current corridor tip

.Terminate

.SUMRet
 gosub @PatchHoles
 gosub @TidyMap
 return
;---
.RandomRoomNumber
; return ROOM as a random choice from the rooms available
code -
 random ROOM
code +
 x1=7
 and room,x1
 if room>3 then RandomRoomNumber ;*****
 return
;---
.CheckForcedTermination
; check if tunnel is getting too close to edge
 if dir=0 then CFTTerminate ;*** 
 if dir<>North then cftNotNorth
 if Y<15 then CFTTerminate
.cftNotNorth
 if dir<>East then cftNotEast
 if X>35 then CFTTerminate
.cftNotEast
 if dir<>South then cftNotSouth
 if Y>35 then CFTTerminate
.cftNotSouth
 if dir<>West then cftNotWest
 if X<15 then cftTerminate
.cftnotWest
 result=true ; ok
 return

.cftTerminate
; have to terminate corridor, or maybe change direction
 gosub @RandomRoomNumber ;  room=1
 push x ; preserve co-ords of corridor end, in case placement fails
 push y
  RoomX=x
  RoomY=y
  gosub @PlaceRoom
 pop y
 pop x
 StraightLength=0
 if result=false then @TerminateCorridor ; couldn't place room
 gosub @RecordRoom
 result=false ; pick a new room to grow from
 return
;---
.PickNewRoom
; choose a room at random from those already placed.
 result=true ; unless otherwise set
 x1=RoomTableOffset
 x2=RoomsPlaced
.PNRLoop
 if x2=0 then @Fail
code -
 random x3
code +
 if x3>60 then PNR1 ; don't even try this room this time
 x3=Workspace(x1) ; number of exits used so far from this room
 if x3<3 then PickNewRoomFound
.PNR1
 x3=RoomTableEntrySize
 add x1,x3
 sub x2,c1
 goto PNRLoop

.PickNewRoomFound
 add x1,c1
 Room=Workspace(x1) ; get data # used in drawing this room
 add x1,c1
 RoomX=Workspace(x1)
 add x1,c1
 RoomY=Workspace(x1)
 return
;---
.RecordRoom
; record ROOM, at RoomX, RoomY
; for future use by PickNewRoom
 x1=RoomsPlaced
;; x2=RoomTableEntrySize
 add x1,x1 ; assumes RoomTableEntrySize=8 and RoomTableOffset=0
 add x1,x1
 add x1,x1
 WorkSpace(x1)=c0 ; zero exits so far from this room
 add x1,c1
 Workspace(x1)=Room
 add x1,c1
 Workspace(x1)=RoomX
 add x1,c1
 Workspace(x1)=RoomY
 add RoomsPlaced,c1
 return
;---
.PickExit
; choose a potential exit at random from those
; in ROOM at coords RoomX,RoomY.
; Return its co-ordinates on the map as x,y
 gosub @GetRoomData ; sets Result=true if ok
 if result=false then @Fail
code -
 random x1
code +
 if RoomY<10 then PENotNorth
 dir=North
 if x1<64 then PE1
.PENotNorth
 if RoomX>35 then PENotEast
 dir=East
 if x1<128 then PE1
.PENotEast
 if RoomY>40 then PENotSouth
 dir=South
 if x1<192 then PE1
.PENotSouth
 dir=0 ; prevent invalid dir being returned
 if RoomX<15 then @Fail ; couldn't decide on a viable exit!
 dir=West
.PE1
 gosub @CheckExit ; get x,y=coords of exit from ROOM in DIRection
 gosub @SetUpDigStep
 push x
 push y
 push x3
  gosub @CalcMapAddress
  add x1,DigStep ; x1=MapAddress
 pop x3
 pop y
 pop x
 &x2=Map(x1)
 if x2<64 then @Fail ; already an exit there
 return
;---
.SetUpDigStep
; note that DigStep is the direction that the WIDTH of the corridor
; is drawn in, and is an offset to the Map Address
; xDigStep, yDigStep are the steps along the LENGTH of the corridor

 xDigStep=0
 yDigStep=65535
 DigStep=RightMapStep
 if dir=North then DUDS1

 xDigStep=0
 yDigStep=1
;; DigStep=RightMapStep
 if dir=South then DUDS1

 xDigStep=1
 yDigStep=0
 DigStep=DownMapStep
 if dir=East then DUDS1

 xDigStep=65535
 yDigStep=0
;; DigStep=DownMapStep
 if dir=West then DUDS1
 break ;*
.DUDS1
 return
;---
.CheckExit
; Enter with x4=ptr to room data for room at RoomX, RoomY
; return x,y as coords of the potential exit in direction DIR,
; and size as size of that exit. The existance
; of the exit is not guaranteed
;
 x=0 ; offsets of wall we're using
 y=0
 if dir=North then @PEHoriz

 add x4,c2
 &x=RoomDefns(x4) ; get x size of room
 sub x,c1 ; to give offset, not size
 sub x4,c2
 if dir=East then PEVert

 x=0
 add x4,c4
  &y=RoomDefns(x4)
  sub y,c1 ; to give offset, not size
 sub x4,c4
 if dir=South then PEHoriz

.PEVert
; the offsets given in RoomDefns are vertical, from the top
; side of the room...
 x3=ExitOffsetBase
 add x3,dir
 add x3,x4 ; get position of exit info
 y=RoomDefns(x3)
 add y,RoomY ; now y is y co-ord of potential exit
 add x,RoomX
 goto PEOk
;---
.PEHoriz
; the offsets given in RoomDefns are horizontal, from the left hand
; side of the room...
 x3=ExitOffsetBase
 add x3,dir
 add x3,x4 ; get position of exit info
 x=RoomDefns(x3)
 add x,RoomX ; now x is x co-ord of potential exit
 add y,RoomY
; drop through to PEOk

.PEOk
 add x3,c1
 size=RoomDefns(x3)
 return
;----
.TerminateCorridor
 push size
 add size,c1 ; because loop terminates 1 early otherwise
;::::::::::::::::::::::::
; If xDigStep<>0 then @TCSup1	; b on tunnel horizontal
; If yDigStep=1 then @TCSup2	; b on tunnel going south
; x4=65				; value if tunnels going north
; g3=64
; g5=66
; Goto TCHere1
;.TCSup2
; x4=70				; value on tunnel going south
; g3=69
; g5=71
; Goto TCHere1
;.TCSup1
; If xDigStep=1 then @TCSup3	; b on tunnel going east
; x4=67				; value if tunnels going west
; g3=64
; g5=69
; Goto TCHere1
;.TCSup3
; x4=68				; value on tunnel going east
; g3=66
; g5=71
.TCHere1
 x4=WallPattern ; 76
 gosub @CalcMapAddress
; Sub size,c2		; subtract the two "end case" blocks from size
; &Map(x1)=g3		; end case one
; Add x1,Digstep
.TC1
  &Map(x1)=x4
  add x1,DigStep
  sub size,c1
  if size>0 then TC1
; &Map(x1)=g5		; end case two
; Add x1,Digstep
 pop size
; FirstDig=0		; clear this becos next dig will be da 1st
 return
;::::::::::::::::::::::::
;---
.CheckTunnelStep
; check a single step of tunnel at (x,y) of SIZE blocks,
; in direction (xstep,ystep)
; return RESULT=true if ok,
; or	RESULT=false and x4=block encountered
 result=true
 x4=0 ; no block encountered to fail
 push size
 if x>48 then CTSFail
 if y>48 then CTSFail ; off map.
 gosub @CalcMapAddress
.CTS1
  &x4=Map(x1)
  if x4<>0 then CTSFail
  add x1,DigStep
  sub size,c1
  if size>0 then CTS1
 pop size
 return

.CTSFail
 pop size
 goto @Fail
;---
.DigTunnelStep
; dig a single step of tunnel at (x,y) of SIZE blocks,
; in direction (xstep,ystep)
; If FirstDig=0 then @DigFirstTunnelStep
 push size
 x4=WallPattern ;76 ; wall pattern

 gosub @CalcMapAddress
  x4=FloorPattern ; 4 ;4 is blank floor, 1 is more patterned. ; blocks after first one are floor pattern
.DigTS1
  &Map(x1)=x4
  add x1,DigStep
  sub size,c1
  if size>0 then DigTS1
 x4=WallPattern ; 76 ; wall pattern
 &Map(x1)=x4
 pop size
 return
;---

;---
.DigIntoRoom
; like DigTunnelStep, but only digs into an existing wall
 push size
 x4=WallPattern ; 76 ; wall pattern

 gosub @CalcMapAddress
.DigIW1
  &x2=Map(x1)
  if x2=0 then DIGIW2
  &Map(x1)=x4
.DIGIW2
  x4=FloorPattern ; 1 ; blocks after first one are floor pattern
  add x1,DigStep
  sub size,c1
  if size>0 then DigIW1
 x4=WallPattern ; 76 ; wall pattern
 &x2=Map(x1)
 if x2=0 then DIGIW3
 &Map(x1)=x4
.DIGIW3
 pop size
 return
;---

;.DigFirstTunnelStep
;; not used for now
;; dig a single step of tunnel at (x,y) of SIZE blocks,
;; in direction (xstep,ystep)
; push size
;
; FirstDig=1
;
;;::::::::::::::::::::::::
; If xDigStep<>0 then @DFTSSup1	; b on tunnel horizontal
; If yDigStep=1 then @DFTSSup2	; b on tunnel going south
; x4=1				; value if tunnels going north
; g3=98
; g5=99
; Goto DFTSHere1
;.DFTSSup2
; x4=1				; value on tunnel going south
; g3=100
; g5=101
; Goto DFTSHere1
;.DFTSSup1
; If xDigStep=1 then @DFTSSup3	; b on tunnel going east
; x4=1				; value if tunnels going west
; g3=98
; g5=101
; Goto DFTSHere1
;.DFTSSup3
; x4=1				; value on tunnel going east
; g3=99
; g5=100
;.DFTSHere1
; gosub @CalcMapAddress
;
; Sub size,c1			; size is obviously one too big (ahem)
;
; &Map(x1)=g3		; end case one
; Add x1,Digstep
;.DFTS1
;  &Map(x1)=x4
;  add x1,DigStep
;  sub size,c1
;  if size>0 then DFTS1
; &Map(x1)=g5		; end case two
; Add x1,Digstep
;
;
; pop size
; return
;;::::::::::::::::::::::::
;
;---
.GetRoomData
; return X4 as ptr to room data for ROOM
; and RESULT=False if not found
 result=true ; unless otherwise specified
 x4=0
 x1=ROOM
.GRDLoop
 &x3=RoomDefns(x4) ; ptr to next
 if x3=0 then PlaceRoomFail
 sub x1,c1
 if x1>32000 then GRDFound
 add x4,x3 ; add on offset of next room data block
 goto GRDLoop

.GRDFound
 return
;---
code -
.IntFail
 result=false
 return

code+
.PopDirFail
 break ;*
 pop dir

.PlaceRoomFail
.Fail
 result=false
 return
;---
.PlaceRoom
; put ROOM at RoomX,RoomY if it will fit. Return result=1 if ok,
; result=0 if not.

; if we've been digging a tunnel, what exit must this room hook
; on with.
 if dir=0 then @PlaceRoomNoLink
; reverse direction

 push x ; save co-ords of the entrance door to this new room
 push y
 push size
  RoomX=x
  RoomY=y
  push dir
   &dir=list7(dir) ; reverses direction
   gosub @GetRoomData ; sets result=true if ok
   if result=false then @PopDirFail
   gosub @CheckExit
  pop dir
; now x,y are positions of the exit on the map - assuming
; the room started at RoomX, RoomY
; Calc offsets within the room...
   sub x,RoomX
   sub y,RoomY
; and shuffle over the room start so RoomX, RoomY become the top left
; coords of the room
   sub RoomX,x
   sub RoomY,y
   x=RoomX
   y=RoomY

   gosub PlaceRoomNoLink
  pop size
  pop y ; restore entrance door to this room
  pop x
 if result=false then @Fail
 gosub @DigTunnelStep
 return
;
.PlaceRoomNoLink
; find data structure for room
 result=true ; unless otherwise specified
 gosub @GetRoomData
 if result=false then @PlaceRoomFail
; check if there is space on the grid. Note that the co-ordinates
; specified will always represent the top left of the room.
 add x4,c2 ; skip ll ptr
 &xsize=RoomDefns(x4)
 add x4,c2
 &ysize=RoomDefns(x4)
 add x4,c2
 x=RoomX
 y=RoomY

 gosub @CheckSpace
 if result=false then @Fail

; nothing adverse found, so place the block...
 gosub @AbsPlaceRoom
 return
;---
.CheckSpace
; check if there is space for a room of size xsize, ysize at x,y
; check x+xsize,y+ysize is still on screen
 if x>250 then @Fail ; negative
 if y>250 then @Fail ; negative
 if y<3 then @Fail
 x1=x
 add x1,xsize
 if x1>ScreenXBlocks then @Fail
 x1=y
 add x1,ysize
 if x1>ScreenYBlocks then @Fail

; now check the actual map area it will cover...
 push x
 push y
;  add x,c1
;  add y,c1
  gosub @CalcMapAddress
 pop y
 pop x
; now x1 gives start position
 LoopCounter2=ySize
 sub LoopCounter2,c2 ; ignore edges of room
 if LoopCounter2>240 then @CheckSpaceOk ; trap overflow

.CheckSpaceYLoop
 LoopCounter1=xSize
 sub LoopCounter1,c2 ; ignore edges of room
 if LoopCounter1>240 then @CheckSpaceOk ; trap overflow

 x2=x1 ; save start of this row of blocks
.CheckSpaceXLoop
  &x3=Map(x1)
  if x3<>0 then @PlaceRoomFail
  add x1,c2
  sub LoopCounter1,c1
  if LoopCounter1<255 then CheckSpaceXLoop
 x1=x2 ; restore x1 to start of current line
 x5=ScreenXBlocksTimes2 ; word-based
 add x1,x5
 sub LoopCounter2,c1
 if LoopCounter2<255 then CheckSpaceYLoop
.CheckSpaceOk
 return
;---
.AbsPlaceRoom
 x1=10 ; skip over possible door info(8) and possible exit (2)
 add x4,x1
push x4
 gosub @CalcMapAddress
; now x1 gives start position
 LoopCounter2=ySize

.PlaceRoomYLoop
 LoopCounter1=xSize
 x2=x1 ; save start of this row of blocks
.PlaceRoomXLoop
  x3=RoomDefns(X4)
  &Map(x1)=x3
  add x4,c1
  add x1,c2
  sub LoopCounter1,c1
  if LoopCounter1>0 then PlaceRoomXLoop

 x1=x2 ; restore x1 to start of current line
 x5=ScreenXBlocksTimes2
 add x1,x5
 sub LoopCounter2,c1
 if LoopCounter2>0 then PlaceRoomYLoop
pop x4
; shall we place an exit in this room?
 sub x4,c2
 x2=RoomDefns(x4)
 if x2=0 then @PRNoDown
 add x4,c1
 x3=RoomDefns(x4)
 if x3=0 then @PRNoDown
;code -
; random x1
;code +
; if x1>80 then @PRNoDown
 if UpStairsX<>0 then PRNoUp
; place an exit at x2,x3
 push x
 push y
  add x,x2
  add y,x3
  gosub @CalcMapAddress
  x2=22 ;****23 ; up square
  &Map(x1)=x2
  gosub @CalcPixelCoords
  UpStairsX=x
  UpStairsY=y
 pop y
 pop x
 return

.PRNoUp
 if DownStairsX<>0 then PRNoDown
; place an exit at x2,x3
 push x
 push y
  add x,x2
  add y,x3
  gosub @CalcMapAddress
  x2=11 ; "EX"
  &Map(x1)=x2
  add x1,c2
  x2=12 ; "IT"
  &Map(x1)=x2
  gosub @CalcPixelCoords
  DownStairsX=x
  DownStairsY=y
 pop y
 pop x
.PRNoDown
 return
;---
.CalcPixelCoords
 add x,x
 add x,x
 add x,x
 add x,x
 add y,y
 add y,y
 add y,y
 add y,y
 return
;---
.CalcMapAddress
 x1=ScreenXBlocksTimes2
 x2=y
 gosub @MultX1X2
 add x1,x
 add x1,x * add on twice, because map table is word-based
 return
;---
.zilchthings
 V1=0 ; must be first var
 V2=0 ; must be second var
 v3=0
 v4=0
 v5=0
 v6=0
 v7=0 ; etc..
 x1=0
 x2=0
 x3=0
 x4=0
 x5=0
 x6=0
 x7=0
 x8=0 ; misc temporary vars
 m1=0 ; message number
 LoopCounter1=0
 LoopCounter2=0
 c0=0
 LeftMargin=0
 TopMargin=0
 HighlightedLine=0
 Line=0
 NumEntries=0
 RepeatCount=0
 SelectedLine=0
 FirstLine=0
 l0=0
 l1=0
 l2=0 ; Linked list temporary workspace
 LLFree=0 ; pointer to Linked list free space chain
 CurrentMenu=0
 HS0=0
 HS1=0
 PreviousObjectInfo=0
 ObjectInfo=0
 StarCounter=0
 xmax=0
 ymax=0
 x=0
 y=0
 speed=0
 result=0
 xsize=0
 ysize=0
 RoomX=0
 RoomY=0
 room=0
 size=0
 PlayerSpriteOffset=0
 StraightLength=0
 xDigStep=0
 yDigStep=0
 DigStep=0
 dir=0
 RoomsPlaced=0
 TrialPlacements=0
 AttemptedNewRooms=0
 CharactersInBuffer=0
 OutputBufferReadPtr=0
 AmountOfScroll=0
 TimeTillSampleBuffer=0
 SampledCharInBuffer=0
 verb=0
 PlayerX=0
 PlayerY=0
 MouseHasMoved=0
 MOuseX=0
 MouseY=0
 PixelCursorX=0
 PixelCursorY=0
 PixelCursorZ=0
 PixelCursorH=0
; PixelX PixelZ PixelH PixelY
; vblx1 vblx2 vblx3 vblx4 vblInitialised
;;=====
;; used for teleport control
; teleportx teleporty
; teleporttimer ; countdown for teleport control
 actor=0
 randomcount=0 ; used as a count for generating objects
; goldpieces ; amount of gold pieces owned
 minsearch=0 ; used in @findvacantsquare
 maxsearch=0 ; ditto
 xoffset=0 ; ditto
 yoffset=0 ; ditto
 VacancyType=0 ; ditto
; PlayerShieldCounter ; countdown shield
; BlackHandFlag ; set by scroll
; FireScrollFlag ; set by scroll
; Wielded ; extended message number for wielded/worn objects in LL
; ArmourClass ; see calcarmourclass
; WeaponClass ; see calcweaponclass
; Magic ; extended message number for magic adjustments
; Level ; dungeon level
; RingTimer ; interval timer for ring activations
; RingSave ; workspace in RingSpecials
; experience ; counter to increase xp when reached a value
; xp ; experience level determines max hit points allowed
; MaxPlayerHitPoints ; varies future depending on xp
; PlayerHiDataPtr ; to save ptr for flashing user when invisible etc.
; PlayerLoDataPtr
;; countdown timers for duration of potions...
; paralysistimer
; invisibilitytimer
; boozetimer
; confusiontimer
; speedtimer
; slowtimer
; heroismtimer
; heroismvalue
;;=====
;
;;::::::::::::::::::::::::
;
 HighestMonster=0
 RandomMask=0
 FirstDig=0
; g1 g2 g3 g4 g5 g6 g7 g8 ; Graeme's misc temporary vars 
;
;;::::::::::::::::::::::::
; WalkingAnimationBase
 StairsDissolve=0 ; controls dissolve when move onto some stairs
 LLOverflowReported=0
; MouseOn
; MinMouseX MaxMouseX MinMouseY MaxMouseY
; InvisLoDataPtr InvisHiDataPtr
; MapHiRandomSeed=0
; MapLoRandomSeed=0
 DownStairsX=0
 DownStairsY=0
 UpStairsX=0
 UpStairsY=0
 level=0
 return
