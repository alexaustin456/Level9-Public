; Special.txt
;
; Special cases for ADEPT
;
; Copyright (C) 1988 Level 9 Computing
;
; M.J.Austin 7-8-88
;

 begin
;---
.FGSpecialsMovedSprite
; TempFixedSprite=20
; PermFixedSprite=20
; TempMovedSprite=22
; PermMovedSprite=23
; the above give the sprite control blocks for the two sprites
; involved in a collision.
; MovedSPrite is guaranteed to have been the one that moved so as
; to cause the collision.
; V1=PermMovedSprite(TypeOffset)
; if V1<>PlayerType then fgsmsNotPlayer

.fgsmsNotPlayer
 return
;---
.BGSpecials
 x5=PermMovedSprite(TypeOffset)
 x1=MonsterMask
 and x1,x5
 if x1=0 then BGSpecialsNotBlocked
 gosub @MonsterBlocked

.BGSpecialsNotBlocked
.DRet
 return
;---
.DAMSSpecials
* now do special cases for particular types of monsters...
 v1=0 ; do mc specials unless otherwise set
 &TempMovedSprite(AnimationOffset)=c0
 &actor=TempMovedSprite(NameOffset)
; make movement decision for monster of name ACTOR
 &x=TempMovedSprite(XPosOffset)
 &y=TempMovedSprite(YPosOffset)
 speed=TempMovedSprite(SpeedOffset)

 gosub @SpecialActivate
;; if v1=0 then DRet ; processed

;; if actor=user then @DAMSSPlayer
;; if actor<22 then dRet
; object numbers can now be greater than 22. hence, we must test 
; the type of sprite rather than the name, otherwise some objects will 
; be treated as monsters.
; if actor=user then NoMoveDecision
 x1=PermMovedSprite(TypeOffset)
 if x1<>MonsterType then NoMoveDecision ;dret 
;; v1=0 ; don't do specials for other monsters
 gosub @MakeMoveDecision

.NoMoveDecision
 gosub @Animation
 gosub @SpecialPlayerSprite ; should this be here?

 v1=0 ; skip specials
 if actor=0 then DAMSSPlayer ; user.
 return

;; x2=PermMovedSprite(NumAnimationOffset)
; add x1,c1
; if x1<x2 then DAMSAnimate1
; x1=0
;.DAMSAnimate1
; TempMovedSprite(StageOffset)=x1
; return

.damsRet
 return 

.DAMSSPlayer
 PlayerX=x
 PlayerY=y
 return
;---
;---
.Animation
 &actor=PermMovedSprite(c0) ; sprite number used.

.AnimationActor
; and animate the monster...
 if actor<50 then NoOffset
 actor=0 ; e.g. user is no. 256 -> 1.

.NoOffset
 x1=actor
 add x1,x1 ; double, because word-based table.
 add x1,WalkingAnimationBase
 &x1=list9(x1) ; find animation data for monster
; find address of ptr for this direction...
 x2=TempMovedSprite(ViewOffset) ; direction of movement
 add x1,x2
 add x1,x2 ; double, because we have word ptrs.
 &x4=List9(x1)
; now &list9(x4+Stage) is place in animation sequence
 x2=x4 ; get a copy of address
 x1=TempMovedSprite(StageOffset) ; stageoffset points to next cell number to use.

;; trap illegal values ******
; x3=1
; and x3,x1
; if x3=0 then NNOk
; break ;****
; TempMovedSprite(StageOffset)=c0 ; recover!
; x1=0
;
;.NNOk ;****
 add x2,x1

 if actor<>0 then AnimateIt
 &x3=TempMovedSprite(XSpeedOffset)
 if x3<>0 then AnimateIt
 &x3=TempMovedSprite(YSpeedOffset)
 if x3=0 then SameFrame

.AnimateIt
 add x1,c2 ; add on two because word-based table.
.SameFrame
 TempMovedSprite(StageOffset)=x1
 &x1=list9(x2) ; get cell to use this frame.

 if x1<>65535 then GotView ; -1 as a cell no. indicates start again.
; reset to start of sequence
 TempMovedSprite(StageOffset)=c2 ; i.e. after using first entry
 &x1=list9(x4) ; cell for start of sequence
 if x1<>65535 then GotView
; -1 is only entry, so use null sprite for display.
 TempMovedSprite(StageOffset)=c0
 x1=0

.GotView
; x1 is animation frame to use for monster.
 &TempMovedSprite(AnimationOffset)=x1
 return
;----
.MakeMoveDecision
; make monster move towards player. Monster is at (x,y), player at
; (PlayerX,PlayerY). Speed is SPEED
 gosub @MonsterNotBlocked

; Handle player invisibility
 if invisibilitytimer<>false then playerinvis ; for potion
 x8=ringinvis
 gosub @TestRingWorn			; or for ring
 if x2=0 then playernotinvis
.playerinvis
 return
.playernotinvis
;
; Handle monsters runing away (after stealing something)
 x1=TempMovedSprite(RunAwayOffset)
 if x1=0 then @dontretreat		; not retreating
 if x1>65000 then @dontretreat		; (just in case!)
 sub x1,c1
 TempMovedSprite(RunAwayOffset)=x1	; dec retreat timer
;
; Now handle the retreat directions...
 x1=65535
 if y<PlayerY then RetreatMMDGotY
 x1=1
 if y>PlayerY then RetreatMMDGotY
.recalcrndy
 code -
 random x1
 code +
 and x1,c3
 if x1=3 then recalcrndy
 sub x1,c1				; random -1,0,1
;
.RetreatMMDGotY
 x2=65535
 if x<PlayerX then @MMDGotX
 x2=1
 if x>PlayerX then @MMDGotX
.recalcrndx
 code -
 random x2
 code +
 and x2,c3
 if x2=3 then recalcrndx
 sub x2,c1				; random -1,0,1
 goto @MMDGotX
;
;---
.dontretreat
; move towards player if we're reasonably close...
; (but not if we're some way off screen.)
; This is not for speed, but to avoid the current
; mad scramble for the player at the start of each level.
 x1=x
 sub x1,PlayerX
 if x1<200 then DRXOk
 if x1<65335 then @DontMoveMonster ; too far away
.DRXOk
 x1=y
 sub x1,PlayerY
 if x1<150 then DRYOk
 if x1<65385 then @DontMoveMonster ; too far away
.DRYOk

 x1=65535
 if y>PlayerY then MMDGotY
 x1=1
 if y<PlayerY then MMDGotY
 x1=0 ; i.e. no y offset

.MMDGotY
 x2=65535
 if x>PlayerX then MMDGotX
 x2=1
 if x<PlayerX then MMDGotX
 x2=0 ; i.e. no x offset

.MMDGotX
; x1=y direction, x2=x direction
; Now calculate any offset to the direction to make the
; npc move in semi-random directions

; we have a table comprised of the 'next x,y' for each
; calculated x,y pair.

; combine x,y directions to give offset into table
; by 4*y+x to give a unique code (see below)
 x3=x1
 add x3,x3
 add x3,x3
 add x3,x2
; x3 is -5 to +5
; now add on existing offset
 x1=TempMovedSprite(AddDirOffset)
  gosub @SignExtendX1 ; corrupts x2

 add x3,x1
 if x3<6 then MMDInRange
 if x3>32000 then MMDInRange ; 65530 then MMDInRange
 x4=11
 sub x3,x4

.MMDInRange
; now x3 is the new (internal) view of the direction in which the
; monster wishes to move
;
;			0,-1=-4
;	   -1,-1=-5	  | 		1,-1=-3
;			  |
;  -1,0=-1	----------+------------		1,0=1
;			  |
;	   -1,1=3	  |		1,1=5
;			0,1=4

; convert internal view to conventional (adventure-type) view
; for display purposes
 x4=ConvertViewToView
 add x4,x3
 x4=List7(x4)
 TempMovedSprite(ViewOffset)=x4

; now use ConvertViewToXY table to calculate the actual x,y direction
; of movement

 add x3,x3 ; times 4 to give index into table with 2 words per entry
 add x3,x3

 x4=ConvertViewToXY
 add x3,x4
 &x2=List7(x3) ; get x speed

 add x3,c2
 &x1=List7(x3) ; get y speed

; is the monster cursed with slowness?
 x3=TempMovedSprite(SlowCounterOffset)
 if x3=0 then monstermovesfast
 sub x3,c1					; decrement slow duration
 TempMovedSprite(SlowCounterOffset)=x3
 goto @movemonster				; speed*1
;
; When returning to full speed, it is neccessary to set the x,y pos 
; to a multiple of their movement speed, otherwise the monsters get 
; stuck!
.monstermovesfast
 add x2,x2					; demon uses speed*2
 add x1,x1
 x4=65534					; hence no bit 0.
 if actor=demon then movethemonster
 add x2,x2					; monsters use speed*4
 add x1,x1
 x4=65532					; hence no bits 0 & 1.
;
; are we retreating?
 x3=TempMovedSprite(RunAwayOffset)
 if x3=0 then MoveTheMonster			; not retreating
 if x3>65000 then MoveTheMonster		; (just in case!)
 add x2,x2					; retreat uses speed*8
 add x1,x1
 x4=65528					; hence no bits 0,1,2.
;
.movethemonster
 &x3=TempMovedSprite(XPosOffset)
 and x3,x4
 &TempMovedSprite(XposOffset)=x3
 &x3=TempMovedSprite(YPosOffset)
 and x3,x4
; special case to add 4 to sprite pos when moving in multiples of 8
; (this is to position the sprite correctly)
 if x4>65528 then movelessthan8
 add x3,c4
.movelessthan8
 &TempMovedSprite(YposOffset)=x3
.movemonster

 add x,x2
 add y,x1
 &TempMovedSprite(XSpeedOffset)=x2
 &TempMovedSprite(YSpeedOffset)=x1
; &TempMovedSprite(XPosOffset)=x
; &TempMovedSprite(YposOffset)=y
.DontMoveMonster
 return 
; or x1,x2 ; merge to give combined x,y offsets
; x2=ConvertXYToView
; add x1,x2
; x1=WorkSpace(x1)
;; now x1=view
;---
; v1=4 ; sprite no.
; v2=32 ; x
; v3=16 ; y
; gosub @MCSprite ;****
;---
.ClearSpriteTable
; clear sprite table
 x1=0
.IST1
 SpriteTable(x1)=c0
 add x1,c1
 if x1<4000 then IST1 ; SpriteTableSize then IST1

 &x1=list11(112) ;28*4 - i.e. spritesTable ptr
 &LongWS(120)=x1 ; SpriteTPtr for MC
 &x1=list11(114) ;28*4 - i.e. spritesTable ptr
 &LongWS(122)=x1 ; SpriteTPtr for MC

 x1=32
 v1=UpStairsX
 add v1,x1 ; get clear of stairs
 PlayerX=v1
 v2=UpStairsY
 PlayerY=v2
 gosub @SetUpPlayer
 return
;---
.InitSpriteTable
 gosub @ClearSpriteTable
code -

; randomly distribute some monsters and sprites throughout the map...
 PlayerSpriteOffset=65535
 
 x=0
 y=0
.ISTLoop
 random x1
code +
 x2=30 ; not bit 0, notice, to keep map ptr word-aligned
 and x1,x2 ; limit size of step
 add x,x1 ; add on a random amount
 add x,c1 ; minimum step is 1
 if x<ScreenXBlocks then ISTNotNextLine
 x1=ScreenXBlocks
 sub x,x1
 add y,c1
.ISTNotNextLine
 if y=UpStairsY then @ISTNotVacant ; put nothing horizontal with stairs.
 if y=DownStairsY then @ISTNotVacant
 gosub @CalcMapAddress
 &x2=Map(x1)
 if x2>MinWall then @ISTNotVacant
 if x2=0 then @ISTNotVacant
; we have a vacant square, put a monster/object on it
 gosub @convertparams

;::::::::::::::::::::::::

 Gosub @DistributeOOrM

 Goto @ISTNotVacant

.DistributeOOrM

code -
 random x1				; get a 'random' byte
code +
 x2=64					; choose wether object or 
 If x1>x2 then @DistributeMonster	; monster (may be weighted)

.DistributeObject
code -
 random x1				; random byte to choose object type
code +
 x2=31					; mask with 00011111
 And x1,x2
 If x1<Bottle then DistributeObject	; ..and if still out of range
 If x1>Club then DistributeObject	; go get a new random number.
 v5=x1					; v5 now holds object number
 Gosub @GenerateObject			; .. so go do it
  Return					; then return


.DistributeMonster
 g1=20				; pointer to the "levels" table in table 4
 &g1=MenuTable(g1)		; pointer to start of level datum
; g2=Level			; get the level number into a temp var
 Add g2,g2			; dubble it cos of 2 bytes/level entry
 Add g1,Level			; and add that to get ptr to this levs entry
 HighestMonster=MenuTable(g1)	; highest mosnter allowed this level
 Add g1,c1			; ..go one along table...
 RandomMask=MenuTable(g1)	; and get value to mask wiv da random no.

.GetRandomForMonster
 v5=22				; first mosnter (floating eye)
code -
 random x1			; random byte to choose object type
code +
 And x1,RandomMask
 If x1>HighestMonster then GetRandomForMonster	; ..and if still out of range
 Add v5,x1			; v5 now holds object number
 Gosub @GenerateMonster		; .. so go do it
 Return					; then return
;::::::::::::::::::::::::

.ISTNotVacant
code -
 if y<ScreenYBlocks then @ISTLoop
code +
 return
;---
.convertparams
 v1=x
 add v1,v1
 add v1,v1
 add v1,v1
 add v1,v1
 v2=y
 add v2,v2
 add v2,v2
 add v2,v2
 add v2,v2
 sub v2,c4			; correct y position
 v3=0
 v4=0
 return
;---
; place an object of sprite type v5 at pos v1,v2 and give it 
; a name depending on its object category.
.generateobject
 gosub @MCSetUpNewSprite

;
; get range of objects in the category for this sprite
 add v5,v5			; table is made up of paired bytes.
 x1=rangeoffset
 add v5,x1			; add the offset into the table
 x3=list7(v5)			; number of first object in this category.
 add v5,c1
 x2=list7(v5)			; number of objects in this category.
;
; ************************************************************************
; * NB: x2 can be reduced for early levels, so as to prevent "advanced"  *
; * objects appearing until a later level is reached.			 *
; ************************************************************************
;
; now find a random number 0<=x1<=x2
 gosub @randomx1modx2
;
; now add the random "range" to the number of first object in category
 add x1,x3
;
; now set the true name of the object in the sprite workspace
; (on exit from MCSetUpNewSprite (above), v6 is sprite table offset)
 x2=nameoffset
 add x2,v6			; find name offset of sprite.
 &SpriteTable(x2)=x1		; set true name of object.
 x3=0
 if x1>maxhand then @setmagic	; not armour/weapon
;
;=====
; choose a magic adjustment for armour/weapon
.addmagic
; x2=15 ; 10
; gosub @randomx1modx2
; x3=0
; if x1<3 then setMagic ; neutral
; if x1>12 then setMagic ; neutral
; x3=x1
; x2=248 ; -7 + (3..12) -> -4..+5
; add x3,x2
; if x3<256 then setmagic
; x2=256
; sub x3,x2			; 8 bit random number from -4 to +5

; give an approx exponential distribution of magic offsets to items
code -
 random x1
code +
 x3=252 ; -4
 if x1<4 then setMagic
 x3=253 ; -3
 if x1<8 then SetMagic
 x3=254 ; -2
 if x1<17 then setMagic
 x3=255 ; -1
 if x1<34 then setMagic
 x3=0
 if x1<194 then setMagic
 x3=1
 if x1<226 then setMagic
 x3=2
 if x1<242 then setMagic
 x3=3
 if x1<250 then setMagic
 x3=4

.setmagic
 x2=magicoffset
 add x2,v6			; find magic offset of sprite.
 SpriteTable(x2)=x3		; set magic weapon adjustment.
;
; shall we curse or poison the object?
 x2=nameoffset
 add x2,v6
 &x3=SpriteTable(x2)		; recover object name again
 if x3>minfoodminus1 then docurse ; food may be poisoned
 if x3>maxhand then dontcurse	; not armour/weapon
.docurse
 x2=5
 gosub @randomx1modx2
 if x1>2 then dontcurse			; curse failed!
 x2=cursedoffset
 add x2,v6				; NB: This overwrites other bytes 
 x4=cursemask				; in "curse" byte.
 if x3<minfood then docurse1		; curse armour/weapon
 x4=poisonmask				; or poison food
.docurse1
 SpriteTable(x2)=x4
;
; choose amount of gold pieces?
.dontcurse
 x2=nameoffset
 add x2,v6
 &x1=SpriteTable(x2)		; recover object name again
 if x1<>gold then notchoosegold
.choosewealth			; also used when creating some monsters
 x2=127
 gosub @randomx1modx2
 x3=127
 add x3,x1
 x2=WealthOffset
 add x2,v6
 &SpriteTable(x2)=x3		; choose 127 to 254 gold pieces
.notchoosegold
;=====
;
 return
;---
; place a monster of sprite type v5 at pos v1,v2 and set up any 
; special offsets (e.g wealth)
.generatemonster
 gosub @MCSetUpNewSprite
 if v5=Leprechaun then choosewealth	; (see gold pieces code above)
 return
;---
.randomx1modx2 ; return random x1.. 0<=x1<=x2
; (a random count is used here, because using random x1 produced 
; predictable results for each object category.)
 add randomcount,c1
 if randomcount<256 then randomcountmodx2
 randomcount=0
;
.randomcountmodx2
 x1=randomcount
.x1divx2 ; return result of division in x4
.x1modx2 ; return remainder of division in x1
 x4=0
 if x2=0 then dividebyzero
.mod1
 if x1<x2 then x1modx2ret
 sub x1,x2
 add x4,c1
 goto mod1
.dividebyzero
 code -
 prs " div by zero "
 code +
 gosub @displayframe
 gosub @longdelay
.x1modx2ret
 return
;---------------
.SetUpPlayer
 v5=0 ; player
 gosub @MCSetUpNewSprite
code -
code +
 &WordWS(WordPlayer1SpriteOffset)=v6
 PlayerSpriteOffset=v6
 &WordWS(WordScreenXPos)=v1
 &WordWS(WordScreenYPos)=v2
 x1=NameOffset
 add x1,v6
 x2=user
 &SpriteTable(x1)=x2 ; set up player's name
; set data pointers for when sprite is invisible
 &InvisLoDataPtr=SpriteTable(v6)
 x1=418 ; player is sprite0, invisible is sprite 11, 38 bytes per entry
 add InvisLoDataPtr,x1
 x1=2
 add x1,v6
 &InvisHiDataPtr=SpriteTable(x1)

 PlayerHiDataPtr=InvisLoDataPtr
 PlayerLoDataPtr=InvisHiDataPtr
 return
;---------
.FGSpecials
; TempFixedSprite=20
; PermFixedSprite=21
; TempMovedSprite=22
; PermMovedSprite=23
; the above give the sprite control blocks for the two sprites
; involved in a collision.
;
; xspeedOffset=4 YSpeedOffset=6
; XPosOffset=8   YPosOffset=10
; NameOffset=24
; HitPointOffset=26
;
;
;.MCDestroyTempMoved
;.MCDestroyTempFixed
;
; return: V1 false if no need to collision detect this
; sprite with other possibilities. You must do this
; if the moved sprite was destroyed
; &TempMovedSprite(XSpeedOffset)=c0
; &TempMovedSprite(YSpeedOffset)=c0
; &TempFixedSprite(XSpeedOffset)=c0
; &TempFixedSprite(YSpeedOffset)=c0
 x5=PermMovedSprite(TypeOffset)
 x6=PermFixedSprite(TypeOffset)

 if x5<>PlayerType then @FGSpecialNotPlayer
 x1=MonsterMask
 and x1,x6
 if x1=0 then FGSpecialNotFight
.FGSFighting
; land a blow
 gosub @BlockSprite
 gosub @LandABlow

.FGSNotDestroyed
; change graphics to reflect attack
 &x1=PermMovedSprite(FightAnimationOffset)
 &x2=TempMovedSprite(AnimationOffset)
 add x1,x2
;**** &TempMovedSprite(AnimationOffset)=x1
 gosub @MCReCalcSpriteGraphics ; update the pointers for new pic
 goto @FGSpecialsStop ; regardless of whether or not anything destroyed

.FGSpecialNotFight
 V1=PermFixedSprite(TypeOffset)
 if V1<>ObjectType then @FGSNotObject

; An object is about to be picked up...
 &v1=TempFixedSprite(NameOffset)
 m1=v1
; Gold pieces are treated as specials
 if v1<>gold then @notaddgold
 m1=604					; space
 gosub @AddMessageToOutputBuffer
 &x1=TempFixedSprite(WealthOffset)
 add goldpieces,x1			; add to tally
 v1=x1
 gosub @AddNumberToOutputBuffer		; add v1 to scrolling textline
 m1=gold
 gosub @AddMessageToOutputBuffer
; m1=599					; dot
; gosub @AddMessageToOutputBuffer
 goto @destroynewobject			; don't add gold to inventory
;---
.notaddgold
; set up LL(LLFree) from the object the player is picking up.
 L0=InvNameOffset
 add L0,LLFree
 &LL(L0)=v1		; record object type
;
 x1=v1
 add x1,x1
 add x1,x1
 x2=statisticoffset
 add x2,x1
 x1=list7(x2)		; x1 = strength of object
 l0=InvStrOffset
 add l0,LLFree
 LL(l0)=x1		; set strength
;
 L0=InvWieldedOffset
 add L0,LLFree
 LL(L0)=c0		; make sure it's not wielded yet
;
; is object cursed or poisoned?
 L0=InvCursedOffset
 add L0,LLFree
 v2=TempFixedSprite(CursedOffset)
 LL(L0)=v2		; add cursed & poisoned bits (if any)
;
 L0=InvMagicOffset
 add L0,LLFree
 v2=TempFixedSprite(MagicOffset)
 LL(L0)=v2		; add magic offset (if any)
;
 ObjectInfo=LLFree	; save for @PrintLLObject (beleow)
 gosub @AddToPlayerInv
;-
; now add object v1 to any other menus
 if v1<minrange then notrangeweapon ; not range weapon or wand
 if v1>maxwand then notrangeweapon ; ditto
 if v1>maxring then okrangeweapon ; between minwand...maxwand
 if v1>maxrange then notrangeweapon ; NOT (between minrange...maxrange)
.okrangeweapon
 x1=v1
 gosub @AddRangedWeapon
.notrangeweapon
.scrollnewobject
 Gosub @PrintLLObject
.destroynewobject
 gosub @MCDestroyTempFixed ; destroy the object

.FGSNotObject

.FGSpecialNotPlayer

; monster?
 x1=MonsterMask
 and x1,x5
 if x1=0 then FGSNotMonster
 if x6<>PlayerType then @FGSNotAttackPlayer
code -
 random x1
code +
 if x1>5 then @FGSFighting
 m1=601 ; ouch!
 gosub @AddMessageToOutputBuffer
 goto @FGSFighting

.FGSNotAttackPlayer
 x1=MonsterMask
 and x1,x6
 if x1=0 then FGSNotBlocked
.FGSBlocked
 gosub @BlockSprite ; prevent monsters climbing over each other
 gosub @MonsterBlocked

.FGSNotBlocked
; monster colliding with something else - ignore at present
 gosub @MonsterNotBlocked ;** should do on EVERY successful move
 goto @FGSpecialsOk ; check for other collisions

; Missile?
.FGSNotMonster
 x1=MissileMask
 and x1,x5
 if x1=0 then @FGSNotMissile
;
; Has missile hit player?
 &x1=TempMovedSprite(NameOffset)
; For some reason, missile 8 has the player collision bit set, 
; although it should not collide with the player!
 if x1=8 then @FGSNotMissile ; notmonstermissile
 if x1=9 then @FGSNotMissile
 x1=PlayerMask
 and x1,x6
 if x1<>0 then @NotRangeMissile		; a hit - damage the player
.notmonstermissile
;
 x1=MonsterMask
 and x1,x6
 if x1=0 then @FGSpecialsOk
 gosub @MCSpecialCheck
 if v1<>0 then @FGSNotMissile
; missile REALLY did hit it
;
; missiles are treated specially because there are 18 of them in all, 
; each having different effects.
 x1=TempMovedSprite(SourceWeaponOffset) ; x1=missile SOURCE object
;
; Wand?
 if x1<minwand then notwandmissile
 if x1>maxwand then notwandmissile
.ZapWand				; also called from @SpecialMissile
 gosub @discoveruse			; use of wand is now known
 x2=minwand
 sub x1,x2
 code -
 jump @WandJump x1			; do the specific wand routine
 code +					; and then return to @missile
;
; Range weapon?
.notwandmissile
 if x1<minrange then notrangemissile
 if x1>maxrange then notrangemissile
 goto @missile				; normal damage for stars etc.
;
; Source is not wand or range weapon, so must either be generated by...
; 1. M/C (off-shoot from exploding missile)
; 2. Magic weapon (e.g. wand of dynamite)
; 3. A monster
; 4. The player before any special weapons are owned (if this is allowed!)
.notrangemissile
 gosub @landablow			; use built-in sprite damage
 goto @donemissile
;
 code -
.WandJump
 data @createmonster	; 60
 data @dmissile		; 61 magic missile
 data @slowmonster	; 62
 data @polymorph	; 63
 data @teleport		; 64
 data @digging		; 65
 data @dmissile		; 66 fire missile
 data @dmissile		; 67 ice missile
 data @deathmissile	; 68 death
 data @exorcism		; 69
 data @cloning		; 70
 data @dynamite		; 71
 data @dmissile		; 72 fire storm
 data @shieldwand	; 73
 data @revealtraps	; 74
;
.deathMissile
 code +
 x1=8000 ; damage to do.
 gosub @DoDamageX1
 goto DoneMissile
code -

.dmissile		; no special code for missile
 code +
;
; damage the target using the missile statistic table damage...
.missile
 x1=TempMovedSprite(SourceWeaponOffset) ; x1=missile SOURCE object
 add x1,x1
 add x1,x1
 x2=statisticoffset
 add x1,x2
 x1=list7(x1)				; x2=missile "special" damage
 gosub @dodamagex1
;
.donemissile
;
; was what we hit destroyed?
 &x1=TempFixedSprite(HitPointOffset)
 if x1=0 then MissileDestroyed
 gosub @StartExplosion

.MissileDestroyed
 &x1=TempMovedSprite(NameOffset)
 if x1=6 then FGSBigExp1
 if x1<>8 then NotBigExplosion
code -
 random x1
code +
 if x1>5 then FGSBigExp1
 m1=602 ; wow!
 gosub @AddMessageToOutputBuffer

.FGSBigExp1
 gosub @StartBigExplosion

.NotBigExplosion
; for missiles, an explosion is also started where the OTHER sprite was.

 if x1=5 then FGSLittleExp1		; no text for player-colliding
 if x1=6 then FGSLittleExp1		; missiles
code -
 random x1
code +
 if x1>5 then FGSLittleExp1
 m1=603 ; got him!
 gosub @AddMessageToOutputBuffer

.FGSLittleExp1
 gosub @MCDestroyTempMoved
 goto @FGSpecialsStop

.FGSNotMissile

; by default, scan for further collisions
.FGSpecialsOk
 v1=true ; continue with cd
 return
;---
.FGSpecialsStop
 v1=false
 return
;
; Special routines for wand missiles
;
; NB: These routines are either called from FGSMissileHit where 
; a real missile is used, or from SpecialMissile where no missile 
; is used. You must return to @Missile if the routine was called from
; FGSMissileHit.
;
 code -
.createmonster				; on entry, v1,v1=player x,y
 code +
 &x1=WordWS(WordFreeSprites)
 if x1<SpriteAllowance then @missile	; safe limit when creating monsters
 gosub @findvacantsquare		; find a vacant square
 if x1=false then @missile		; tough cookie!
; Now bung a random monster in it...
 v5=22					; floating eye
 code -
 random x1
code +
 x2=15
 and x1,x2
 add v5,x1				; randomize monster type
 goto @generatemonster
;---
 code -
.slowmonster
 code +
 x1=100
 TempFixedSprite(SlowCounterOffset)=x1	; set countdown time for slowness
 goto @missile
;---
; change monster into a random object
 code -
.polymorphagain
.polymorph
; random v5
; x1=31
; and v5,x1
; if v5<Bottle then polymorphagain
; if v5>Club then polymorphagain
 v5=22				; first mosnter (floating eye)
 random x1			; random byte to choose object type
 x2=31
code +
 And x1,x2
code -
 If x1>AbsHighestMonster then polymorph ; ..and if still out of range
 Add v5,x1			; v5 now holds object number


code +
 &TempFixedSprite(HitPointOffset)=c0	; destroy "old" monster
 &v1=TempFixedSprite(XPosOffset)	; monster x
 &v2=TempFixedSprite(YPosOffset)	; monster y
 v3=0					; speed=0
 v4=0
; gosub @generateobject			; change monster to object
 Gosub @GenerateMonster		; .. so go do it


 goto @missile
;---
 code -
.teleport
 code +
 gosub getrandompos
 &TempFixedSprite(HitPointOffset)=c0	; destroy "old" monster
; Now reposition the "new" monster...
 &v5=TempFixedSprite(NameOffset)
 gosub @MCSetUpNewSprite
 goto @missile
;---
;=====
; get a random sprite position in v1,v2 for use with teleport
.getrandompos
 code -
 random x
 random y
 code +
 x1=15
 and x,x1
 and y,x1				; 0..15
 x1=17
 add x,x1
 add y,x1				; 17..32
 gosub @CalcMapAddress
 &x2=Map(x1)				; get square value
 if x2<>0 then getrandompos		; not blank
 gosub @convertparams			; parameters * 16
 gosub @findvacantsquare		; sprites vacant here?
 if x1=false then getrandompos		; try again...
 return
;=====
;---
; digging (null - simply used from mcode to set identify flag)
 code -
.digging
 code +
 return
;---
; destroy ghosts
 code -
.exorcism
 code +
 &x1=TempFixedSprite(NameOffset)
 if x1<>ghost then targetnotghost
 &TempFixedSprite(HitPointOffset)=c0	; destroy ghost
.targetnotghost
 goto @missile
;---
 code -
.cloning
 code +
 &x1=WordWS(WordFreeSprites)
 if x1<SpriteAllowance then @missile	; safe limit when creating monsters
 &v1=TempMovedSprite(XPosOffset) 	; v1 is x pos of missile
 &v2=TempMovedSprite(YPosOffset)	; v2 is y pos of missile
 gosub @findvacantsquare		; find a vacant square
 if x1=false then @missile		; tough cookie!
; Now clone the monster...
 &v5=TempFixedSprite(NameOffset)
 gosub @generatemonster
 goto @missile
;---
 code -
.dynamite				; on entry, v1,v1=player x,y
 code +
; destroy wand from both inventory & ranged weapons list
 v3=0					; xspeed
 v4=1					; yspeed (to trigger collision)
 v5=6					; player-colliding exp missile
 gosub @MCSetUpNewSprite
 x2=SourceWeaponOffset
 add x2,v6
 x1=255
 SpriteTable(x2)=x1			; missile source type="monster"
 x1=71					; dynamite wand number
 ObjectInfo=LLPlayerInv			; destroy from inventory
 gosub @DestroyEntry
 ObjectInfo=LLRangedWeapons		; destroy from ranged list
 gosub @DestroyEntry
 ByteWs(ByteSourceWeapon)=c0		; no longer current weapon
 return
;---
 code -
.shieldwand
 code +
; destroy wand from both inventory & ranged weapons list
 playershieldcounter=100		; set countdown time for shield
 x1=73					; protection wand number
 ObjectInfo=LLPlayerInv			; destroy from inventory
 gosub @DestroyEntry
 ObjectInfo=LLRangedWeapons		; destroy from ranged list
 gosub @DestroyEntry
 ByteWs(ByteSourceWeapon)=c0		; no longer current weapon
 return
;---
; Graham 01/09/88. The game contains no traps as yet...
;
 code -
.revealtraps
 code +
 goto @missile
;---
; Find a totally vacant square as close as possible to "sprite-scale"
; co-ordinates V1,V2.
; On exit, x1=TRUE if vacant square is found within a range of +/- 4
; squares.
; 
.findvacantsquare
; divide x,y pos by 16 to get map square pos
 add v1,v1
 add v1,v1
 add v1,v1
 add v1,v1				; * 16 to move to high byte
 &list3(spareword)=v1			; store word
 x5=list3(spareword)			; read high byte
 add v2,v2
 add v2,v2
 add v2,v2
 add v2,v2				; * 16 to move to high byte
 &list3(spareword)=v2			; store word
 x6=list3(spareword)			; read high byte

;::::::::::::::::::::::::
 VacancyType=64				; first, search for room floor type
 gosub FindVacancy
 VacancyType=1
 if x1=false then FindVacancy		; last resort, search outside map
 return
;::::::::::::::::::::::::
;
; find the nearest vacant square...
.FindVacancy
 minsearch=0				; -ve range for square search
 maxsearch=0				; +ve range for square search
.nextsearch
  yoffset=minsearch			; vertical search
.nextyoffset
   xoffset=minsearch			; horizontal search
.nextxoffset
    x=x5
    y=x6				; centralise x,y
    add x,xoffset			; add x pos offset
    if x>ScreenXBlocksM1 then NotVacant	; out of map range
    add y,yoffset			; add y pos offset
    if y>ScreenYBlocksM1 then NotVacant	; out of map range
    gosub @CalcMapAddress
    &x2=Map(x1)				; get square value
; if square is vacant, then test for any sprites already there...
;::::::::::::::::::::::::
    if x2<VacancyType then @testforsprites
;::::::::::::::::::::::::
; no vacant square found if returned here, so try another...
.NotVacant
   if maxsearch<1 then testallrows	; test all squares at first...
   if yoffset=minsearch then testallrows
   if yoffset=maxsearch then testallrows
   if xoffset=maxsearch then nextrow
   xoffset=maxsearch			; ...then just test border squares
   goto @nextxoffset
.testallrows
   if xoffset=maxsearch then nextrow	; end of x search. step down y
   add xoffset,c1
   goto @nextxoffset
.nextrow
  if yoffset=maxsearch then nextrange	; end of y search. enlarge range
  add yoffset,c1
  goto @nextyoffset
.nextrange
 sub minsearch,c1			; enlarge -ve range
 add maxsearch,c1			; enlarge +ve range
 if maxsearch<6 then @nextsearch	; test -5 to +5
 x1=false				; search failed
 return
;
; vacant map square found. now test for any LIVING sprites already here...
.testforsprites
 gosub @convertparams			; convert map x,y to sprite v1,v2
; (MUST preserve v1 v2 v3 v4 v5 X5 X6)
 x1=0					; offset counter into SpriteTable
.testspritepos
 x4=hitpointoffset
 add x4,x1
 &x4=SpriteTable(x4)			; x4=hit points of sprite
 if x4=0 then @spriteposok		; no hit points - not living
 x4=xposoffset
 add x4,x1
 &x2=SpriteTable(x4)			; x2=test sprite x pos
 add x4,c2
 &x3=SpriteTable(x4)			; x3=test sprite y pos
 x4=16					; width/depth of all sprites
;
; test x collision...
 x7=x2					; x7=new sprite x pos
 sub x7,x4
 sub x7,v1
 if x7<32000 then spriteposok		; test sprite is left of new one
 x7=x2
 add x7,x4
 sub x7,v1
 if x7>32000 then spriteposok		; test sprite is right of new one
;
; sprite is within x range, so test y collision...
 x7=x3					; x7=new sprite y pos
 sub x7,x4
 sub x7,v2
 if x7<32000 then spriteposok		; test sprite is above new one
 x7=x3
 add x7,x4
 sub x7,v2
 if x7<32000 then @NotVacant		; test sprite is NOT on below
;
.spriteposok
; now test the next sprite...
 x2=48
 add x1,x2
 if x1<SpriteTableSize then @testspritepos
 x1=true				; search was successful!
 return
;---
; This routine handles all the special cases when the fire button is 
; pressed, and a missile is about to be generated.
; Return v1=0 if a missile is to be generated, anything
; else to prevent it.
; Such cases are used for "create monster" and "shield" wands etc.
.SpecialMissile
 v1=PlayerX				; x,y is required by many of 
 v2=PlayerY				; the Special Missile routines
 x1=ByteWs(ByteSourceWeapon) ; ByteSpecialMissile)
push x1
 gosub @DiscoverUse
pop x1
;
 if x1=72 then Explosive ; 'fire storm' missile
 if x1=60 then FunnyWand ; create monster
 if x1=71 then FunnyWand ; dynamite
 if x1=73 then FunnyWand ; shield
 if x1<>65 then NormalWand
; digging wand - do special, then continue with missile fire.
 gosub @ZapWand
 v1=9 ; digging missile
 return

.NormalWand
 v1=1 ; sprite number to use for missile
 return ; back to MC

.Explosive
 v1=8 ; explosive missile sprite
 return

.FunnyWand
 gosub @ZapWand
 v1=0 ; don't do missile - sprite number 0.
 return ; back to MC

;; Wand?
; if x1<minwand then NotSpecialWand
; if x1<minscroll then @ZapWand		; uses same jumblock as FGSpecial
;;
;.NotSpecialwand
; return
;---
; Called every turn of the main loop. Handle any specials for rings 
; worn...
.RingSpecials
 add ringtimer,c1			; interval timer for hunger etc.
 x8=MinRing
.RSLoop
 gosub @TestRingWorn			; is ring x8 worn?
 if x2<>0 then callring			; ring worn, so call its routine
.RSNextRing
 add x8,c1
 if x8<MaxRingPlus1 then RSLoop
 return
;
; Do jump to ring routine specified by ring x8.
; All routines MUST preserve x6 and x8
.CallRing
 ringsave=x8
 x1=x8
 x2=MinRing
 sub x1,x2				; first ring is 0
 code -
 jump RingJump x1
;
; many rings are handled elsewhere, hence they use nullring here...
.RingJump
 data @adjornment			; adjornment does nothing
 data @teleportation			;
 data @regeneration			;
 data @hunger				;
 data @nullring				; poison protection
 data @nullring				; fire resistance
 data @nullring				; cold resistance
 data @nullring				; increase damage
 data @protection			; protection
 data @nullring				; teleport control
 data @leech				; leech ring
 data @invisibility			;
 data @nullring				; strength
 data @nullring				; undead protection
;
; ring of adjornment does nothing, but is still identified
.adjornment
;
; Ring code has been executed, so identify the ring
 code +
.RSIdentify
 x1=ringsave
 gosub @discoveruse
;
 code -
.nullring
 code +
;
;=====
; Ring is being worn, so decrement the "ring decay" timer
 goto @RSNextRing

; decay code disabled, because I don't like it!...

 x1=RingTableMinus40
 add x1,ringsave
 x2=List3(x1)				; get the dacay counter
 sub x2,c1
 List3(x1)=x2				; decrement it by 1
 if x2>0 then @RSNextRing
;
; Ring has decayed...
; Search through inventory until we reach a ring of type x8 that is 
; currently being worn (since there may be other rings of this type 
; that are not worn)
 ObjectInfo=LLPlayerInv
 if ringsave<>ringinvis then DestroyRing
; If the ring was invisibility, make the player visible just in case 
; we are currently showing the "invisible" frame.
 &SpriteTable(v1)=PlayerHiDataPtr
 &SpriteTable(v2)=PlayerLoDataPtr	; restore old sprite data ptr
.DestroyRing
 PreviousObjectInfo=ObjectInfo
 &ObjectInfo=LL(PreviousObjectInfo)
 if ObjectInfo=0 then @RSNextRing	; end of inventory
 x2=InvNameOffset
 add x2,ObjectInfo
 &x2=LL(x2)				; get name
 if x2<>ringsave then NotDestroyRing	; different name
;
 x2=InvWieldedOffset
 add x2,ObjectInfo
 x2=LL(x2)				; get worn status
 if x2=0 then NotDestroyRing		; ring not worn
;
; Remove the entry...
 Gosub @RemoveFromLL
 m1=ringsave
 gosub @AddMessageToOutputBuffer	; <ring name>
 m1=766
 goto @AddMessageToOutputBuffer		; disappears from your finger
;
.NotDestroyRing
 Goto @DestroyRing			; not last entry
;
; Test to see if ring x8 is worn. return x2<>0 if worn
.TestRingWorn
 x2=RingTableMinus40
 add x2,x8
 x2=List3(x2)
 return
;
; Specific ring routines called from RingJump table.
; Return to RSIdentify in all cases.
;
 code -
.Teleportation
 code +
 x1=127
 and x1,ringtimer
 if x1<>0 then teleportationret		; teleport every 128 moves
 gosub @TeleportMe1			; see menu.txt (teleport scroll)
.teleportationret
 goto @RSIdentify
;---
 code -
.regeneration
 code +
 x1=3
 and x1,ringtimer
 if x1<>0 then regenret			; every 4 turns
 x1=1
 gosub @increasehitpoints		; add 1 to hit points
.regenret
 goto @RSIdentify
;---
 code -
.protection
 code +
; Ring of protection works in same way as wand of protection, except 
; that it repeatedly triggers the shield while the ring is worn.
 if playershieldcounter=0 then triggershield
 if playershieldcounter<65000 then protectionret
.triggershield
 playershieldcounter=3			; set countdown time for shield
.protectionret
 goto @RSIdentify
;---
 code -
.leech
 code +
 x1=127
 and x1,ringtimer
 if x1<>0 then leechret			; xp drain every 128 moves
 gosub @subxp
.leechret
 goto @RSIdentify
;---
 code -
.hunger
 code +
 x1=3
 and x1,ringtimer
 if x1<>0 then hungerret		; every 4 turns
 x1=1
 gosub @decreasehitpoints		; sub 1 from hit points
.hungerret
 goto @RSIdentify
;---
 code -
.invisibility
 code +
 x1=7
 and x1,ringtimer
 gosub flashplayer
 goto @RSIdentify
;---
; used as a subroutine because it is called by ring and potion of 
; invisibility...
; on entry, if x1 contains zero, then show the player as invisible, 
; otherwise, show the player as solid.
.flashplayer
 &v6=WordWS(WordPlayer1SpriteOffset)
 v1=DataPtrOffset
 add v1,v6				; v1=hi word
 v2=LoDataPtrOffset
 add v2,v6				; v2=lo word
;
; show invisible sprite on frame 0
 if x1<>0 then solidsprite
 &PlayerHiDataPtr=SpriteTable(v1)
 &PlayerLoDataPtr=SpriteTable(v2)	; save old sprite data ptr
 x1=InvisLoDataPtr
 &SpriteTable(v1)=x1
 x1=InvisHiDataPtr
 &SpriteTable(v2)=x1			; set to invis. sprite
 goto invisret
;
; show solid sprite on frame 1
.solidsprite
 if x1<>1 then invisret
 &SpriteTable(v1)=PlayerHiDataPtr
 &SpriteTable(v2)=PlayerLoDataPtr	; restore old sprite data ptr
;
.invisret
 return
;---
; reset player's hit points to maximum
.resethitpoints
 &v6=WordWS(WordPlayer1SpriteOffset)
 v1=hitpointoffset
 add v1,v6
.rhp1
 &SpriteTable(v1)=MaxPlayerHitPoints
 return
;=====
;---
; add x1 to player hit points
.increasehitpoints
 &v6=WordWS(WordPlayer1SpriteOffset)
 v1=hitpointoffset
 add v1,v6
 &v2=SpriteTable(v1)			; v2=player hit points
 add v2,x1				; add x1 increment
 if v2>MaxPlayerHitPoints then rhp1	; don't go over max hp
 &SpriteTable(v1)=v2
.ihpret
 return
;---
; sub x1 from player hit points
.decreasehitpoints
 &v6=WordWS(WordPlayer1SpriteOffset)
 v1=hitpointoffset
 add v1,v6
 &v2=SpriteTable(v1)			; v2=player hit points
 sub v2,x1				; sub x1 decrement
 if v2=0 then dhpdead			; zero - dead
 if v2>MaxPlayerHitPoints then dhpdead	; underflow - dead
 &SpriteTable(v1)=v2
 return
;
;******************************************************************
;* Player is killed by energy drain. Unsure what to do here -     *
;* can't call dodamagedestroy, since Perm/TempFixedSprite not set *
;* up...							  *
;******************************************************************
.dhpdead
 code -
 prs "DEAD IN DECREASEHITPOINTS "
 code +
 gosub @DisplayFrame
 gosub @LongDelay
 return
;---
.BlockSprite
 &TempMovedSprite(XSpeedOffset)=c0 ; monsters blocked by everything
 &TempMovedSprite(YSpeedOffset)=c0
 &x1=WordWs(WordXPosSave)
 &TempMovedSprite(XPosOffset)=x1
 &x1=WordWs(WordYPosSave)
 &TempMovedSprite(YPosOffset)=x1
 return
;---
.MonsterBlocked
 x1=TempMovedSprite(AddDirOffset)
 gosub @SignExtendX1
 x2=NextAddDirTableOffset
 add x2,x1
 x1=list7(x2)
 TempMovedSprite(AddDirOffset)=x1
 TempMovedSprite(DistanceOffset)=c0
 return
;---
.MonsterNotBlocked
; sprite can move ok - add to distance travelled, and
; if AddDirOffset is set, eventually stop moving in that direction
 x1=TempMovedSprite(DistanceOffset)
 add x1,c1
 TempMovedSprite(DistanceOffset)=x1
 x2=TempMovedSprite(AddDirOffset)
 if x2=0 then MonsterNotBlockedRet
 if x1>8 then @MonsterBlocked ; max distance monster can move
; in a direction not directly towards the player without reconsidering

.MonsterNotBlockedRet
 return

.LandABlow
 x1=TempMovedSprite(TimeToNextBlowOffset)
 sub x1,c1
 if x1<250 then @FGSFighting1
;
; monster hitting user?
 &x1=TempFixedSprite(NameOffset)
 if x1<>user then targetisnotuser
 gosub @SpecialCombat			; any special cases before hit?
 gosub @doesmonsterhit			; will monster hit or miss?
 if x1=false then FGSFighting1		; missed!
;
;=====
; monster now hits user. is user weak etc.?
 x8=ringdamage
 gosub @TestRingWorn
 if x2=0 then targetisnotuser
 x1=ringundead
 gosub @discoveruse
 &x1=TempMovedSprite(BlowStrengthOffset)
 add x1,x1				; twice damage if damage 
 goto damagetarget			; ring is worn!
;
; do damage to fixed sprite
.targetisnotuser
 &x1=TempMovedSprite(BlowStrengthOffset)
.damagetarget
;=====
;
; user hitting monster?
 &x2=TempMovedSprite(NameOffset)
 if x2<>user then attackerisnotuser	; add to damage if user 
 gosub @adjustuserstrength		; is using a weapon
.attackerisnotuser
;
 gosub @DoDamageX1
 x1=PermMovedSprite(TimeBetweenBlowsOffset)
;
.FGSFighting1
 TempMovedSprite(TimeToNextBlowOffset)=x1
 return
;---
; Special combat routines for stealing things etc.
.SpecialCombat
;
 &x1=TempMovedSprite(NameOffset)	; name of attacker
 if x1<>leprechaun then @sahnotleprechaun
 if goldpieces=0 then @sahnotleprechaun	; nothing worth stealing!
 x1=TempMovedSprite(RunAwayOffset)
 if x1<>0 then @sahnotleprechaun	; retreating (has just attacked)
 code -
 random x1
 code +
 x3=x1					; preserve x1 for later
 x2=15
 and x1,x2
 add x1,x2
 TempMovedSprite(RunAwayOffset)=x1	; retreat for x1 moves
 x1=x3					; recover x1
 x2=127
 and x1,x2
 add x1,x2
 if x1<GoldPieces then oktosteal
 x1=GoldPieces
.oktosteal
 sub GoldPieces,x1			; steal 127-254 gold pieces
 &x2=TempMovedSprite(WealthOffset)
 add x2,x1
 &TempMovedSprite(WealthOffset)=x2	; add to wealth
 m1=1000
 goto @AddMessageToOutputBuffer		; "your purse feels lighter"
.sahnotleprechaun
;
 &x1=TempMovedSprite(NameOffset)	; name of attacker
 if x1<>Nymph then sahnotnymph
 x1=TempMovedSprite(RunAwayOffset)
 if x1<>0 then sahnotNymph		; retreating (has just attacked)
 x8=true				; don't charm cursed armour
 gosub @DestroyArmour1
 if m1=820 then sahnotnymph		; no armour wielded to charm off!
 code -
 random x1
 code +
 x2=15
 and x1,x2
 add x1,x2
 TempMovedSprite(RunAwayOffset)=x1	; retreat for x1 moves
 m1=1001
 goto @AddMessageToOutputBuffer		; "nymph charms off your armour"
.sahnotnymph
;
.sahret
 return
;---
; Monster is about to hit user. Work out the probability of 
; a hit or miss, and return x1=TRUE if it's a hit.
.DoesMonsterHit
;
;=====
; undead protection
 &x1=TempMovedSprite(NameOffset)
 if x1=ghost then dmundead
 if x1=ghoul then dmundead
 if x1=mummy then dmundead
 if x1<>skeleton then dmnotundead
.dmundead
 x8=ringundead
 gosub @TestRingWorn
 if x2=0 then dmnotundead
 x1=ringundead
 gosub @discoveruse
 goto @preventhit			; wearing ring
.dmnotundead
;
; fire protection against various missiles
 x8=ringfireprotect
 gosub @TestRingWorn
 if x2=0 then dmhnotfire		; not wearing ring
 x1=ringfireprotect
 gosub @discoveruse
 &x1=TempMovedSprite(NameOffset)
 if x1=5 then @preventhit		; demon's missile
 if x1=6 then @preventhit		; dynamite wand
.dmhnotfire
;
; cold protection against various missiles
 x8=ringcoldprotect
 gosub @TestRingWorn
 if x2=0 then dmhnotcold		; not wearing ring
 x1=ringcoldprotect
 gosub @discoveruse
 &x1=TempMovedSprite(NameOffset)
; As yet, there are no cold missiles fired by other monsters. 
; When such missiles are introduced to the game, check for their 
; sprite numbers here...
 if x1=5 then @preventhit		; demon's missile
.dmhnotcold
;=====
;
; Wand of protection being used?
 if playershieldcounter=0 then nomagicshield
 if playershieldcounter<65000 then @PreventHit	; Yes - Prevent all hits
.nomagicshield
;
; Roll a hit dice and see if it "beats" the armour class...
 code -
 random x2
 code +
 x3=15
 and x2,x3				; hit dice 0-15
 sub x2,ArmourClass
 if x2>65000 then AllowHit		; it's a hit!
;
.PreventHit
 x1=false
 return
;
.AllowHit
 x1=true
 return
;---
; User is hitting a monster. Adjust strength x1 for weapons used etc.
.adjustuserstrength
;
 if blackhandflag=false then noblackhand
 blackhandflag=true
 x1=255					; target is as good as dead!
 goto @ausret
.noblackhand
;
 x2=weaponclass
 add x2,x2
 add x2,x2
 add x2,weaponclass			; weaponclass*5 is more realistic
;
 add x1,x2				; Sprite Strength + 5WC
;
;=====
 x8=ringstrength
 gosub @TestRingWorn
 if x2=0 then ausret			; not wearing ring
 x8=x1					; save x1
 x1=ringstrength
 gosub @discoveruse
 x1=40
 add x1,x8				; add WC of 8. (5*8=40)
;=====
;
.ausret
 return
;---
; calc both ArmourClass and WeaponClass
.CalcACWC
 gosub CalcWeaponClass
;---
; Return ArmourClass=Armour class (0 is invincible)
.CalcArmourClass
 ArmourClass=InitialArmourClass
 x7=1
 gosub @calcstrength			; x5=total str body armour
 sub ArmourClass,x5
 x7=2
 gosub @calcstrength			; x5=total str accessory armour
 sub ArmourClass,x5
 if ArmourClass<65000 then CACRet	; (in case of underflow)
 ArmourClass=0
.CACRet
 return
;---
; return WeaponClass=weapon class (greater x8 means more weapon strength)
.CalcWeaponClass
 x7=3
 gosub @calcstrength			; x5=total str weapons
 WeaponClass=x5
 if WeaponClass<65000 then CWCRet	; (in case of "magic" underflow)
 WeaponClass=0
.CWCRet
 return
;---
; calc x5 as total strength of objects with wielded type x7
.calcstrength
 x5=0
 x3=LLPlayerInv
.calcstrength1
 &x4=LL(x3)
 if x4=0 then @calcstrengthend
 x1=InvWieldedOffset
 add x1,x4
 x1=LL(x1)				; get wielded status
 if x1<>x7 then @csnotwieldtype		; now correct wield type
;
; we are wielding armour. add strength
 x1=InvStrOffset
 add x1,x4
 x1=LL(x1)
 add x5,x1				; add strength
;
; add magic adjustment (if any)
 x1=InvMagicOffset
 add x1,x4
 x1=LL(x1)
 gosub @signextendx1
 add x5,x1				; add magic adjustment
;
.csnotwieldtype
 x3=x4 					; previous entry
 goto @calcstrength1			; not last entry
.calcstrengthend
 return
;---
;=====
; Special effects concerning player's sprite (e.g. flashing 
; when invisible etc.)
; It may seem obvious to put such code in SpecialActivate, but 
; this does not work, since the player's sprite pointers appear 
; to be reset immediately after.
;
.SpecialPlayerSprite
;
; invisibility potion repeatedly uses same routine as invisibility
; ring until the duration timer runs out
 x1=2
 and x1,StairsDissolve
 if StairsDissolve>0 then SPS1
 if invisibilitytimer=false then noinvisibility
 sub invisibilitytimer,c1		; dec invisibility timer
; make sure the player is visible when the potion wears off by 
; ignoring the last iteration of the timer
 if invisibilitytimer=false then noinvisibility
 x1=7
 and x1,invisibilitytimer
.SPS1
 gosub @flashplayer			; pulse player's sprite
.noinvisibility
;
; Handle any Adjustments to player's speed...
; first, get the address of the player speed offset for use with 
; potions of speed and slowness
;
 ByteWS(BytePlayerSpeed)=c4		; set initial default speed
 ByteWS(ByteScrollStep)=c4		; and scroll speed
;
; If player is moving fast, then SET twice normal speed offset
 if SpeedTimer=0 then NotSpeed
 sub SpeedTimer,c1
 x1=8
 ByteWS(BytePlayerSpeed)=x1		; speed=8
 ByteWS(ByteScrollStep)=x1
.NotSpeed
;
; If player is moving slow, then HALF the PRESENT speed offset
 if SlowTimer=0 then @NotSlow
 sub SlowTimer,c1
;
; NB: Code concerning speed is specially written so that if both 
; potions of speed and slowness are in effect, then they will 
; cancel each other out...
;
 x1=ByteWS(BytePlayerSpeed)		; get current speed,
 x2=2
 gosub @x1divx2				; half it,
 ByteWS(BytePlayerSpeed)=x4		; and stick the result back
 if SlowTimer<>0 then NotSlow
;
; Potion of slowness has just worn off, so make sure the player is 
; put back on a 4 pixel boundary
 &v6=WordWS(WordPlayer1SpriteOffset)
 v2=XPosOffset
 add v2,v6				; v2=Pointer to x pos
 v3=YPosOffset
 add v3,v6				; v3=Pointer to y pos
 x3=65532				; mask out bits 0 & 1.
 &x1=SpriteTable(v2)			; get x pos
 and x1,x3				; align it
 &SpriteTable(v2)=x1			; and put it back
 &x1=SpriteTable(v3)			; get y pos
 and x1,x3				; align it
 &SpriteTable(v3)=x1			; and put it back
;
.NotSlow
;
.spsret
 return
;---
; Routines that affect joystick movement...
;
; NB: Two joystick status bytes are now used so that one can be 
; set by the interrupt (ByteTrueJoystickStatus) and the other 
; can be set or distorted by the Acode (ByteJoystickStatus).
;
; This is to allow the status to be changed without the interrupt 
; reseting it before it is processed.
;
.SpecialMovements
;
; is player on a down staircase?
 if PlayerX<DownStairsX then SMNotDown
 if PlayerY<DownStairsY then SMNotDown
 x1=16
 add x1,DownStairsX
 if PlayerX>x1 then SMNotDown
 x1=8
 add x1,DownStairsY
 if PlayerY>x1 then SMNotDown
; on a down stairs - paralyse whilst any graphics goes on,
 ByteWS(ByteJoystickStatus)=c0
 add StairsDissolve,c1
 if StairsDissolve<32 then SMNotDown ;**16
; and if dissolve has finished, move onto new level
 gosub @SaveLevelContents
 add level,c1
;; gosub @RestoreLevelContents
 goto @NewLevel

.SMNotDown
; is player on an up staircase?
 if PlayerX<UpStairsX then SMNotUp
 if PlayerY<UpStairsY then SMNotUp
 x1=8
 add x1,UpStairsX
 if PlayerX>x1 then SMNotUp
 x1=8
 add x1,UpStairsY
 if PlayerY>x1 then SMNotUp
; on an up staircase - paralyse whilst any graphics goes on,
 if level=1 then SMNotUp ; can't go up from top level at present
 ByteWS(ByteJoystickStatus)=c0
 add StairsDissolve,c1
 if StairsDissolve<16 then SMNotDown
; and if dissolve has finished, move onto new level
 gosub @SaveLevelContents
 sub level,c1
;; gosub @RestoreLevelContents
 goto @NewLevel

.SMNotUp
; If player is paralysed, then clear joystick status
 if ParalysisTimer=0 then NotParalysed
 sub ParalysisTimer,c1
 ByteWS(ByteJoystickStatus)=c0
 goto @SMRet
.NotParalysed
;
; If player is pissed, then distort joystick status
 if BoozeTimer=0 then NotDrunk
 sub BoozeTimer,c1
 x1=4
 and x1,BoozeTimer
 if x1<>0 then NotDrunk			; toggle control every 4 moves
 code -
 random x1				; get a random direction
 code +
 x2=7					; mask off the unwanted bits
 and x1,x2
 ByteWS(ByteJoystickStatus)=x1		; and set the new status
 goto @SMRet
.NotDrunk
;
; If player is confused, then reverse joystick status
 if ConfusionTimer=0 then @NotConfused
 sub ConfusionTimer,c1
 x1=ByteWS(ByteTrueJoystickStatus)	; x1 is current status
 x4=x1
 x3=240
 and x4,x3				; x4=top 4 bits
 x2=x1
 and x2,c3				; x2=up & down bits
 if x2=0 then NoVerticalConfusion
 xor x2,c3				; swap up & down bits
.NoVerticalConfusion
 x3=12
 and x1,x3				; x1=left & right bits
 if x1=0 then NoHorizontalConfusion
 xor x1,x3				; swap left & right bits
.NoHorizontalConfusion
 or x1,x2				; combine vertical & horizontal
 or x1,x4				; bits and merge with top 4 bits.
 ByteWS(ByteJoystickStatus)=x1		; set new status
 goto @SMRet
.NotConfused
;
; Movement is normal...
 x1=ByteWS(ByteTrueJoystickStatus)	; get true status from interrupt
 ByteWS(ByteJoystickStatus)=x1		; set status to be used for 
;					; movement
.SMRet
 return
;=====
;---
.SpecialActivate
; TempMovedSprite (of name ACTOR) has just been activated.
; position x,y; speed
; Return v1=0 if it is not to move normally.
;
 if actor<>user then @notactivateuser
;
; heroism potion adds heroismvalue to hit points at regular intervals
 if heroismtimer=false then noheroism
 sub heroismtimer,c1			; dec heroism timer
 x1=7
 and x1,heroismtimer
 if x1<>0 then noheroism		; every 8 turns
 x1=heroismvalue
 gosub @increasehitpoints		; add heroismvalue to hit points
.noheroism
;
; any scrolls to be activated which couldn't be handled from 
; the menu?
; fire scroll...
 if firescrollflag=false then nofirescroll
 firescrollflag=0
 v1=playerx
 v2=playery
 v3=0					; xspeed
 v4=1					; yspeed (to trigger collision)
 v5=6					; player-colliding exp missile
 gosub @MCSetUpNewSprite
 x2=SourceWeaponOffset
 add x2,v6
 x1=255
 SpriteTable(x2)=x1			; missile source type="monster"
 return
.nofirescroll
;
; magic shield?
 return
; if playershieldcounter=0 then @Playeractivateret
; if playershieldcounter>65000 then @activateret ; (just in case!)
; sub playershieldcounter,c1
; x1=playershieldcounter
; and x1,c3
; if x1<>0 then @activateret		; pulsing shield
; v1=playerx
; v2=playery
; v3=0					; xspeed
; v4=0					; yspeed
; v5=3					; sprite no. for explosion
; goto @MCStartBigExplosion
;
.PlayerActivateRet
 return

.notactivateuser
;---
 if actor<>demon then @notactivatedemon
;
; Shall we fire a missile?
 code -
 random x1
 code +
 if x1>12 then @activateret		; No missiles
;
; Fire a missile...
 &v3=TempMovedSprite(XSpeedOffset)
 &v4=TempMovedSprite(YSpeedOffset)	; Get x,y speed of demon
 x1=v3
 add x1,v4
 if x1=0 then @activateret		; No movement, so no fireballs
;
; Position the missile AHEAD of the demon...
 &v1=TempMovedSprite(XPosOffset)
 &v2=TempMovedSprite(YPosOffset)	; Get x,y of demon
 add v1,v3				; Start the fireball ahead
 add v2,v4				; of the demon
;
; Now work out the x,y speed of the missile, bearing in mind that 
; the demon may be moving at slow-speed if cursed.
 if v3=0 then NoDemonXSpeed
 if v3>65000 then DemonXSpeedNeg
 v3=12					; X speed is +12
 goto NoDemonXSpeed
.DemonXSpeedNeg
 v3=65524				; X speed is -12
.NoDemonXSpeed
;
 if v4=0 then NoDemonYSpeed
 if v4>65000 then DemonYSpeedNeg
 v4=12					; Y speed is +12
 goto NoDemonYSpeed
.DemonYSpeedNeg
 v4=65524				; Y speed is -12
.NoDemonYSpeed
;
; Away we go...
 v5=5					; player-colliding missile
 goto @MCSetUpNewSprite
;
.notactivatedemon
.activateret
; set v1=1 to continue movement processing in DAMSSpecials
 v1=1
;
 return
;---
.saveLevelContents
; save contents of LEVEL to linked list.
; First, destroy any existing contents of this linked list...
 ObjectInfo=LLLevel0Save
 x1=level
 x2=LLEntrySize
 gosub @MultX1X2
 add ObjectInfo,x1

push ObjectInfo
 gosub @DestroyLL
pop ObjectInfo

; now save level contents to the linked list...
 l0=ObjectInfo ; ll we're writing to.
 x4=SpriteCurrentSize ; offset in SpriteTable, ignoring player.
.SaveLevelLoop
 x3=LLFree ; write ptr
 &x1=SpriteTable(x4)
 if x1=0 then SLLNullObject
push l0
 gosub @SaveLLObject
pop l0
.SLLNullObject

 x1=SpriteCurrentSize
 add x4,x1
 if x4<SpriteTableSize then SaveLevelLoop

 x1=2
 add x1,l0
 &LL(x1)=MapHiRandomSeed
 add x1,c2
 &LL(x1)=MapLoRandomSeed
 return
;---
.SaveLLObject
; save the details of object SpriteTable(x4) to LL(x3)
 add x3,c2 ; skip LL chain ptr

 x1=SpriteNumOffset ; nameoffset ; read ptr
 add x1,x4
 x2=SpriteTable(x1)
 LL(x3)=x2 ; write in name of sprite
 add x3,c1

 x1=XPosOffset
 add x1,x4
 &x2=SpriteTable(x1)
; convert to cell-based...
 asr x2
 asr x2
 asr x2
 asr x2
 LL(x3)=x2 ; write in x pos
 add x3,c1

 x1=YPosOffset
 add x1,x4
 &x2=SpriteTable(x1)
; convert to cell-based...
 asr x2
 asr x2
 asr x2
 asr x2
 LL(x3)=x2 ; write in y pos
 add x3,c1

 x1=MagicOffset
 add x1,x4
 x2=SpriteTable(x1)
 LL(x3)=x2 ; write in magic adjustment
 add x3,c1

 x1=CursedOffset
 add x1,x4
 x2=SpriteTable(x1)
 LL(x3)=x2 ; write in cursed adjustment
 add x3,c1

 x1=WealthOffset
 add x1,x4
 x2=SpriteTable(x1)
 LL(x3)=x2 ; write in wealth adjustment
 add x3,c1

 x1=HitPointOffset
 add x1,x4
 &x2=SpriteTable(x1)
; reduce precision of hit points (copes with 0..8192)...
 asr x2
 asr x2
 asr x2
 asr x2
 asr x2
 LL(x3)=x2 ; write in hit point value.
 add x3,c1



 add x3,c1 ; make NameOffset even...


 x1=NameOffset ; SpriteNumOffset
 add x1,x4
 &x2=SpriteTable(x1)
 &LL(x3)=x2
 add x3,c2

 gosub @AddToLL ; adds LL(LLFree) to LL(L0)
 return

;---

.RestoreLevelContents
; restore contents of LEVEL from linked list.
;; gosub @ClearSpriteTable ; destroy all sprites etc, set up player position

; ObjectInfo=LLLevel1Save
; add ObjectInfo,Level
; add ObjectInfo,Level
; sub ObjectInfo,c2 ; levels are numbered 1..
 ObjectInfo=LLLevel0Save
 x1=level
 x2=LLEntrySize
 gosub @MultX1X2
 add ObjectInfo,x1

; and bring back all the saved items for this level...
 l0=ObjectInfo ; ptr to original table.
 &ObjectInfo=LL(ObjectInfo)
 x1=2
 add x1,l0
 &x2=LL(x1)
 if x2=0 then @BrandNewLevel
 MapHiRandomSeed=x2
 add x1,c2
 &MapLoRandomSeed=LL(x1)
 &LongWS(HiLongRandomSeed)=MapHiRandomSeed
 &LongWS(LoLongRandomSeed)=MapLoRandomSeed

 if ObjectInfo=0 then @BrandNewLevel ; InitSpriteTable ; set up a new level

 push l0
 push ObjectInfo
  gosub @SetUpMap
 pop ObjectInfo
 pop l0

 gosub @ClearSpriteTable ; destroy all sprites etc, set up player position


.RLCLoop
 push ObjectInfo
  gosub @RLCObject
 pop ObjectInfo
 &ObjectInfo=LL(ObjectInfo)
 if ObjectInfo<>0 then RLCLoop
 StairsDissolve=0
 return
;-----
.BrandNewLevel
 gosub @SetUpMap
 gosub @InitSpriteTable
 return
;-----
.RLCObject
; restore object saved at LL(ObjectInfo)
 x3=ObjectInfo

 add x3,c2 ; skip LL chain ptr

 v5=LL(x3) ; get spriteNum to use
 add x3,c1

 v1=LL(x3) ; x
 add v1,v1
 add v1,v1
 add v1,v1
 add v1,v1
 add x3,c1

 v2=LL(x3) ; y
 add v2,v2
 add v2,v2
 add v2,v2
 add v2,v2
 add x3,c1

 v3=0
 v4=0
 gosub @MCSetUpNewSprite

; SpriteTable(v6) is control block for sprite set up.

 x1=MagicOffset
 add x1,v6
 x2=LL(x3) ; magic adjustment
 add x3,c1
 SpriteTable(x1)=x2

 x1=CursedOffset
 add x1,v6
 x2=LL(x3) ; cursed adjustment
 add x3,c1
 SpriteTable(x1)=x2

 x1=WealthOffset
 add x1,x4
 x2=LL(x3) ; wealth adjustment
 add x3,c1
 SpriteTable(x1)=x2

 x1=HitPointOffset
 add x1,x4
 x2=LL(x3)
 add x3,c1
 add x2,x2
 add x2,x2
 add x2,x2
 add x2,x2
 add x2,x2
 SpriteTable(x1)=x2

 add x3,c1 ; make nameoffset read from even addr...

 x1=nameoffset
 add x1,x4
 &x2=LL(x3)
 &SpriteTable(x1)=x2

 return
;---
.DestroyLL
; destroy LL whose first entry is LL(ObjectInfo)

; don't add header to free space map, as we'll need it later...
 &x1=LL(ObjectInfo)
 &LL(objectInfo)=c0 ; delete header
 ObjectInfo=x1

; but DO add any chained entries to the FS map.
.DestroyLLLoop
 if ObjectInfo=0 then DestroyLLRet ; end of chain to delete
 &LL(LLFree)=ObjectInfo
 &x1=LL(ObjectInfo) ; next item in chain to be deleted
 &LL(ObjectInfo)=c0 ; item becomes end of free space
 ObjectInfo=x1
 goto DestroyLLLoop

.DestroyLLRet
 return
;---
