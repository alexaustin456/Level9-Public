* Atari ST driver
* Copyright (C) 1986 Level 9 Computing
* M.J.Austin 20/7/86

* note - if 'graphics' is defined elsewhere (as anything),
* the appropriate code will be defined in here.
* To make this driver public domain, simply
* remove all the code assembled within the 'ifd' instruction

* Some programs need to know which machine they are running
* on (e.g. to allow for different assemblers)
* this is catered for by the following constants
* THIS FACILITY SHOULD BE USED AS LITTLE AS POSSIBLE

ilsize equr d2
ilhighwater equr d3
ilpos equr d4

*!!! opt d+ * turn on symbol table dump

amiga   equ 1
st      equ 2

computertype    equ st


*---
waitkey
 move.b #osrdchdcode,d0
 bsr driver
 tst.b (a6)
 beq.s waitkey
 rts
*---

* character constants

crlf equ 13
cr equ 13
lf equ 10
bs equ 8
eof equ 26
cursorleft equ 2 *  ^B - Perfect Writer type control keys
cursorright equ 6 * ^F - used as values generated by cursor keys
cursorup equ 16   * ^P
cursordown equ 14 * ^N
pageoff equ 15
helpkey equ 21
quitkey equ 17 * also = control-Q
autorunkey equ 18
logkey equ 19
undokey equ 20

true equ $ff

* driver constants

initdcode equ 0
checksumdcode equ 1
oswrchdcode equ 2
osrdchdcode equ 3
inputlinedcode equ 4
savedcode equ 5
loaddcode equ 6
settextdcode equ 7
taskinitdcode equ 8
returntoosdcode equ 9
chainprogramdcode equ 11
randomnumberdcode equ 12

getclockdcode equ 14
;
clgdcode equ 16
linedcode equ 17
filldcode equ 18
chgcoldcode equ 19
finishpicturedcode equ 20

ramsavedcode equ 22
ramloaddcode equ 23
lenslokdisplaydcode equ 25

* equates for BDOS calls (ie Trap #1)

P_TERM_OLD      EQU 0           (should use $4C really)
C_CONIN EQU 1
C_CONOUT        EQU 2
C_AUXIN EQU 3
C_AUXOUT        EQU 4
C_PRNOUT        EQU 5
C_RAWIO EQU 6
C_RAWCIN        EQU 7
C_NECIN EQU 8
C_CONWS EQU 9
C_CONRS EQU $0A
C_CONIS EQU $0B
D_SETDRV        EQU $0E
C_CONOS EQU $10
C_PRNOS EQU $11
C_AUXIS EQU $12
C_AUXOS EQU $13
D_GETDRV        EQU $19
F_SETDTA        EQU $1A
_SUPER          EQU $20
T_GETDATE       EQU $2A
T_SETDATE       EQU $2B
T_GETTIME       EQU $2C
T_SETTIME       EQU $2D
F_GETDTA        EQU $2F
S_VERSION       EQU $30
P_TERMRES       EQU $31
D_FREE          EQU $36
D_CREATE        EQU $39
D_DELETE        EQU $3A
D_SETPATH       EQU $3B
F_CREATE        EQU $3C
F_OPEN          EQU $3D
F_CLOSE EQU $3E
F_READ          EQU $3F
F_WRITE EQU $40
F_DELETE        EQU $41
F_SEEK          EQU $42
F_ATTRIB        EQU $43
F_DUP           EQU $45
F_FORCE EQU $46
D_GETPATH       EQU $47
M_ALLOC EQU $48
M_FREE          EQU $49
M_SHRINK        EQU $4A
P_EXEC          EQU $4B
P_TERM          EQU $4C
F_SFIRST        EQU $4E
F_SNEXT EQU $4F
F_RENAME        EQU $56
F_DATIME        EQU $57

* Base Page Offsets
P_LOWTPA        EQU 0
P_HITPA EQU 4
P_TBASE EQU 8
P_TLEN          EQU $0C
P_DBASE EQU $10
P_DLEN          EQU $14
P_BBASE EQU $18
P_BLEN          EQU $1C
P_ENV           EQU $2C
P_CMDLIN        EQU $80

* Error codes
E_OK            EQU 0
ERROR           EQU -1
EDRVNR          EQU -2
EUNCMD          EQU -3
E_CRC           EQU -4
EBADRQ          EQU -5
E_SEEK          EQU -6
EMEDIA          EQU -7
ESECNF          EQU -8
EPAPER          EQU -9
EWRITF          EQU -10
EREADF          EQU -11
EGENRL          EQU -12
EWRPRO          EQU -13
E_CHNG          EQU -14
EUNDEV          EQU -15
EBADSF          EQU -16
EOTHER          EQU -17

EINVFN          EQU -32
EFILNF          EQU -33
EPTHNF          EQU -34
ENHNDL          EQU -35
EACCDN          EQU -36
EIHNDL          EQU -37
ENSMEM          EQU -39
EIMBA           EQU -40
EDRIVE          EQU -46
ENMFIL          EQU -49
ERANGE          EQU -64
EINTRN          EQU -65
EPLFMT          EQU -66
EGSBF           EQU -67

* BIOS calls (Trap #13) - Atari names are lower case
getmpb          equ 0
bconstat        equ 1
bconin          equ 2
bconout equ 3
rwabs           equ 4
setexc          equ 5
tickcal equ 6
getbpb          equ 7
bcostat equ 8
mediach equ 9
drvmap          equ 10
kbshift equ 11

* Extended BIOS calls (Trap #14)
initmous        equ 0
ssbrk           equ 1
_physbase       equ 2
_logbase        equ 3
_getRez equ 4
_setScreen      equ 5
_setPallete     equ 6
_setColor       equ 7
_floprd equ 8
_flopwr equ 9
_flopfmt        equ 10
midiws          equ 12
_mfprint        equ 13
iorec           equ 14
rsconf          equ 15
keytbl          equ 16
_random equ 17
_protobt        equ 18
_flopver        equ 19
scrdmp          equ 20
cursconf        equ 21
settime equ 22
gettime equ 23
bioskeys        equ 24
ikbdws          equ 25
jdisint equ 26
jenabint        equ 27
giaccess        equ 28
offgibit        equ 29
ongibit equ 30
xbtimer equ 31
dosound equ 32
setprt          equ 33
kbdvbase        equ 34
kbrate          equ 35
_prtblk equ 36
vsync           equ 37
supexec equ 38
puntaes equ 39


* System Variables
proc_lives      equ $380
proc_dregs      equ $384
proc_aregs      equ $3a4
proc_enum       equ $3c4
proc_usp        equ $3c8
proc_stk        equ $3cc
etv_timer       equ $400
etv_critic      equ $404
etv_term        equ $408
etv_xtra        equ $40c
memvalid        equ $420
memcntlr        equ $424
resvalid        equ $426
resvector       equ $42a
phystop equ $42e
_membot equ $432
_memtop equ $436
memval2 equ $43a
flock           equ $43e
seekrate        equ $440
_timr_ms        equ $442
_fverify        equ $444
_bootdev        equ $446
palmode equ $448
defshiftmd      equ $44a
sshiftmd        equ $44c
_v_bas_ad       equ $44e
vblsem          equ $452
nvbls           equ $454
_vblqueue       equ $456
colorptr        equ $45a
screenpt        equ $45e
_vbclock        equ $462
_frclock        equ $466
hdv_init        equ $46a
swv_vec equ $46e
hdv_bpb equ $472
hdv_rw          equ $476
hdv_boot        equ $47a
hdv_mediach     equ $47e
_cmdload        equ $482
conterm equ $484
themd           equ $48e
savptr          equ $4a2
_nflops equ $4a6
sav_context     equ $4ae
_bufl           equ $4b4
_hz_200 equ $4bc
the_env equ $4be
_drvbits        equ $4c4
_dskbufp        equ $4c6
_prt_cnt        equ $4ee
_sysbase        equ $4f2
_shell_p        equ $4f6
end_os          equ $4fa
exec_os equ $4fe

**n********
* Macros *
**********

* call the BDOS - requires 1 parameter:
* the function number
call_bdos       macro
                move.w #\1,-(sp)
*>>                lea     macrospsave,a0
*>>                move.l  sp,(a0)
                trap #1
*>>                move.l  macrospsave,sp
*>>                cmp.l #$30000,sp
*>>                bls bdosmacroerror
              endm

bdosmacroerror
bdosmacroiloop
 bra.s bdosmacroiloop

* call the BIOS - requires 1 parameter:
* the function number
call_bios       macro
                move.w #\1,-(sp)
*>>                lea     macrospsave,a0
*>>                move.l sp,(a0)
                trap #13
*>>                move.l  macrospsave,sp
                endm

* call the extended BIOS - requires 1 parameter:
* the function number
call_ebios      macro
                move.w  #\1,-(sp)
*>>                lea     macrospsave(pc),a0
*>>                move.l  sp,(a0)
                trap    #14
*>>                move.l  macrospsave(pc),sp
                endm

* print string whose address is given by parameter
*prs macro
* pea \1(pc)
* call_bdos c_conws
* addq.l #6,sp
* endm

macrospsave dc.l 0
suspendtaskswap dc.w 0

**********************
* the Program Itself *
**********************


driver
* Standard entry point for all external routines
* Parameter block is pointed to by a6
* all registers preserved
 movem.l d0-d7/a0-a6,-(a7) * overkill ?
 pea driverret(pc) * return address from routines
 cmp.b #initdcode,d0
 beq init
 cmp.b #checksumdcode,d0
 beq calcchecksum
 cmp.b #oswrchdcode,d0
 beq driveroswrch
 cmp.b #osrdchdcode,d0
 beq driverosrdch
 cmp.b #savedcode,d0
 beq driversavefile
 cmp.b #loaddcode,d0
 beq driverloadfile
 cmp.b #settextdcode,d0
 beq settext

 cmp.b #taskinitdcode,d0
 beq resetginttask
 cmp.b #inputlinedcode,d0
 beq driverinputline
 cmp.b #returntoosdcode,d0
 beq closedown
 cmp.b #randomnumberdcode,d0
 beq randomnumber

 cmp.b #getclockdcode,d0
 beq getclock
 cmp.b #clgdcode,d0
 beq driverclg
 cmp.b #linedcode,d0
 beq line
 cmp.b #filldcode,d0
 beq fill
 cmp.b #chgcoldcode,d0
 beq driverchgcol
 cmp.b #finishpicturedcode,d0
 beq finishpicture

 cmp.b #ramsavedcode,d0
 beq ramsave
 cmp.b #ramloaddcode,d0
 beq ramload
 
 cmp.b #lenslokdisplaydcode,d0
 beq lenslokdisplay
 rts * nothing else, so return to driverret (i.e. next line!)
driverret
 movem.l (sp)+,d0-d7/a0-a6
 rts

*---
getclock
; return real time clock in list9(hi4,hi3,lo2,lo)
; approx 1/50 second per unit
 move.l realtimeclock,d0
 move.l d0,(a6)
 rts
*---
randomnumber
* return a random word
 move.w #17,-(sp)
 trap #14
 addq.l #2,sp
 move.w d0,(a6)
 rts
*---
lenslokdisplay
* On the screen !!!!
 bsr prs
 dc.b cr,'The code is: [',0
 even
 move.b #oswrchdcode,d0
 bsr driver * left hand character
 move.b $1(a6),d1
 move.b d1,(a6)
 bsr driver * right hand character
 bsr prs
 dc.b ']',cr,0
 even
 rts
*---
ramsave
 bsr initram
* copy workspace to ram
 move.l (a6),a0 * start address
 move.l $8(a6),a1 * start of destination block
ramsave1
 move.l (a0)+,(a1)+
 cmp.l $4(a6),a0 * end address
 bls.s ramsave1 * unsigned <
 rts
*---
ramload
 bsr initram
 move.l (a6),a1 * start of workspace (destination)
 move.l $8(a6),a0 * start of save area (source)
ramload1
 move.l (a0)+,(a1)+
 cmp.l $4(a6),a1 * end address
 bls.s ramload1 * unsigned <
 rts

*---
initram
** for debugging, print addresses
* movem.l d0-d7/a0-a6,-(sp)
* move.l (a6),a0
* bsr hexlonga0
* move.l $4(a6),a0
* bsr hexlonga0
* move.l $8(a6),a0
* bsr hexlonga0
* move.b #13,d0
* bsr oswrch
* movem.l (sp)+,d0-d7/a0-a6


* (a6).l is start address
 move.l $4(a6),a1 * end address
* $8(a6).l * position in save memory
* now see if enough space in save memory
 sub.l (a6),a1 * get length to save
 add.l $8(a6),a1
* now d1.l=address of end of save memory
* compare with screen address-$1000 to see if enough memory
 move.l screenpointer,a0
 sub.l #$1000,a0
 cmp.l a0,a1
 bhi.s ramoverflow

* ok, so return
 rts
*---
ramoverflow
 move.b #$ff,(a6) * non-zero, indicating failure
 move.l (sp)+,d0 * remove return address, return to driver call
 rts
*---
returnzero
 move.b #0,(a6) * indicate failiure of operation
 rts
*---
closedown
* exit gracefully
 bsr prs
 dc.b cr
 dc.b "Do you really want to leave the game? ",0
 even
closedownloop
 bsr osrdch
 cmp.b #"y",d0
 beq.s cd1
 cmp.b #"Y",d0
 beq.s cd1
 cmp.b #"n",d0
 beq.s noclosedown
 cmp.b #"N",d0
 bne.s closedownloop
noclosedown
 bsr prs
 dc.b cr,0
 even
 clr.b d0 * avoid returning any values to caller (of osrdch)
 rts
*
cd1
 ifd graphics
  move.b #settextdcode,d0
  bsr killmultitasking
  bsr driver
 endc * if graphics

 bra returntogem
*---
 ifd graphics
killmultitasking
* is multi-tasking running?
 move.l osvblhandler(pc),d0
 beq.s closenotasks
 move.l d0,$70 * restore os irq vector
closenotasks
 move.l oshblhandler(pc),d0
 beq.s closenosplit
 move.l d0,$68 * restore fast vector
closenosplit
* all split screens disabled (if they werew running)
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s closedownhires * changing to med res from lowres reboots!
* Now set medium resolution,
* so OS will print 80 column text correctly
 move.w #1,-(sp) * medium resolution
 move.l #-1,-(sp) * retain physical base
 move.l #-1,-(sp) * retail logical base
* move.w #5,-(sp) * set screen
 call_ebios _setscreen
 add.l #12,sp

closedownhires
 lea defaultcolours,a0
 bra setuppalettea0
 endc * ifd graphics
*------
defaultcolours
 dc.w $777 * window background colour - white
 dc.w $700 * not used by gem - red
 dc.w $060 * desktop colour (when not covered by windows) - green
 dc.w $000 * text - black
*---
finishpicture
* nothing to do in lowres
 move.b screenresolution,d0
 cmp.b #hires,d0
 bne.s fpret
* in Hires mode, go through to differentiate shading
* patterns from each other
* change colour 02 on alternate lines to 00
 move.l #$92492492,d4 * pattern to replace with
 move.l screenpointer,a0
 move.b #96,d3 * y - number of lines (y direction)
fpnewline
 move.b #160,d2 * x - number of bytes in an x direction
fp1
 move.b #16,d0 * nnumber of pixels to do in a long
 move.l (a0),d1
fp2
 ror.l #1,d1
 bcs.s fp3
 ror.l #1,d1
 bcc.s fp4
 and.l #$3FFFFFFF,d1
* some experimental code added -----
 move.l d4,d5
 and.l #$c0000000,d5
 ror.l #2,d4 * shift replacement mask along
 or.l d5,d1
*---
* btst #0,d0 * x
* beq.s fp4
* or.l #$40000000,d1
 bra.s fp4

fp3
 ror.l #1,d1
fp4
 subq.b #1,d0
 bne.s fp2

 move.l d1,(a0)+
 subq.b #4,d2 * x - finished line ?
 bne.s fp1
* new line, skip this one
 add.l #160,a0
 subq.b #2,d3 * y
 bpl.s fpnewline
fpret
 rts


getscreenaddress
* return address of screen start in a0.l and d0.l
 call_ebios _physbase
 addq.l #2,sp
 move.l d0,a0
 rts
*---
*starttask
* initialse a new task with starting address of (a6).l
* task handles go 0,8,16,24,...
* Thus the task handle is merely the offset in the task
* control block
* structure of task control block
* is:
*tcbentrysize equ 16
*  **** address of next entry in TCB
*  **** end address of this entry in table
*  **** current stack pointer for task
*       (0000 if last value in table)
*  *    priority (not currently implemented)
*  *    not currently used
*  *    not currently used
*  *    not currently used
*  ...  stack space for task

* stack space required by this new task is $4(a6).l
* move.l $4(a6),d0
* add.l #tcbentrysize,d0 * d0.l is space required by new task tcb

* first scan through table for an empty space
* lea taskcontrolblock,a0 * current position in table
*starttask1
* move.l (a0),a1 * a1 is position of next entry in table
* beq.s lastentry * last entry in table
* where does this tcb entry end ?
* move.l $4(a0),a2
** is there a gap between this entry and the next ?
* sub.w a2,a1 * what is the gap between this entry and the next
* cmp.w d0,a1 * big enough for new tcb entry ?
* bcc.s starttask1 * unsigned >= 
*
* move.l (a0),a0 * move to next entry
* bra.s starttask1
*
**2lastentry
***2 (a0) is last entry in table,
* so append this tcb onto the end
*gottcbgap
* there is a gap in the tcb table at tcbentrysize(a0,d1)
* move.w d1,d2
* add.w #tcbentrysize,d2
** d2 is now pointer to vacant entry
** change reference of previous entry to point to it ...
* move.w d2,$4(a0,d1)
* and set up pointer of new entry to point to next
* element in the chain
* move.w d0,$4(a0,d2)
* and set up the stack pointer for it
* 
numswaps
 dc.w 0 * ??????
 even *?????
*---

resetginttask
 lea gintstacktop(pc),a0

 lea gintstart(pc),a1
 move.l a1,-(a0)
 move.w sr,-(a0)
 lea irqswaptaskend(pc),a1
 move.l a1,-(a0) * return address from ist1

 movem.l d0-d7/a0-a6,-(a0) * dummy stack values
 lea taskstackptr,a1
 move.l a0,(a1)
 rts
*---
setsupervisormode
 clr.l -(sp)
 call_bdos _super
 add.l #6,sp
* and check if in supervisor mode
 move.w sr,d0
 and.w #$2000,d0
 beq.s setsupervisormode * NO! *+@%*œ^%* operating system!
* d0 = old supervisor stack (See P.113 ST Internals for details)
 rts
*---
 ifd graphics
initialisetasks
* set up stack values for tasks
* the task for the program which called initdcode 
* is automatically set up, so ignore it at present
* first push on a ret address on to fire up the gint task
* first fake a status word as if from an exception vector
* first put system permamently into supervisor mode
 bsr.s setsupervisormode

 bsr resetginttask
* now set up the interrupt vector
* it doesn't matter if interrupts occur during the
* following bit of code ....
* now set up MY VBL interrupt handler routine
 tst.l osvblhandler
 bne.s vblalreadysetup
 move.l $70,d0 * address of OS routine
 lea osvblhandler,a0
 move.l d0,(a0)

 lea irqvblhandler,a0
 move.l a0,$70 * ... and enable my routine
vblalreadysetup
 rts
*---
 endc * ifd graphics, just before initialisetasks
snoozeend
 move.w (sp)+,d0
snoozeret
 rts
*---
snooze
 ifd graphics
 move.w d0,-(sp)
 move.b snoozesinceswap(pc),d0
 bne.s snoozeend
 move.w (sp)+,d0

 move.l a0,-(sp)
 lea snoozesinceswap,a0
 move.b #1,(a0) * prevent further snoozes in this time slot
 move.l (sp)+,a0

 move.w sr,-(sp) * simulate a irq
 bsr.s ist1
* and remove the sr value
 move.w (sp)+,sr
 endc * graphics
 rts

*irqswaptask
* have just received a VBL irq
* do a task swap, if needed
* and then jump to (osvblhandler)
* No registers to be corrupted, except sr
* first, reset snoozesinceswap

* move.l a0,-(sp)
*lea snoozesinceswap,a0
* clr.b (a0)
* move.l (sp)+,a0
* bsr.s ist1
irqswaptaskend
 move.l osvblhandler,-(sp)
 rts
*---
ist1
* can't interrupt the OS *(because it does all sorts of terrible
* things - like non-reentrant code etc.)
 movem.l d0-d7/a0-a6,-(sp) * from task just finished
 move.b drivergraphicsmode,d0
 beq.s istnoswap * false, so in text mode, so don't do task swapping

 lea taskstackptr,a0
 move.l (a0),d0 * stack pointer of other stack
 move.l sp,(a0) * save stack pointer
* and now do the task swap !!!!
 move.l d0,sp

istnoswap
 movem.l (sp)+,d0-d7/a0-a6 * restore reggies (for task to start)
istret
 rts
*---
init1
 lea cursorxpos,a0
 clr.b (a0)
 lea cursorypos,a0
 move.b #24,(a0) * bottom left is 0,24 here

 lea cyclicwriteptr,a0
 lea cyclicib,a1
 move.l a1,(a0)
 lea cyclicbufferstart,a0
 move.l a1,(a0)
 lea cyclicbufferend,a0
 lea cyclicibtop,a1
 move.l a1,(a0)
 lea cycliccharsused,a0
 clr.l (a0)
 rts
*---
init2
 bsr getscreenaddress
 lea screenpointer(pc),a0
 move.l d0,(a0)
* now before doing anything, clear out the screen
 move.b #27,d0 * turn off cursor to avoid leaving a block behind
 bsr bdososwrch
 move.b #"f",d0
 bsr bdososwrch
* and clear it!
 move.l screenpointer(pc),a0
 move.w #$8000,d0 * length to clear
 moveq.l #0,d1
cls1
 move.l d1,(a0)+
 subq.w #4,d0
 bpl.s cls1

 move.b #12,(a6)
 move.b #oswrchdcode,d0
 bsr driver

 lea scrolledlines,a0
 clr.b (a0)
* and what screen resolution are we in ?
 call_ebios _getrez * move.w #4,-(sp)
 addq.l #2,sp
* d0.b = 0 - low resolution, 1 = medium resolution, 2 = high res
 lea screenresolution(pc),a0
 cmp.b #2,d0
 beq.s inithires1
 move.b #0,d0 * always low res for graphics nowadays

inithires1
 move.b d0,(a0)
 lea screenheight(pc),a0
 move.w #absscreenheight,(a0)
 cmp.b #2,d0 * hi-res ?
 rts
*---
init
* .initialise
* first, some general purpose initialisation ---

* bsr prs
* dc.b 27,'v' * automatic overflow on
* dc.b 0
* even
 bsr init1
 ifd graphics
 bsr initialisetasks
 bsr seterrorvectors * address error and bus error etc.
 endc * graphics

 bsr init2
 ifd graphics
 bne initsplitscreen * no, so set up med-low res split screen
 endc

 move.w #absscreenheight*2,(a0) * hi-res height
initret
 rts
*---
*----------------------
seterrorvectors
* set up address error and bus error vectors
* to kill multi-tasking, then jump to os handler
* (or to a debugger if present)
* MUST BE IN SUPERVISOR MODE TO DO THIS
 rts * ************

 lea hardwareerrorhandler,a0
 lea oshardwareerrorvectors,a1
 lea $8,a2 * address of bus error vector (exception 2)
sev1
 move.l (a2),(a1)+
 move.l a0,(a2)+
 cmp.l #$18,a2
 bne.s sev1
 rts
*---
hardwareerrorhandler
* have got a hardware error, for some reason.
* kill multi-tasking and jump to os handler
* move.l d0,-(sp)
* move.l oshardwareerrorvectors,d0
* cmp.l #$18000,d0
* bls.s nodebugginginstalled
* move.l (sp)+,d0
* nasty kludge - always bus error handler:

 move.l oshardwareerrorvectors,-(sp)
 movem.l d0-d7/a0-a6,-(sp)
 bsr killmultitasking
 movem.l (sp)+,d0-d7/a0-a6
 rts * enter monitor at previously set up return address

*nodebugginginstalled
* move.l (sp)+,d0
* rte
*---
oshardwareerrorvectors
 dc.l 0 * bus error
 dc.l 0 * address error
 dc.l 0 * illegal instruction
 dc.l 0 * division by zero (!)
 dc.l 0 * one more for luck (chk instruction)
*---
*------------------------------
initgraphics
* have just switched to graphics mode from text mode
* (screen just cleared)
* set up anything necessary
* at present, just position cursor correctly for
* split screen useage
 lea drivergraphicsmode(pc),a0
 move.b #1,(a0)

 move.b #27,d0
 bsr bdososwrch
 move.b #'Y',d0
 bsr bdososwrch * position cursor
 move.b #32+24,d0
 bsr bdososwrch
 move.b #32+0,d0
 bsr bdososwrch * line 24,column 0
 rts
*---
calcchecksum
* calculate checksum of area between (a6).l and $4(a6).l
 move.l (a6),a0
 move.l $4(a6),a1
 sub.l a0,a1 * get a1=length
 addq.l #1,a1
 move.w a1,d2 * now d2=length
 move.b #0,d1 * checksum value
checksum1
 tst.w d2 * length
 beq.s checksumend
 move.b (a0)+,d0
 add.b d0,d1
 subq.w #1,d2 * dec length
 bra.s checksum1

checksumend
 move.b d1,(a6)
 rts

*---
autorunsize equ 20000
autorun
* get instructions from disk file
* is there a command file in this directory on the disk?
 bsr prs
 dc.b cr,"Looking for gameplay log on disk - 'LOG.BAT'",cr,0
 even
 move.l a6,-(sp)
 lea logdriverblock,a6
 move.l screenpointer,a0
 sub.l #autorunsize,a0 * !!!!!!!!??????
 move.l a0,(a6) * loading address
 move.b #loaddcode,d0
 bsr driver
 move.b (a6),d0
 bne autorunend * not loaded, so ignore command to start fetching
 bsr prs
 dc.b cr,"Executing instructions in file 'LOG.BAT'",cr,0
 even
 move.l $4(a6),a0 * end of batch file
 move.b #cr,(a0)+
 move.b #lf,(a0)+

 move.b #eof,(a0)+
 move.b #eof,(a0)+
 move.l (a6),a0
 lea batchptr,a1
 move.l a0,(a1) * current batch pointer
 lea executingcommandfile,a0
 move.b #1,(a0)
autorunend
 move.l (sp)+,a6
 rts

ardelay
* do a one-second delay, then continue
 move.l #200000,d0
ard1
 subq.l #1,d0
 bne.s ard1
 bra.s bc1 * get next character from command sequence

autorunagain
* reset batch pointer
 move.l screenpointer,a0
 sub.l #autorunsize,a0
 lea batchptr,a1
 move.l a0,(a1)

autoruninputline
 move.l batchptr,a0
* copy string into driverbuffer
 move.l a6,a1
bc1
 move.b (a0)+,d0
 cmp.b #lf,d0
 beq.s bc1 * ignore line feeds
 cmp.b #cr,d0
 beq.s bc2
 cmp.b #eof,d0
 beq autorunagain
 cmp.b #"*",d0
 beq.s ardelay
 move.b d0,(a1)+
 bsr oswrch * echo it
 bra.s bc1
bc2
* end of string, add terminator
 clr.b (a1)+
 lea batchptr,a1
 move.l a0,(a1)
 move.b #cr,d0
 bra oswrch * cr at end of input
*---
getfilename
 cmp.b #0,$8(a6) * check if filename was supplied
 bne gfret
 bsr prs
 dc.b cr,"Filename ? ",0
 even

 addq.l #8,a6 * put filename at address expected file handling
 bsr inputline
 subq.l #8,a6 * restore a6
gfret
 rts

driverloadfile
 bsr.s getfilename
* fall through to loadfile
loadfile
 bsr openrd
 tst.l d0
 bmi.s readerror
 bsr rdfile
 bsr closefile
 move.b #0,(a6) * signify load ok
 rts

driversavefile
 bsr.s getfilename
* fall through to savefile
savefile
 bsr createfile
 tst.l d0
 bpl savefile2
* file does not exist, so have to separately open it
 bsr openwrt
 tst.l d0
 bmi.s writeerror
savefile2
 bsr wrtfile
 bsr closefile
 move.b #0,(a6) * signify save ok
 rts

readerror
 bsr prs
 dc.b "Can't find file on disk.",cr,0
 even
 move.b #1,(a6) * signify load error
 rts

writeerror
 bsr prs
 dc.b "Save error.",cr,0
 even
 move.b #1,(a6) * signify save error
 rts

openrd
 move.w #0,-(sp) * open for read
open1
 move.l a6,a0 * a6 is buffer address
 addq.l #8,a0 * a6 was still buffer address
 move.l a0,-(sp)
 call_bdos f_open
 move.w d0,d4 * handle
 addq.l #8,sp
 rts

createfile
 move.w #0,-(sp) * zero attributes for a normal file
 move.l a6,a0 * buffer address
 addq.l #8,a0
 move.l a0,-(sp)
 call_bdos f_create
 move.w d0,d4 * handle
 addq.l #8,sp
 rts

openwrt
 move.w #1,-(sp) * open for write
 bra open1

rdfile
 move.l (a6),-(sp) * address of where to put it
 move.l #$30000,-(sp) * max length to read
 move.w d4,-(sp) * handle(pc),-(sp)
 call_bdos f_read
 add.l #12,sp
 tst.l d0
 bmi readerror
* d0= number of bytes read
 add.l (a6),d0
 move.l d0,$4(a6) * save end address

 rts

wrtfile
 move.l (a6),-(sp) * pea buffer(pc) * address of start of file
 move.l $4(a6),a1 * end address
 sub.l (a6),a1 * calc length
 move.l a1,-(sp) * length
 move.w d4,-(sp) * handle
 call_bdos f_write
 add.l #12,sp
 rts

closefile
 move.w d4,-(sp) * handle(pc),-(sp)
 call_bdos f_close
 addq.l #4,sp
 rts

*---

readhex
* given a hex string typed by the user at (a0),
* return d0.l = the equivalent value
* and a0.l = position after number
 movem.l d1-d7/a1-a6,-(sp)
 bsr absreadhex
 movem.l (sp)+,d1-d7/a1-a6
 rts
*---

absreadhex
 clr.l d0
readhex1
 move.l d0,-(sp)
 bsr.s readhexdigit
 move.l (sp)+,d0
 cmp.b #$ff,d1 * finished ?
 beq.s readhexret
 asl.l #4,d0 * shift existing digits along to make room
 add.b d1,d0
 bra.s readhex1

readhexdigit
* return in d1.b the value of the hex digit at (a0)
* or #$FF if none there
 move.b #$ff,d1 * error return
 move.b (a0)+,d0
 bsr converttouppercase
 cmp.b #"0",d0
 bcs.s rhdret * unsigned <, so return
 cmp.b #"9",d0
 bls.s rhdnumber * unsigned <=
 cmp.b #"A",d0
 bcs.s rhdret * unsigned <, so return
* got A-F
 sub.b #"A"-10,d0
 move.b d0,d1
readhexret
rhdret
 rts
rhdnumber
* got 0 - 9
 sub.b #"0",d0
 move.b d0,d1
 rts

*---

hexlonga0
 move.l a0,a2 * preserve a0
 move.l a0,d0 * transfer to data for shifts
 lsr.l #4,d0
 lsr.l #4,d0
 lsr.l #4,d0
 lsr.l #4,d0
 move.l d0,a0 * and back again
 bsr hexworda0
 move.l a2,a0
* drop through to hexworda0

hexworda0
* print hex word in a0. a0 preserved, d0 corrupted
 move.w a0,d0
 lsr.w #8,d0
 bsr hexbyted0
 move.w a0,d0
* drop through to hexbyted0

hexbyted0
* print hex byte d0. d0 corrupted, other registers preserved
 move.b d0,-(sp)
 lsr.w #4,d0
 bsr printhexdigit
 move.b (sp)+,d0
 and #$0f,d0
* branch through to printhexdigit
 
printhexdigit
*given d0.b as a single digit, print it as hex
 movem.l d0-d7/a0-a6,-(sp)
 bsr absprinthexdigit
 movem.l (sp)+,d0-d7/a0-a6
 rts

absprinthexdigit
 and.l #$0000000f,d0 * remove hi-order rubbish
 cmp.b #10,d0
 blt.s phdnum
 add #"A"-10,d0
 bra oswrch
phdnum
 add #"0",d0
 bra oswrch

printdecimald0
* print d0.l as a decimal number,
* suppressing leading zeros
 tst.l d0
 bne.s printdec1
 move.b #"0",d0
 bra printchar
printdec1
* non-zero number to print
 move.l d0,d2 * store number somewhere more sensible
 lea numbertable(pc),a1
 move.b #0,d3 * reset flag
printdec1a
* find the current digit value
 move.l (a1)+,d1 * get value
 beq.s printdecret * no more digits possible
* given d2=remainder of number, d1=value of current digit,
* find value
 move.b #"0",d0
printdec2
 sub.l d1,d2
 bcs.s printdec3
 addq.b #1,d0
 move.b #1,d3 * set leading-zeros flag
 bra.s printdec2
printdec3
 add.l d1,d2
 tst.b d3 * flag set yet ?
 beq.s printdec1a
 bsr printchar * oswrch * printchar
 bra.s printdec1a 

numbertable
 dc.l 1000000000
 dc.l 100000000
 dc.l 10000000
 dc.l 1000000
 dc.l 100000
 dc.l 10000
 dc.l 1000
 dc.l 100
 dc.l 10
 dc.l 1
 dc.l 0

driverprintchar
* very important note.
* this routine is provided so the printdecimal
* routine may run in the driver on its own
* or with new programs
* For the interpreter, and any other programs
* requiring word-wrap, it should be
* replaced with the appropriate routine using SET
* in the source of the other program
* this code should be left present

* note 2: At present SET is not supported
* by genst, Re-enable the label above when it is
 movem.l d0-d7/a0-a7,-(sp)
 bsr oswrch
 movem.l (sp)+,d0-d7/a0-a7
printdecret
readdecret
 rts

readdecimal
* given a decimal number as an ascii string at a0, return
* its value in d0.l
* and a0.l = charcter after the number
 clr.l d0
readdec1
 clr.w d1
 move.b (a0)+,d1
 cmp.b #"0",d1 * could it be part of a number (stop if not)
 bcs.s readdecend
 cmp.b #"9"+1,d1
 bcc.s readdecend
 sub.b #"0",d1
* multiply existing number by 10 ( 32 bit so can't use mulu d2,d0)
 asl.l #1,d0 * gives times 2
 move.l d0,-(sp)
 asl.l #2,d0 * gives times 8
 add.l (sp)+,d0
 add.l d1,d0   * and add in the new trailing digit
 bra.s readdec1
readdecend
 subq.l #1,a0
 rts
*---
*---
isd0alphanumeric
* return d0.b = 0 if not
 cmp.b #"0",d0
 bcs.s idanfail * unsigned <
 cmp.b #"9",d0
 bls.s idanret * unsigned <=
 cmp.b #"A",d0
 bcs.s idanfail * unsigned <
* do "quick-and-dirty" lower-upper case conversion
 and.b #$DF,d0
 cmp.b #"Z",d0
 bhi.s idanfail * unsigned >
idanret
 tst.b d0 * non-zero
 rts
idanfail
 clr.b d0
 rts
*--- 

 
 even
prs
* print string following call, terminated by 0
 move.l a0,-(sp)
 move.l d0,-(sp)
 move.l $8(sp),a0 * get return address = start address of string
prs1
 move.b (a0)+,d0 * (a6)
 beq.s prsend
* move.b #oswrchdcode,d0
 bsr oswrch * driver
 bra prs1
prsend
* make sure it is an even return address
 move.w a0,d0
 btst #0,d0
 beq.s prsend1
 addq.l #1,a0
prsend1
 move.l a0,$8(sp)
 move.l (sp)+,d0
 move.l (sp)+,a0
 rts
*---
addtoinputbuffer
* get a character from OS input char routine
* and stuff it into my own buffer
* this is only necessary because OS has a tendency
* to crash when the input buffer fills with multi-tasking
* going on ( I think it tries to sound a bell or something )

 bsr absgetcharfrombdos
* d0.b = character received
 tst.b d0
* beq.s addtoinputbuffer
 beq.s atibret

* escape pressed ?
 cmp.b #27,d0
 bne.s atibnotescape
* reset input buffer pointers, return zero
 lea driveribuffReadPtr,a0
 clr.l (a0) * 2 bytes each, reset both at once
 clr.b d0
 rts

atibnotescape 

 move.w driveribuffWritePtr,d1
 addq.w #1,d1
 cmp.w driveribuffReadPtr,d1
 beq.s atibfull
 subq.w #1,d1

 lea driveribuff,a0
 move.b d0,$0(a0,d1)
 addq.w #1,d1
 cmp.w #driveribuffsize,d1
 bne.s atib1
 move.w #0,d1
atib1
 lea driveribuffWritePtr,a0
 move.w d1,(a0)
atibfull
atibret
 rts

getcharfromdriveribuff
osrdch
* return d0.b = char from buffer, or 0 if none waiting
 bsr addtoinputbuffer

 move.b #0,d0
 move.w driveribuffReadPtr,d1
 cmp.w driveribuffWritePtr,d1
 beq.s gcfiret * buffer empty

 lea driveribuff,a0
 move.b $0(a0,d1),d0
 addq.w #1,d1
 cmp.w #driveribuffsize,d1
 bne.s gcfi1
 move.w #0,d1
gcfi1
 lea driveribuffReadPtr,a0
 move.w d1,(a0)
gcfiret
 rts



driveroswrch
 move.b (a6),d0
* fall through to oswrch
oswrch
* output character in d0 to screen
* I think all registers are preserved - please modify if not
 movem.l d0-d7/a0-a6,-(sp)
 bsr oswrch1
 movem.l (sp)+,d0-d7/a0-a6
 rts

oswrch1
 cmp.b #pageoff,d0
 bne.s oswrchnopage
 lea pageingdisabled,a0
 move.b #1,(a0)
 rts

oswrchnopage
 lea cursorxpos,a0
 cmp.b #bs,d0
 beq oswrchbs
 cmp.b #' ',d0
 bcs.s oswrch2 * unsigned <
 addq.b #1,(a0) * inc cursorxpos
oswrch2
oswrch3
 cmp.b #crlf,d0
 bne absoswrch
 clr.b (a0) * reset x pos
 bsr absoswrch * print cr
 move.b #lf,d0
* drop through to absoswrch to print lf

absoswrch
 lea drivergraphicsmode(pc),a0
 tst.b (a0)
 beq absoswrch2
* handle split screen etc.
 cmp.b #lf,d0
 bne absoswrch2
* when in split screen mode, don't do line feeds - 
* just scroll up screen, leaving cursor where it is
 move.b cursorypos,d1
 cmp.b #24,d1
 beq.s dolinefeed
* not on bottom line, so do OS line feed
 lea cursorypos,a0
 addq.b #1,(a0)
 bra absoswrch2 * do it

dolinefeed
* on bottom line, so scroll screen
 movem.l d0-d7/a0-a6,-(sp)
 lea scrolldriverbuffer(pc),a6
* first turn off cursor
 move.b #27,d0
 bsr bdososwrch
 move.b #"f",d0
 bsr bdososwrch
* now do the actual scroll
 move.l screenpointer(pc),a0
 move.l a0,a1            
 move.l a0,a2

* move.w #(absscreenheight*160),d0 * length of memory to scroll
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s scrollhires
 add.l #(absscreenheight)*160,a0
 add.l #(absscreenheight+8)*160,a1
* calculate length to scroll
 add.l #200*160,a2 * get end of screen
 sub.l a0,a2 * subtract start of text window
 move.w a2,d0 * length of text window
 sub.w #160*8,d0 * subtract one text line
 bra.s scroll1

scrollhires
 add.l #(absscreenheight)*160+160,a0
 add.l #(absscreenheight+8)*160+160,a1
* calculate length to scroll
 add.l #200*160,a2 * get end of screen
 sub.l a0,a2 * subtract start of text window
 move.w a2,d0 * length of text window
 sub.w #160*8-160,d0 * subtract one text line
scroll1
 move.l (a1)+,(a0)+
 subq.w #4,d0
 bpl.s scroll1

* and now blank out bottom line
 move.l #0,d0
 move.w #8*160,d1
scroll2
 move.l d0,(a0)+
 subq.w #4,d1
 bpl.s scroll2
* now re-enable cursor
 move.b #27,d0
 bsr bdososwrch
 move.b #"e",d0
 bsr bdososwrch
 movem.l (sp)+,d0-d7/a0-a6

afterlinefeed
* and finally, if have scrolled a complete screen since
* the last input, print '<more>' and wait for a key to enter
* the keyboard buffer
 move.b pageingdisabled,d0
 bne scrollnowait

 lea scrolledlines,a0
 addq.b #1,(a0)
 move.b drivergraphicsmode,d0
 beq.s scrolllinestext
 cmp.b #12,(a0) * fewer lines available in graphics mode
 bne.s scrollnowait
 bra.s scrollwait

scrolllinestext
 cmp.b #24,(a0) * lots of lines in text mode
 bne.s scrollnowait

scrollwait
 bsr prs
 dc.b "<More>",0
 even
 lea cursorxpos,a0
 clr.b (a0) * make it think we're still at start of line
; move.w driveribuffReadPtr,d1
; cmp.w driveribuffWritePtr,d1
; bne.s scrollend * buffer now contains a character
 move.w driveribuffWritePtr,-(sp) ; preserve current pos in buffer
scrollwaitkey
 bsr addtoinputbuffer * check for key strokes, store them away
 move.w (sp),d0
 cmp.w driveribuffWritePtr,d0
 bne.s scrollend
 bra.s scrollwaitkey
scrollend
 addq.l #2,sp * pop off initial WritePtr
* reset number of lines scrolled since last input
 lea scrolledlines,a0
 clr.b (a0)
* and delete the <more> message
* position cursor at start of line ....
 move.b #27,d0
 bsr bdososwrch
 move.b #'Y',d0
 bsr bdososwrch * position cursor
 move.b #32+24,d0
 bsr bdososwrch
 move.b #32+0,d0
 bsr bdososwrch * line 24,column 0
* and delete to end of screen ....
 move.b #27,d0
 bsr bdososwrch
 move.b #'J',d0
 bsr bdososwrch
scrollnowait
 rts
*---
absoswrch2
 bsr bdososwrch
 cmp.b #32,d0
 bcs.s absoswrch3
 move.b cursorxpos,d1
 cmp.b #80,d1
 bne.s absoswrch3
 lea cursorxpos,a0
 clr.b (a0)
 move.b #cr,d0
 bsr absoswrch
 move.b #lf,d0
 bsr absoswrch
 lea cursorxpos,a0
 clr.b (a0)
 bra afterlinefeed
absoswrch3
 move.w d0,-(sp) * preserve character just printed
 bsr addtoinputbuffer * prevent OS crashing on buffer full
 move.w (sp)+,d0
 cmp.b #lf,d0
 beq afterlinefeed
 rts
bdososwrch
* print d0.b using OS
* now print it (using os at present)
 move.b outputdevice,d1
 cmp.b #1,d1
 bne.s bdososwrchOK
 cmp.w #13,d0
 beq.s bdososwrchok
 cmp.w #10,d0
 beq.s bdososwrchok
 cmp.w #' ',d0 * ??? printing only
 bcs.s bdososwrchret * ??? printing ONLY
bdososwrchok
;
 move.l a0,-(sp)
 move.w d0,-(sp) * this is argument for routine as well as preservation
 call_bdos c_conout
 addq.l #2,sp * remove function call number etc.
 move.w (sp)+,d0
 move.l (sp)+,a0

 move.b outputdevice,d1
 cmp.b #1,d1
 bne.s bdososwrchret
;* now send it to the printer
; wait for device to become ready.
 movem.l d0-d7/a0-a6,-(sp)
bdosPrinterWait
 move.w #1,-(sp) ; aux ready?
 move.w #8,-(sp) ; bcostat
 trap #13
 addq.l #4,sp
 tst.b d0
 beq bdosprinterWait
 movem.l (sp)+,d0-d7/a0-a6

 move.l a0,-(sp)
 move.w d0,-(sp) * this is argument for routine as well as preservation
 call_bdos c_auxout * send to printer - call_bdos c_conout
 addq.l #2,sp * remove function call number etc.
 move.w (sp)+,d0
 move.l (sp)+,a0
bdososwrchret
 rts
*---
oswrchbs
* (a0).b is cursorxpos
 subq.b #1,(a0)
 bpl bdososwrch * nothing special on this occasion
 move.b cursorypos,d0
 cmp.b #16,d0
 beq.s oswrchbserror
* we are going to move backwards from the start of one line
* to the beginning of the previous one
 lea cursorxpos,a0
 move.b #70,(a0) * allow plenty of space for positioning commands
* doing backspace at start of line - want to wrap round
* to end of previous line
*
* at present - just position cursor at end of line 23
 lea cursorypos,a0
 subq.b #1,(a0) * decrement y pos
 move.b #27,d0
 bsr bdososwrch
 move.b #'Y',d0
 bsr bdososwrch
 move.b (a0),d0 * y pos
 add.b #32,d0 * for benefit of vt52 emulator
 bsr bdososwrch * print it
 move.b #32+79,d0 * x pos
 bsr bdososwrch
*
 lea cursorxpos,a0
 move.b #79,(a0) * reset because cursor pos command changes pos
 move.b #" ",d0 * delete existing char in last column
* (no overflow in operation, so cursor will not move)
 bra bdososwrch
* rts
*---
oswrchbserror
* can't go any further
 move.b #7,d0 * sound a bell
 bsr oswrch
 lea cursorxpos,a0
 addq.b #1,(a0)
 rts
*---
protectedoswrch
* given single character in d0. If invalid, print a dot
 cmp.b #32,d0
 bge oswrch
 move.b #".",d0
 bra oswrch
*---
initinputline
 clr.l (a6) * destroy any left-overs
 lea currentlineoffset(pc),a0
 clr.w (a0) * editing current line
 clr.w ilhighwater * characters in buffer
 clr.w d4
 lea scrolledlines,a0
 clr.b (a0)
 rts
*---
*startlog
** write all commands into a file log from now on
* lea logdriverblock,a6
* bra inputline

startautorunning
 bsr autorun

driverinputline
 move.b executingcommandfile,d0
 bne autoruninputline

inputline
 bsr initinputline
* clr.l (a6) * destroy any left-overs
* lea currentlineoffset(pc),a0
* clr.w (a0) * editing current line
* move.w #0,ilhighwater * characters in buffer

inputline0
* input a string into memory
* starting at a6.l
* terminated by 0
 move.w #0,ilpos
inputline1
 move.w #148,ilsize * think before making it larger (about editing)
 bsr snooze

 bsr osrdch
 tst.b d0
 beq.s inputline1
 cmp.b #3,d0
 beq.s tryclose
 cmp.b #quitkey,d0
 bne notclosedown
tryclose
 bsr closedown
 clr.w ilpos * display from current pos to end
 bsr displayinputline
 bra inputline1

notclosedown
 cmp.b #helpkey,d0
 bne.s nothelp
* put 'help. credits.' into input line buffer
 lea helptext,a0
returnfixedstring
 clr.w ilhighwater * pointer into table
rfs1
 move.b (a0)+,d0
 beq.s rfsend
 move.b d0,$0(a6,ilhighwater)
 addq.w #1,ilhighwater
 bra.s rfs1

rfsend
 bsr startofinputline * position cursor at start of input
 clr.w ilpos * display from current pos to end
 bsr displayinputline
 bra inputlinecr

nothelp
 cmp.b #undokey,d0
 bne.s notundo
 lea undotext,a0
 bra.s returnfixedstring

helptext
 dc.b "help.",0
 even
undotext
 dc.b "Undo!",0
 even

notundo
 cmp.b #autorunkey,d0
 beq startautorunning
* cmp.b #logkey,d0
* beq startlog

 cmp.b #cr,d0
 beq inputlinecr
 cmp.b #bs,d0
 beq inputlinebs
 cmp.b #$7F,d0 * delete key
 beq inputlinedelete

 cmp.b #cursorleft,d0
 beq moveleft
 cmp.b #cursorright,d0
 beq moveright
 cmp.b #cursorup,d0
 beq moveup
 cmp.b #cursordown,d0
 beq movedown
* filter out control codes
 cmp.b #32,d0
 blt inputline1
* ordinary character - check if space in buffer
 cmp.w ilsize,ilhighwater
 bhi inputlinebell * unsigned >
* shift up following characters in buffer to make space
 move.w d0,-(sp)
 move.w ilhighwater,d1
insertchar1
 move.b 0(a6,d1),d0
 move.b d0,1(a6,d1)
 cmp.w d1,ilpos
 beq.s insertchar2
 subq.b #1,d1
 bra.s insertchar1

insertchar2
 move.w (sp)+,d0
 move.b d0,0(a6,ilpos)
 bsr oswrch * echo character
 addq.w #1,ilpos
 addq.w #1,ilhighwater
 bsr displayinputline
 bra inputline1
*---
inputlinebell
 move.b #7,d0
 bsr oswrch
 bra inputline1

inputlinedelete
* shift all characters up in buffer
* so as to delete the character after the cursor
* anything to delete after cursor ?
 cmp.w ilhighwater,ilpos
 beq inputline1
 addq.w #1,ilpos * so that backspace will work as desired
 bra.s ilbs1 * don't print bs first

inputlinebs
 tst.w ilpos * anything in buffer to delete ?
 beq inputline1 * no
 move.b #bs,d0
 bsr oswrch * echo character
ilbs1
* now shift all characters up in buffer
* so as to delete the character before the cursor
 move.w ilpos,d1
deletechar1
 move.b $0(a6,d1),d0
 move.b d0,-1(a6,d1)
 cmp.w d1,ilhighwater
 beq.s deletechar2
 addq.w #1,d1
 bra.s deletechar1

deletechar2
 subq.w #1,ilpos
 subq.w #1,ilhighwater
 bsr displayinputline
 bra inputline1

moveleft
 tst.w ilpos * at start of input line ?
 beq inputline1 * no
 move.b #bs,d0
 bsr oswrch
 subq.w #1,ilpos
 bra inputline1

moveright
 bsr.s mrsub
 bra inputline1

mrsub
 cmp.w ilhighwater,ilpos
 bcc mrsubret * greater than or equal
 move.b 0(a6,ilpos),d0
 bsr oswrch * step cursor on
 addq.w #1,ilpos
mrsubret
 rts
*---
startofinputline
* move to the start of the current input line
 tst.w ilpos * at start of input line ?
 beq soilret * yes
 move.b #bs,d0
 bsr oswrch
 subq.w #1,ilpos
 bra startofinputline
soilret
 rts
*---
movedown
 bsr startofinputline ;>>
 move.w currentlineoffset(pc),d2
 subq.w #1,d2
 bmi inputlinebell
 beq movedownblank * back to blank line
 bsr findaninputline
 move.w currentlineoffset(pc),d2
 addq.w #1,d2 * a problem, so put current line back
movedownend
 lea currentlineoffset(pc),a0
 move.w d2,(a0)
 bra inputlinebell

movedownblank
 bsr initinputline
 bsr displayinputline
 bra inputline

moveup
 move.w currentlineoffset(pc),d2
 addq.w #1,d2
 bsr findaninputline
 move.w currentlineoffset(pc),d2
 subq.w #1,d2 * a problem if get back to here, so reset current line
 bra.s movedownend

findaninputline
* display the d2.w th previously entered line
 lea currentlineoffset(pc),a0
 move.w d2,(a0)

* first find its address
 move.l cycliccharsused,d1
 move.l cyclicwriteptr,a0
 move.l #1,a1
 bsr subcyclic * skip over terminator of previous input
 subq.w #1,d1 * chars used

moveup1
 bsr subcyclic
 subq.w #1,d1 * chars used
 bmi.s moveup1a * maybe have first line entered
 tst.b (a0)
 bne.s moveup1
moveup1a
* got a terminator, are we at the right message yet ?
 subq.w #1,d2
 beq.s moveupfound
 tst.w d1 * chars used
 bmi moveupret * out of previous lines
 bra.s moveup1

moveupfound
* have found the wanted previous line
* which starts at a0.l+1
 bsr inccyclic * addq.l #1,a0
* first, position cursor at start of current input line
 bsr startofinputline

* copy it into the buffer for editing
 move.w #-1,ilpos
moveup2
 addq.w #1,ilpos
 move.b 0(a0,ilpos),d0
 move.b d0,0(a6,ilpos)
 bne.s moveup2
 move.w ilpos,ilhighwater
 clr.w ilpos
 bsr displayinputline
* ok, so strip off return address
* and edit the line
* see moveup,movedown routines for why
 move.l (sp)+,d0 * pop off unwanted return address
 bra inputline0
moveupret
 rts
*---
inputlinecr
* terminate and return
* move to bottom of screen
 move.b cursorypos,d0
 cmp.b #24,d0
 beq.s il0
 move.b #cr,d0
 bsr oswrch
 bra.s inputlinecr
il0
 move.b #cr,d0
 bsr oswrch

storeinputline
* store it in a cyclical buffer
 move.b #0,0(a6,ilhighwater) * add a terminator
 tst.w ilhighwater
 beq.s ilret * blank line, don't store it
ilcr1
* enough space ?
 move.l cycliccharsused,d0
 add.w ilhighwater,d0
* how much space available in cyclic buffer ?
 move.l cyclicbufferend,d1
 sub.l cyclicbufferstart,d1
 cmp.w d1,d0
 bcs.s ilcr3
* no, so remove chars from buffer until 0 (eol) reached
ilcr2
 bsr removecharcyclicbuffer
 tst.b d0
 bne.s ilcr2
 bra.s ilcr1

ilcr3
* enough space available now, so go through and write in
* this input line
 move.w #0,ilpos * pointer to buffer
ilcr4
 move.b 0(a6,ilpos),d0
 bsr putcharcyclicbuffer
 addq.w #1,ilpos
 tst.b d0
 bne.s ilcr4
ilret
 rts
*------
subcyclic
* do cyclic subtraction: a0:=a0-a1
 sub.l a1,a0
 cmp.l cyclicbufferstart,a0
 bcc.s scret * unsigned >= - still within buffer
 sub.l cyclicbufferstart,a0 * get (negative) offset from buffer start
 add.l cyclicbufferend,a0 * and add it to the buffer end
* to give a0.l = pos in buffer
scret
 rts
*---
removecharcyclicbuffer
* get oldest char from cyclical buffer in d0.b
 move.l cyclicwriteptr,a0
 move.l cycliccharsused,a1
 bsr subcyclic * a0:=a0-a1
 move.b (a0),d0
 lea cycliccharsused,a0
 subq.l #1,(a0)
 rts
*---
inccyclic
* a0.l:=a0.l+1
 addq.l #1,a0
 cmp.l cyclicbufferend,a0
 bcs.s ic1
 move.l cyclicbufferstart,a0
ic1
 rts
*---
putcharcyclicbuffer
* write char d0.b into cyclical buffer
* at (cyclicwriteptr).l
 move.l cyclicwriteptr,a0
 move.b d0,(a0)
 bsr inccyclic
 lea cyclicwriteptr,a1
 move.l a0,(a1)
* and inc number of chars used in buffer
 lea cycliccharsused,a0
 addq.l #1,(a0)
 rts
*---
displayinputline
* now echo input line from current pos to end of buffer
 move.w ilpos,d1
dil1
 cmp.w d1,ilhighwater
 beq.s dil2
 move.b 0(a6,d1),d0
 bsr oswrch
 addq.w #1,d1
 bra.s dil1

dil2
* and clear to end of screen
 move.b #27,d0
 bsr bdososwrch
 move.b #'J',d0
 bsr bdososwrch
* now restore the cursor position
 move.w ilhighwater,d1
 sub.w ilpos,d1
* do d1.w cursor lefts
dil3
 tst.w d1
 beq dilret * finished doing cl's ?
 move.b #bs,d0
 bsr oswrch
 subq.w #1,d1
 bra.s dil3
dilret
 rts
*---

* --------

converttouppercase
* convert character in d0.b to upper case
 cmp.b #"a",d0
 bcs.s ctucret * unsigned <
 cmp.b #"z",d0
 bhi.s ctucret * unsigned >
 sub.b #"a"-"A",d0
ctucret
 rts

converttolowercase
* convert character in d0.b to lower case
 cmp.b #"A",d0
 bcs.s ctlcret * unsinged <
 cmp.b #"Z",d0
 bhi.s ctlcret * unsigned >
 add.b #"a"-"A",d0
ctlcret
 rts

*---

driverosrdch
 bsr osrdch
 move.b d0,(a6)
 rts

absgetcharfrombdos
* get character from keyboard in d0
* without waiting or echo (not easy in Gem !)
 call_bdos c_conis * check if key pending
 addq.l #2,sp
 tst.l d0
 bmi.s osrdchgetkey
* no key waiting, so return 0
 move.b #0,d0
 rts
osrdchgetkey
 call_bdos c_rawcin * get key from buffer without echo
 addq.l #2,sp
*
* if d0.b=0, the lower byte of the upper word may
* contain a keyboard code for the cursor keys etc.
 tst.b d0
 bne.s ogkret
 lsr.l #8,d0
 lsr.l #8,d0
 cmp.b #$48,d0
 bne.s ogk1
 move.b #cursorup,d0
 rts
ogk1
 cmp.b #$4b,d0
 bne.s ogk2
 move.b #cursorleft,d0
 rts
ogk2
 cmp.b #$4d,d0
 bne.s ogk3
 move.b #cursorright,d0
 rts
ogk3
 cmp.b #$50,d0
 bne.s ogk4
 move.b #cursordown,d0
 rts
ogk4
 cmp.b #$62,d0
 bne.s ogk5
 move.b #helpkey,d0
 rts
ogk5
 cmp.b #$61,d0
 bne.s ogk6 * undo key
 move.b #undokey,d0
 rts
ogk6
 cmp.b #$10,d0
 bne.s ogk7 * alt-Q
 move.b #quitkey,d0
 rts
ogk7
 cmp.b #$13,d0
 bne.s ogk8 * alt-R
 move.b #autorunkey,d0
 rts

ogk8
 cmp.b #$26,d0
 bne.s ogk9 * alt-L
 move.b #logkey,d0
 rts

ogk9
* $3b = f1
* $3c = f2
* $3d - f3 ... etc
 clr.b d0
ogkret
 rts

returntogem
 ifd graphics
  move.b #settextdcode,d0
  bsr killmultitasking
  bsr driver
 endc * if graphics

 call_bdos p_term

*----------

 ifnd graphics * only assembled if graphics has not been defined
settext
setgraphics
driverclg
driverchgcol
line
fill
gintstart
killmultitasking
 rts

 endc

* assemble this stuff anyway, for simplicity:


* constant definitions
screenleft equ 10
screenright equ 630
absscreenheight equ 96
fillspentrylength equ 12
fillspmax equ 2048

hiresscreenleft equ 1 * 7 *10
hiresscreenright equ 319 *2 * 630/2
hiresabsscreenheight equ 96

lowresscreenleft equ 1
lowresscreenright equ 319 *312 * 315 * 630/2
lowresabsscreenheight equ 96

lowres equ 0
hires equ 2

 even
screenpointer dc.l 0
screenheight dc.w 0
screenresolution dc.b 0
 even
*---

 ifd graphics * only assembled if graphics has been defined


settext
* clear top half of screen
 move.l screenpointer(pc),a0
 move.w #$3bfe,d0 * length to clear
settext2
 clr.l (a0)+
 subq.w #4,d0
 bpl.s settext2

* and kill the split screen, restore full screen scrolling etc.
 lea drivergraphicsmode(pc),a0
 clr.b (a0)
 rts
*---
driverchgcol
* only for low res mode
 move.b screenresolution,d0
 cmp.b #lowres,d0
 bne.s dcret
 clr.w d0
 move.b $1(a6),d0 * new appearan
 asl.w #1,d0 * two bytes per ent
 lea bbcequivalenttable,a0
 move.w $0(a0,d0),d0
 move.w d0,-(sp)

 clr.l d0
 move.b (a6),d0
* reverse colours 1 and 2
 lea bugfixtable,a0
 move.b $0(a0,d0),d0
 add.b #12,d0
 asl.b #1,d0

 move.w (sp)+,d1 * new appearance of colour
* d0 is colour number
 lea $ff8240,a0 * address of colour 0 in palette table
 move.w d1,$0(a0,d0)
dcret
 rts

 even
bugfixtable
 dc.b 0,2,1,3

 even
bbcequivalenttable
 dc.w $000 * black
 dc.w $600 * 700 * red
 dc.w $060 * 070 * green
 dc.w $660 * 770 * yellow
 dc.w $005 * 007 * blue
 dc.w $532 * brown - $707 is magenta
 dc.w $066 * 077 * cyan
 dc.w $666 * 777 * white

 even
*---
setuppalette
* set up colour palette
 move.b screenresolution,d0
 cmp.b #hires,d0
 lea monopalette(pc),a0
 beq.s setuppalettea0
 lea lowrespalette(pc),a0
setuppalettea0
 move.l a0,-(sp)
 call_ebios _setpallete * move.w #6,-(sp)
 addq.l #6,sp
 rts
*--- 
driverclg
* first set up colour palette
 lea drivergraphicsmode(pc),a0
 tst.b (a0)
 bne driverclgalready
 bsr initgraphics * set (drivergraphicsmode)=true etc.
driverclgalready
 move.l screenpointer(pc),a0

 clr.l d1 * fill colour for upper two bit planes
 clr.l d2 * fill colour for lower two bit planes
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s driverclg2
* fill pattern for lowres is a bit complex
* need to set upper two bit planes to 0
* and lower two bit planes to FFFF so that
* all graphics colours end in FFFF (to avoid clashing with
* text colours, and with border colour (colour 0))
 clr.l d1
 move.l #$ffffffff,d2

driverclg2
 move.w #$3c00,d0 * length to clear (colour)
 move.b screenresolution,d0
 cmp.b #hires,d0
 bne.s driverclg3
 move.w #$3ca0,d0 * 3bc8,d0 * length to clear (mono)
driverclg3
 move.l d1,(a0)+
 move.l d2,(a0)+
 sub.w #8,d0
 bpl.s driverclg3

* reset pesky point which I cannot get rid of (???)
 move.l screenpointer(pc),a0
 add.l #$3c04,a0
 clr.l (a0)

* and for lowres mode, set screen margin to black
 move.l screenpointer(pc),a0
 addq.l #4,a0 * only operate on low word of colours
 move.b #absscreenheight,d1
driverclgmargin
 move.l (a0),d0
 and.l #$7fff7fff,d0
 move.l d0,(a0)

 add.l #160,a0
 subq.b #1,d1
 bne.s driverclgmargin
 rts
*---
 even
monopalette
* first colour gives white on black text if 0
* or black on white if 1
 dc.w 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0

* these colours are defined in form RGB
* see P.57 ST Internals
textbackground equ $000
textforeground equ $662 * Yellow text
gcol0 equ $000 * 400
gcol1 equ $040
gcol2 equ $004
gcol3 equ $044
nocolour equ $777

lowrespalette
 dc.w textbackground,textforeground,textforeground,textforeground * 0-3
 dc.w nocolour,nocolour,nocolour,nocolour
 dc.w nocolour,nocolour,nocolour,nocolour
 dc.w gcol0,gcol1,gcol2,gcol3

*---
point
mask equr d5
* given actual screen co-ords x=d6.w,y=d7.w
* return a0=address, d5=plotting mask, z if ok to plot
* note that co-ordinate system presented to this routine
* is x1=0,y1=screenheight at top left, x1=0,y1=0 at bottom left of screen
* entire medium res screen is 640x200
* d6,d7 preserved

 move.b screenresolution(pc),d0
 cmp.b #2,d0
 beq pointhires
 cmp.b #lowres,d0
 beq pointlowres

* first check if point is on screen
 cmp.w #screenright,d6
 bhi pointerror * unsigned >
 cmp.w #screenleft,d6
 bcs pointerror * unsigned <
* assume screen bottom is at y=0
 cmp.w screenheight(pc),d7
 bhi pointerror * unsigned >

* invert screen so y=0 is at top left, for convenience in calculations
 move.w screenheight(pc),d0
 move.w d7,d1
 sub.w d1,d0 * now d0=inverted form of y

* now calculate address of point on screen
* medium res has 160.=$a0 bytes per line (640 pixels)
* do in two stages: *128+*32
 asl.w #5,d0
* now, times 10/2
 move.w d0,d1
 asl.w #2,d0
 add.w d1,d0
 move.l screenpointer(pc),a0
 add.w d0,a0

* get nearest 4-byte boundary (x direction)
 move.w d6,d0
 lsr.w #2,d0
 and.w #$fffc,d0
 add.w d0,a0

* now set to 1-byte boundary (1st of the pair)
 btst #3,d6
 beq.s point1
 addq.l #1,a0
point1

* now find plotting mask
 move.b d6,d0
 and.b #$7,d0
 move.b #$80,mask
 lsr.b d0,mask * shift plotting mask into position
 
pointaddrmask

* now look at plotting option and act accordingly
 move.b $1(a6),d0
 beq.s pointret * option 0 - plot regardless, so return z = ok
* look at pixel at this point
 clr.b d0 * move.b #0,d0
 move.b mask,d1
 and.b $2(a0),d1 * low-order bit (?)
 beq.s pointcompare2
 move.b #1,d0

pointcompare2
 move.b mask,d1
 and.b (a0),d1 * high-order bit (?)
 beq.s pointcompare3
 or.b #2,d0
pointcompare3
* d0.b = 0,1,2,3 depending on colour at this pixel
 cmp.b optioncolour(pc),d0
pointret
 rts * return z if ok, nz if not

pointerror
 move.b #255,d0 * set nz to indicate problems
 rts
* ---
pointhires
* first check if point is on screen
 cmp.w #hiresscreenright,d6
 bhi pointerror * unsigned >
 cmp.w #hiresscreenleft,d6
 bcs pointerror * unsigned <
 tst.w d7
 beq pointerror * don't plot on bottom line nowadays
 cmp.w screenheight(pc),d7
 bhi pointerror * unsigned >

* invert screen so y=0 is at top left, for convenience in calculations
 move.w screenheight(pc),d0
 move.w d7,d1
 sub.w d1,d0 * now d0=inverted form of y

* now calculate address of point on screen
* high res has 80.=$50 bytes per line (640 pixels)
* for hires mode, I am using two machine pixels as one of mine
* so as to give 4 colour capability (needed for fill etc.)
* do in two stages: *64+*16
 asl.w #4,d0
* now, times 10/2
 move.w d0,d1
 asl.w #2,d0
 add.w d1,d0
 move.l screenpointer(pc),a0
 add.w d0,a0

* get nearest byte boundary (x direction)
 move.w d6,d0
 lsr.w #2,d0 * four pseudo-pixels per byte in hires mode
 add.w d0,a0 * ( 8 physical pixels )

* now find plotting mask
 move.b d6,d0
 and.b #$3,d0
 asl.b #1,d0
 move.b #$c0,mask
 lsr.b d0,mask * shift plotting mask into position
 
pointamhires
* now look at plotting option and act accordingly
 move.b $1(a6),d0
 beq.s pointret * option 0 - plot regardless, so return z = ok
* look at pixel at this point
 move.b mask,d0
 and.b (a0),d0 * both bits of pixel
* d0.b = 0,1,2,3 depending on colour at this pixel
 cmp.b optioncolour(pc),d0
 rts * return z if ok, nz if not
* --- 

convertargshires
 move.w $2(a6),d0
 asr.w #5,d0
 lea x1(pc),a0
 move.w d0,(a0)

 move.w $4(a6),d0
 bsr processy
 lea y1(pc),a0
 move.w d0,(a0)

 move.w $6(a6),d0
 asr.w #5,d0 * bsr processx
 lea x2(pc),a0
 move.w d0,(a0)

 move.w $8(a6),d0
 bsr processy
 lea y2(pc),a0
 move.w d0,(a0)

 move.b (a6),d0
 lea colour(pc),a0
 move.b d0,(a0)
* put colour in all pixels for hi-res mode
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 asl.b #2,d0
 or.b d1,d0
 move.b d0,(a0)

 move.b $1(a6),d0
 and.b #3,d0
 lea optioncolour(pc),a0
 move.b d0,(a0)
 
 rts
*---
pointlowres
* first check if point is on screen
 cmp.w #lowresscreenright,d6
 bhi pointerror * unsigned >
 cmp.w #lowresscreenleft,d6
 bcs pointerror * unsigned <
* assume screen bottom is at y=0 (until inverted)
 tst.w d7
 beq pointerror
 cmp.w screenheight,d7
 bhi pointerror * unsigned >

* invert screen so y=0 is at top left, for convenience in calculations
 move.w screenheight(pc),d0
 move.w d7,d1
 sub.w d1,d0 * now d0=inverted form of y

* now calculate address of point on screen
* low res has 160.=$100 bytes per line (320 pixels)
 asl.w #5,d0
* now, times 10/2
 move.w d0,d1
 asl.w #2,d0
 add.w d1,d0
 move.l screenpointer(pc),a0
 add.w d0,a0

* get nearest byte boundary (x direction)
 move.w d6,d0 * first shift to get block of 8 bytes
 and.w #$fff0,d0 * first shift is XXXX0000 -> .XXXX000
 lsr.w #1,d0
 add.w d0,a0

 move.w d6,d0  * now shift because 16 pixels go in two adjacent bytes
 and.w #$08,d0 * next shift is 0000X000  -> .0000001
 lsr.w #3,d0
 add.w d0,a0

* now find plotting mask
 move.b d6,d0
 and.b #$7,d0
 move.b #$80,mask
 lsr.b d0,mask * shift plotting mask into position
 
pointamlowres
 bra pointaddrmask * for medium res really, but should work

* now look at plotting option and act accordingly
 move.b $1(a6),d0
 beq pointret * option 0 - plot regardless, so return z = ok
* look at pixel at this point
 move.b mask,d0
 and.b (a0),d0 * high-order bit (?)
* d0.b = 0,1,2,3 depending on colour at this pixel
 cmp.b optioncolour(pc),d0
 rts * return z if ok, nz if not
* --- 

convertargslowres
 move.w $2(a6),d0
 asr.w #5,d0
 lea x1(pc),a0
 move.w d0,(a0)

 move.w $4(a6),d0
 bsr processy
 lea y1(pc),a0
 move.w d0,(a0)

 move.w $6(a6),d0
 asr.w #5,d0 * bsr processx
 lea x2(pc),a0
 move.w d0,(a0)

 move.w $8(a6),d0
 bsr processy
 lea y2(pc),a0
 move.w d0,(a0)

 move.b (a6),d0
 lea colour(pc),a0
 move.b d0,(a0)
* put colour in all pixels for low-res mode
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 asl.b #2,d0
 or.b d1,d0
 move.b d0,(a0)

 move.b $1(a6),d0
 and.b #3,d0
 lea optioncolour(pc),a0
 move.b d0,(a0)
* and propogate hi and lo bits of option colour (for use by fill)
 move.b #8,d2 * number of shifts to do
 lsr.b #1,d0 * do high bit first
 move.b d0,d1
prop1
 asl.b #1,d0
 or.b d0,d1
 subq.b #1,d2
 bne.s prop1
 lea hioptioncolour,a1
 move.b d1,(a1)

 move.b #8,d2 * number of shifts to do
 move.b (a0),d0 * retrieve optioncolour
 and.b #1,d0 * now the low bit
 move.b d0,d1
prop2
 asl.b #1,d0
 or.b d0,d1
 subq.b #1,d2
 bne.s prop2
 lea looptioncolour,a1
 move.b d1,(a1)

* now do the plotting colour
 move.b (a6),d0
 and.b #3,d0
* and propogate hi and lo bits of option colour (for use by fill)
 move.b #8,d2 * number of shifts to do
 lsr.b #1,d0 * do high bit first
 move.b d0,d1
prop3
 asl.b #1,d0
 or.b d0,d1
 subq.b #1,d2
 bne.s prop3
 lea hicolour,a1
 move.b d1,(a1)

 move.b #8,d2 * number of shifts to do
 move.b (a6),d0
 and.b #1,d0 * now the low bit
 move.b d0,d1
prop4
 asl.b #1,d0
 or.b d0,d1
 subq.b #1,d2
 bne.s prop4
 lea locolour,a1
 move.b d1,(a1)

 rts
 
*---
convertargs
* convert x1,y1,x2,y2,colour,option
* to      x1,y1,x2,y2,colour,optioncolour
* in actual screen co-ordinates (640 by 96)
* note: these arguments are in the driver buffer
* and must be word-aligned, hi byte first

 move.b screenresolution(pc),d0
 cmp.b #2,d0
 beq convertargshires
 cmp.b #lowres,d0
 beq convertargslowres

 move.w $2(a6),d0
 asr.w #4,d0 * bsr processx
 lea x1(pc),a0
 move.w d0,(a0)

 move.w $4(a6),d0
 bsr processy
 lea y1(pc),a0
 move.w d0,(a0)

 move.w $6(a6),d0
 asr.w #4,d0 * bsr processx
 lea x2(pc),a0
 move.w d0,(a0)

 move.w $8(a6),d0
 bsr processy
 lea y2(pc),a0
 move.w d0,(a0)

 move.b (a6),d0
 lea colour(pc),a0
 move.b d0,(a0)
 move.b screenresolution(pc),d1
 cmp.b #2,d1
 bne.s convertarg2
* put colour in all pixels for hi-res mode
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 move.b d0,d1
 asl.b #2,d0
 or.b d1,d0
 move.b d0,(a0)

convertarg2
 move.b $1(a6),d0
 and.b #3,d0
 lea optioncolour(pc),a0
 move.b d0,(a0)
 
 rts

* ----
processy
* to give y on a 0 .. 96 grid
* d0:=d0/32 x (3/4)
 move.b screenresolution(pc),d1
* this will do for either medium or low res
 cmp.b #2,d1
 beq.s processyhires
 asr.w #5,d0 * / 32
 move.w d0,d1
 asr.w #1,d0 * x 3
 add.w d1,d0
 asr.w #3,d0 * /4
 rts
processyhires
 asr.w #4,d0 * / 16
 move.w d0,d1
 asr.w #1,d0 * x 3
 add.w d1,d0
 asr.w #3,d0 * /4
 rts
* ----
* processx - replaced by in-line code to make it faster
* to give x on a 0..320 grid
* x = d0/32
* lsr.l #5,d0
* rts
* ---

plotaddrmask
* plot at (a0) with plotting mask d5
 move.b screenresolution(pc),d0
 cmp.b #2,d0
 beq.s plotamhires
* this code is ok for both low and medium res
* clear existing pixel at this point
 move.b mask,d0
 eor.b #$ff,d0
 and.b d0,(a0)

 btst #1,(a6) * plotting colour
 beq.s plotaddrmask1
* do high-order bit
 or.b mask,(a0)

plotaddrmask1
* clear low-order bit
 move.b mask,d0
 eor.b #$ff,d0
 and.b d0,$2(a0)

* and set it if appropriate
 btst #0,(a6)
 beq.s plotaddrmaskret
* do low-order bit
 or.b mask,$2(a0)
plotaddrmaskret
 rts

plotamhires
* reset pixel just in case
 move.b mask,d0
 eor.b #$ff,d0
 and.b d0,(a0)

 move.b colour(pc),d0 * plotting colour
* beq.s plotamhiresret
 and.b mask,d0
 or.b d0,(a0)
plotamhiresret
 rts

*---
line
* draw line from x1,y1 to x2,y2
* register useage:
*                            a1.w=xdir
* d2=testw                   a2.w=ydir
* d3=testminus               a3.w=ygreater
* d4=testplus                a4.w=smaller
* d5=plotting mask           a5.w=larger
* d6=x / xdiff               a6.l=driver buffer
* d7=y / ydiff               a7.l=stack
testw equr d2
testminus equr d3
testplus equr d4
* mask equr d5 - defined in point
x equr d6
xdiff equr d6
y equr d7
ydiff equr d7
xdir equr a1
ydir equr a2
ygreater equr a3
smaller equr a4
larger equr a5

 bsr convertargs
** prevent use of colours 1/2 in hires mode
* move.b screenresolution,d0
* cmp.b #hires,d0
**2 bne.s linenhires
*move.b colour(pc),d0
* cmp.b #$aa,d0
* bne.s linenhires
* dc.w $4afa
* lea colour(pc),a0
* move.b #$ff,(a0)
*linenhires

* calculate:
*    xdiff=abs(x2-x1)   ;   xdir.w=sign
*    ydiff=abs(y2-y1)   ;   ydir.w=sign
line0
 move.w #1,xdir
 move.w x2(pc),xdiff
 sub.w x1(pc),xdiff
 bpl.s line1
 move.w x1(pc),xdiff
 sub.w x2(pc),xdiff
 move.w #-1,xdir

line1
 move.w #1,ydir
 move.w y2(pc),ydiff
 sub.w y1(pc),ydiff
 bpl.s line2
 move.w y1(pc),ydiff
 sub.w y2(pc),ydiff
 move.w #-1,ydir

line2
* compare xdiff,ydiff and set up:
* larger = larger difference
* smaller = smaller difference
* ygreater = 0 if x greater, 1 if y greater
 cmp.w xdiff,ydiff
 bcc.s line3
* ydiff<xdiff
 move.w xdiff,larger
 move.w ydiff,smaller
 move.w #0,ygreater
 bra.s line4

line3
* ydiff>xdiff
 move.w ydiff,larger
 move.w xdiff,smaller
 move.w #1,ygreater

line4
* xdiff,ydiff not used from here on ,so d6/d7 are free for x/y
* testw = smaller*2-larger
* testw oscillates around zero.
* at each point, if it is
* -ve:step is orthogonal
* 0 or +ve, step is diagonal
 move.w smaller,testw
 asl.w #1,testw
 sub.w larger,testw

line5
* as each point is plotted, testw is modified by:
* diagonal step; - testminus
* orthogal step; + testplus
 move.w smaller,testplus
 asl.w #1,testplus

 move.w larger,testminus
 sub.w smaller,testminus
 asl.w #1,testminus

* increment total number of steps to make (larger)
 addq.w #1,larger
* set up x and y
 move.w x1(pc),x
 move.w y1(pc),y

linedraw
 bsr point
 bne.s linedraw1
 bsr plotaddrmask
linedraw1

* see if line is finished
 subq.w #1,larger
 move.w larger,d0
 beq.s linedrawend

 tst.w testw
 bmi.s lineorthog
* diagonal move
 bsr.s gohoriz
 move.w ydir,d0
 bmi.s diagdown
 addq.w #1,y * bsr.s goup
 sub.w testminus,testw * bsr.s subtest
 bra.s linedraw

diagdown
 subq.w #1,y * bsr.s godown
 sub.w testminus,testw * bsr.s subtest
 bra.s linedraw

lineorthog
* orthogonal move
 move.w ygreater,d0
 bne.s orthvert

* move horizontally
 bsr.s gohoriz
 add.w testplus,testw * bsr.s addtest
 bra.s linedraw

orthvert
 move.w ydir,d0
 bmi.s orthdown
 addq.w #1,y * goup
 add.w testplus,testw * bsr.s addtest
 bra.s linedraw

orthdown
 subq.w #1,y * godown
 add.w testplus,testw * addtest
 bra.s linedraw

linedrawend
 rts
*---
gohoriz
 move.w xdir,d0
 bmi.s linegoleft
 addq.w #1,x
 rts
linegoleft
 subq.w #1,x
 rts
*---
fill
* converted from amstrad version used for mole
* register useage:
* d0                                      a0
* d1                                      a1
* d2 filldir                              a2 
* d3 leftend                              a3 leftmost
* d4 rightend                             a4 rightmost
* d5 mask                                 a5 fillsp
* d6 x                                    a6 driver block
* d7 y                                    a7 sp
filldir equr d2
leftend equr d3
rightend equr d4
leftmost equr a3
rightmost equr a4
fillsp equr a5
 bsr convertargs
* move.w #0,leftmost
* move.w leftmost,rightmost
 lea fillstackbase(pc),a0
 move.w a0,fillsp
 lea storedsp(pc),a0
 move.l sp,(a0) * preserve sp to make error handling etc. easy

 move.w x1(pc),x
 move.w y1(pc),y
 move.w x,rightend * x1
 move.w rightend,leftend * x1
 move.w rightend,leftmost
 move.w rightend,rightmost
 move.b #0,filldir
 lea fillstackbase(pc),fillsp

 bsr point
 bne fillret * not ok to plot, so forget it
* amstrad does something odd here. Important ?
* z80 code is: ld a,(colour) ; cp c ; ret z

 bsr fillpush
 bsr fill1
 move.b #$FF,filldir
 bsr movevertically * move down a pixel, onto a clear area (maybe)

fill1

 move.w rightend,x
 add.w leftend,x
 asr.w #1,x

 bsr point
 bne fillend
 move.l a0,-(sp)
 move.w mask,-(sp)
 move.w x,-(sp)
 move.b screenresolution(pc),d0
 cmp.b #2,d0
 beq golefthires
 cmp.b #0,d0
 beq goleftlowres
goleft1
 cmp.w #screenright,x
 bhi goleftend  * unsigned >
 cmp.w #screenleft,x
 bcs.s goleftend * unsigned <
 bsr pointaddrmask
 bne.s goleftend
 bsr plotaddrmask
 subq.w #1,x
 rol.b #1,mask
* have we come to the end of a byte (8-pixel block) ?
 bcc.s goleft1 * no, so carry on

* have we come to the end of a word (16-pixel block) ?
 subq.l #1,a0
 move.w a0,d0
 btst #0,d0
 beq.s goleft1 * still within word, so carry on
goleft2
* cmp.w #screenright,x
* bhi goleftend * unsigned >
* cmp.w #screenleft,x
* bcs.s goleftend * unsigned <
 subq.l #2,a0
 bra.s goleft1

goleftend
* x is pixel at which plotting was impossible
* so set leftmost to the pixel at the end of the drawn line
 addq.w #1,x
 move.w x,leftmost
* restore values for first point plotted
 move.w (sp)+,x
 move.w (sp)+,mask
 move.l (sp)+,a0

* goright
* must inc position first, so order of code is reversed from goleft
 addq.w #1,x
 ror.b #1,mask
 bcs.s goright4 * is mask now at leftmost pixel of byte ?
goright2
 cmp.w #screenright,x
 bhi.s gorightend * unsigned >
 cmp.w #screenleft,x
 bcs.s gorightend * unsigned <

 bsr pointaddrmask
 bne.s gorightend
 bsr plotaddrmask
 addq.w #1,x
 ror.b #1,mask
* at end of byte (8pixels) ?
 bcc.s goright2 * no, so carry on
goright4
 addq.l #1,a0
* at end of word (16 pixels)?
 move.w a0,d0
 btst #0,d0
 bne.s goright2 * carry on
 addq.l #2,a0
 bra.s goright2

gorightend
 subq.w #1,x
 move.w x,rightmost
 bra changeend

*---
goleftlowres
 cmp.w #lowresscreenright,x
 bhi.s gllowresend  * unsigned >
 cmp.w #lowresscreenleft,x
 bcs.s gllowresend * unsigned <
 bsr pointamlowres
 bne.s gllowresend
 bsr plotaddrmask
 subq.w #1,x
 rol.b #1,mask
* have we come to the end of a byte (8-pixel block) ?
 bcc.s goleftlowres * no, so carry on

* have we come to the end of a word (16-pixel block) ?
 subq.l #1,a0
 move.w a0,d0
 btst #0,d0
 beq.s goleft5 * still within word, so carry on
 subq.l #6,a0
goleft5
** bra.s goleftlowres
*
* now modifications to increase speed of horizontal lines
 move.b optioncolour,d0
gllowresspeedup
* are we still on screen ?
* cmp.w #(lowresscreenright-8),x
* bhi.s gllowresend  * unsigned >
 cmp.w #(lowresscreenleft+8),x
 bcs.s goleftlowres * llowresend * unsigned <
* and option 0 plots regardless of what's there already
 tst.b $1(a6) * fill option
 beq.s glls1
 move.b (a0),d0
 cmp.b hioptioncolour,d0
 bne.s goleftlowres * not a clear run
 move.b $2(a0),d0
 cmp.b looptioncolour,d0
 bne.s goleftlowres * not a clear run
glls1
 move.b hicolour,(a0)
 move.b locolour,$2(a0)
 subq.l #1,a0
 subq.w #8,x
 move.w a0,d0
 btst #0,d0
 beq.s gllowresspeedup * still within word, so carry on
 subq.l #6,a0
 bra.s gllowresspeedup * goleftlowres
*--
gllowresend
* x is pixel at which plotting was impossible
* so set leftmost to the pixel at the end of the drawn line
 addq.w #1,x
 move.w x,leftmost
* restore values for first point plotted
 move.w (sp)+,x
 move.w (sp)+,mask
 move.l (sp)+,a0

* goright
* must inc position first, so order of code is reversed form goleft
grlowres1
* must inc position first, so order of code is reversed form goleft
 addq.w #1,x
 ror.b #1,mask
 bcc.s grlowres2 * is mask now at rightmost pixel of byte ?
grlowres1a
 cmp.w #lowresscreenright,x
 bhi.s grlowresend * unsigned >
 cmp.w #lowresscreenleft,x
 bcs.s grlowresend * unsigned <
 addq.l #1,a0

* new block of 16 pixels ?
 move.w a0,d0
 btst #0,d0
 bne.s grlowressamepage * still within word, so carry on
 addq.l #6,a0
grlowressamepage
* cmp.w #(lowresscreenright-8),x
* bhi.s grlowres2

 tst.b option
 beq.s grlowres1b

 move.b (a0),d0
 cmp.b hioptioncolour,d0
 bne.s grlowres2 * not a clear run
 move.b $2(a0),d0
 cmp.b looptioncolour,d0
 bne.s grlowres2 * not a clear run
grlowres1b
 move.b colour,(a0)
 move.b hicolour,(a0)
 move.b locolour,$2(a0)
 addq.w #8,x
 bra.s grlowres1a
grlowres2
 bsr pointamlowres
 bne.s grlowresend
 bsr plotaddrmask
 bra grlowres1
*---

grlowresend
 subq.w #1,x
 move.w x,rightmost
 bra changeend

*---
golefthires
 cmp.w #hiresscreenright,x
 bhi.s glhiresend  * unsigned >
 cmp.w #hiresscreenleft,x
 bcs.s glhiresend * unsigned <
 bsr pointamhires
 bne.s glhiresend
 bsr plotaddrmask
 subq.w #1,x
 rol.b #2,mask
* have we come to the end of a byte (4-pixel block) ?
 bcc.s golefthires * no, so carry on

 subq.l #1,a0
* now modifications to increase speed of horizontal lines
 move.b optioncolour,d0
glhiresspeedup
* are we still on screen ?
 cmp.w #hiresscreenright,x
 bhi.s glhiresend  * unsigned >
 cmp.w #(hiresscreenleft+4),x
 bcs.s golefthires * lhiresend * unsigned <
* and option 0 plots regardless of what's there already
 tst.b $1(a6) * fill option
 beq.s glhs1
 cmp.b (a0),d0
 bne.s golefthires * not a clear run
glhs1
 move.b colour,(a0)
 subq.l #1,a0
 subq.w #4,x
 bra.s glhiresspeedup * still within word, so carry on

glhiresend
* x is pixel at which plotting was impossible
* so set leftmost to the pixel at the end of the drawn line
 addq.w #1,x
 move.w x,leftmost
* restore values for first point plotted
 move.w (sp)+,x
 move.w (sp)+,mask
 move.l (sp)+,a0

grhires1
* must inc position first, so order of code is reversed form goleft
 addq.w #1,x
 ror.b #2,mask
 bcc.s grhires2 * is mask now at leftmost pixel of byte ?
grhires1a
 cmp.w #hiresscreenright,x
 bhi.s grhiresend * unsigned >
 cmp.w #hiresscreenleft,x
 bcs.s grhiresend * unsigned <
 addq.l #1,a0
 tst.b option
 beq.s goright1b
 move.b optioncolour,d0
 cmp.b (a0),d0
 bne.s grhires2
goright1b
 move.b colour,(a0)
 addq.w #4,x
 bra.s grhires1a
grhires2
 bsr pointamhires
 bne.s grhiresend
 bsr plotaddrmask
 bra grhires1
* addq.w #1,x
* ror.b #2,mask
** at end of byte (8pixels) ?
* bcc.s grhires2 * no, so carry on
*grhires4
* addq.l #1,a0
*
* bsr conditionalbreakpoint
*
*grhiresspeedup
* are we still on screen ?
* cmp.w #hiresscreenright,x
* bhi.s grhiresend  * unsigned >
* cmp.w #hiresscreenleft,x
* bcs.s grhiresend * unsigned <
* and option 0 plots regardless of what's there already
* tst.b $1(a6) * fill option
* beq.s grhs1
* cmp.b (a0),d0
* bne.s grhires2 * not a clear run, so carry on
*grhs1
*move.b colour,(a0)
* addq.l #1,a0
* addq.w #4,x
* bra.s grhiresspeedup * still within word, so carry on

grhiresend
 subq.w #1,x
 move.w x,rightmost

* drop through to changeend

changeend
 move.w rightend,d0
 addq.w #1,d0
 sub.w rightmost,d0
 bcc.s change2
 bsr fillpush
 bsr inverty
 bcs.s change2
 bsr movevertically
 move.w rightend,leftend
 addq.w #2,leftend
 move.w rightmost,rightend
 bsr fill1
change2
 move.w rightmost,d0
 addq.w #1,d0
 sub.w rightend,d0
 bcc.s change3
 bsr fillpush
 move.w rightmost,leftend
 addq.w #2,leftend
 bsr fill1
change3
 move.w leftmost,d0
 addq.w #1,d0
 sub.w leftend,d0
 bcc.s change4
 bsr fillpush
 bsr inverty
 bcs.s change4
 bsr movevertically
 move.w leftend,rightend
 subq.w #2,rightend
 move.w leftmost,leftend
 bsr fill1
change4
 move.w leftend,d0
 addq.w #1,d0
 sub.w leftmost,d0
 bcc.s linedone
 bsr fillpush
 move.w leftmost,rightend
 subq.w #2,rightend
 bsr fill1
linedone
 bsr checky
 bcs.s fillpop
 bsr movevertically
 move.w leftmost,leftend
 move.w rightmost,rightend
 bra fill1
*---
inverty
* return carryset if at top/bottom of screen
 not.b filldir
 bsr checky
 bcc.s invertyret
inverty2
 not.b filldir
 sub.w #fillspentrylength,fillsp * discard value from sp
 move.b #$ff,ccr * set carry flag
invertyret
fillret
 rts
*---
checky
* return carry set if at top/bottom of screen
 tst.b filldir
 bmi.s checky0
 cmp.b screenheight+1,y * screenheight should be a word
 bcs.s checky1
checkyfail
* yes - so set carry flag
 move.b #$ff,ccr * set carry flag
 rts
checky0
* check at bottom of screen ( i.e. near the middle of the monitor)
 cmp.w #2,y
 rts
checky1
 move.b #0,ccr * clear carry flag
 rts
*---
movevertically
 tst.b filldir
 bpl.s movevertinc
 subq.w #1,y
 rts
movevertinc
 addq.w #1,y
 rts
*---
fillspoverflow
 move.l storedsp(pc),sp
 rts
*---
fillpush
 lea fillstackbase(pc),a0
 move.l fillsp,a1
 sub.l a0,a1
 cmp.l #fillspmax,a1
 bhi fillspoverflow * unsigned >
 move.w filldir,(fillsp)+
 move.w leftend,(fillsp)+
 move.w rightend,(fillsp)+
 move.w leftmost,(fillsp)+
 move.w rightmost,(fillsp)+
 move.w y,(fillsp)+
 rts
*---
fillpop
 move.w -(fillsp),y
 move.w -(fillsp),rightmost
 move.w -(fillsp),leftmost
 move.w -(fillsp),rightend
 move.w -(fillsp),leftend
 move.w -(fillsp),filldir
 rts
*---
fillend
 addq.w #1,x
 move.w x,leftmost
 cmp.w rightend,leftend
 beq.s fillpop
 bsr fillpush
fill2
* find centre point of (leftend),(rightend)
 add.w leftend,rightend
 asr.w #1,rightend
 bsr fill1
fillend1
 add.w rightend,leftend
 asr.w #1,leftend
 addq.w #1,leftend
 bra fill1
*---

addvblevent
* on entry, a1.l is address of a new vbl event
 move.b #0,d0 * count of number of entries in vbl queue
 move.l $456,a0 * get address of array of VBL routines P.238 STInterns
* now scan list
addvbl
 tst.l (a0)
 beq.s addvbl2
 addq.b #1,d0 * number of entries in queue
 addq.l #4,a0
 bra.s addvbl
addvbl2
* max number of vbl routines is 8
 cmp.b #8,d0
 bcc vbloverflow  * unsigned >=
* set up pointer to my routine
 move.l a1,(a0)
 rts
*---
* SPLIT SCREEN CODE
* See P. 235,237,147 in ST Internals
initsplitscreen
* first, set medium res mode, so OS will print 80 column text correctly
 move.w #1,-(sp) * medium resolution
 move.l #-1,-(sp) * retain physical base
 move.l #-1,-(sp) * retail logical base
* move.w #5,-(sp) * set screen
 call_ebios _setscreen
 add.l #12,sp

* and set irq mask to disable all interrupts (except NMIs)
 move.b #7,d7
 bsr setirqmask

* now set up MY HBL handler routine
 move.l $68,d0
 lea oshblhandler,a0
 move.l d0,(a0) * preserve os hbl handler

 lea hblhandler,a0
* move.l a0,$68 * exception vector for level 2 interrupt (#26)
 move.l a0,-(sp)
 move.w #26,-(sp)
 move.w #5,-(sp)
 trap #13               * setexec - see P.147 ST Internals
 addq.l #8,sp

* now set interrupt mask to 1 to allow HBL interrupts
 move.b #1,d7
 bsr setirqmask
 rts

* the following code is very useful for playing around
* with the split screen and removing flicker - so LEAVE IT IN !!!

iloop
 lea driverbuffer(pc),a6
 addq.l #1,$7e000
 bsr waitkey
 cmp.b #" ",(a6)
 beq.s iloop
 move.b (a6),d0
 move.w d0,-(sp)

 move.b midsplitpos,d0
 bsr hexbyted0
 move.b #" ",(a6)
 move.b #oswrchdcode,d0
 bsr driver
 move.b lowsplitpos,d0
 bsr hexbyted0
 move.b #$0d,(a6)
 move.b #oswrchdcode,d0
 bsr driver

 move.w (sp)+,d0
 cmp.b #"1",d0
 bne.s adjustnotleft
 subq.b #1,lowsplitpos
 bra.s iloop
adjustnotleft
 cmp.b #"2",d0
 bne.s adjustnotright
 addq.b #1,lowsplitpos
 bra.s iloop
adjustnotright
 cmp.b #"3",d0
 bne.s adjustnotup
 subq.b #1,midsplitpos
 bra.s iloop
adjustnotup
 cmp.b #"4",d0
 bne.s iloop
 addq.b #1,midsplitpos
 bra.s iloop

*---
splitmargin equ 8

normalvblhandler
 dc.l 0
midsplitpos
 dc.b $B4 * middle address of low-to hi res split
 even
lowsplitpos 
 dc.b $0
 even


hblhandler
* executed in supervisor mode
* This is an interrupt routine - preserve all registers
* most registers can be corruted
 move.w d0,-(sp)
 move.b $ff8207,d0 * middle video address pointer
 cmp.b midsplitpos,d0
 bcs.s csrte
 sub.b #splitmargin,d0
 cmp.b midsplitpos,d0
 bcs.s tohires
csrte
 move.w (sp)+,d0
 rte * no action at the moment

tohires
 move.w #$2700,sr * supervisor mode, nmis only
* first wait for SPLITMARGIN pages of memory to be displayed
tohiresa
 move.b $ff8207,d0
 sub.b #splitmargin,d0
 cmp.b midsplitpos,d0
 bne.s tohiresa
tohires1
* now wait for the scanning beam to go off-screen
 move.b $ff8209,d0
 cmp.b lowsplitpos,d0
 bcs.s tohires1 * unsigned <
tohires2
 move.b $ff8209,d0
 cmp.b lowsplitpos,d0
 bhi.s tohires1 * unsigned >

 move.b #1,$ff8260 * 640x200, 4 col - for text
* move.b #44,$ff8240 * colour pallette 0
 move.w (sp)+,d0
 rte

irqvblhandler
* vertical blank interrupt
 move.w d0,-(sp)

 move.l a0,-(sp)
 lea realtimeclock,a0
 addq.l #1,(a0) * increment real time clock
 move.l (sp)+,a0

 tst.b drivergraphicsmode
 beq.s ivhnosplit * don't do split screen
 move.b screenresolution,d0
 cmp.b #hires,d0
 beq.s ivhnosplit

 move.b #0,$ff8260 * 320x200, 16 col - for graphics

ivhnosplit
 move.w (sp)+,d0
 move.l a0,-(sp)
 lea snoozesinceswap,a0
 clr.b (a0)
 move.l (sp)+,a0

 bsr ist1
 move.l osvblhandler,-(sp)
 rts
*---
setirqmask
* this routine must be executed in supervisor mode
* d7.b = new irq mask
* (bottom three bits of status register)
 and.w #7,d7
 asl.w #8,d7
 move.w sr,d0
 and.w #$f8ff,d0
 or.w d7,d0
 move.w d0,sr
 rts
*---
callsupera0
* this routine executes subroutine at a0.l in supervisor mode
 move.l a0,-(sp)
* move.w #38,-(sp)
 call_ebios supexec
 addq.l #6,sp
 rts
*---
vbloverflow
 bsr prs
 dc.b "Fatal error - VBL overflow. Press a key to return to gem",cr,0
 bsr waitkey
 bra returntogem

*---
 even

fillstackbase
 ds.b fillspmax

 endc * graphics only section of driver
*---
conditionalbreakpoint
* do a breakpoint if cr pressed
 movem.l d0-d7/a0-a6,-(sp)
cb1
 bsr absgetcharfrombdos
 tst.b d0
 beq.s cb1
 cmp.b #13,d0
 bne.s cbend
 dc.w $4afa
cbend
 movem.l (sp)+,d0-d7/a0-a6
 rts
*---
* graphics workspace
x1 dc.w 0
y1 dc.w 0
x2 dc.w 0
y2 dc.w 0
storedsp dc.l 0
colour dc.b 0
optioncolour dc.b 0
drivergraphicsmode dc.b 0
hioptioncolour dc.b 0
looptioncolour dc.b 0
locolour dc.b 0
hicolour dc.b 0


 even
snoozesinceswap dc.b 0
cursorxpos dc.b 0
cursorypos dc.b 0
scrolledlines dc.b 0
pageingdisabled dc.b 0
outputdevice dc.b 2 ; starts set to CON:

 even
cyclicwriteptr dc.l 0
cyclicbufferstart dc.l 0
cyclicbufferend dc.l 0
cycliccharsused dc.l 0
currentlineoffset dc.w 0
cyclicib
 ds.b 4000
cyclicibtop

 even
realtimeclock dc.l 0
oshblhandler dc.l 0
osvblhandler dc.l 0
taskstackptr dc.l 0
newtaskstackptr dc.l 0
 ds.b 1024 * probably over the top
gintstacktop
* ---
driveribuffreadptr dc.w 0
driveribuffwriteptr dc.w 0
driveribuffsize equ 4096

driveribuff
 ds.b driveribuffsize
*---

 even
logdriverblock
 dc.l 0
 dc.l 0
 dc.b "LOG.BAT",0
 even

batchptr dc.l 0
executingcommandfile dc.b 0
 even

scrolldriverbuffer
 dc.l 0

driverbuffer
 ds.b 40
 
 even                  GEMDOS likes even length files


