; MENU.TXT
;
; Copyright (C) 1988 Level 9 Computing
;
; M.J.Austin 7-8-88
;
 begin

.DoMenu
; first ensure both frames have same display...
 gosub @EqualiseFrames

 gosub @MCCheckSum ;******
 if v1=0 then CS7 ;****
 break ;****
.cs7 ;*****

 HighlightedLine=1
 CurrentMenu=2 ; 0 is not present.

.DoMenuLoop
 if CurrentMenu=0 then @HeroLoop
 gosub DisplayCurrentMenu
 gosub @DisplayTextLine
 gosub @DisplayFrame
 gosub @WaitForFrame

;>>code -
 gosub @MakeMenuSelection
;>>code +
 if SelectedLine=0 then NoSelection
 gosub @HandleSelection
.NoSelection
 gosub @MCHeroInput ;*****
 V1=ByteWS(ByteLastKeyPressed) ;*
 if V1=13 then @MCCloseDown ;*
; gosub @WaitForFrame ;*
; gosub @LimitFrameRate
; v1=MenuDelay
; gosub @DelayV1

 goto DoMenuLoop
;---
.DisplayCurrentMenu
; Display CurrentMenu
; 3 bytes per entry
 gosub @DoFirstMenuLine ; clear screen, set up Line etc.
 &l0=MenuTable(CurrentMenu) ; start with verbs table
;>>code -
.DM1

 V1=MenuTable(l0)
 if V1=255 then DisplaymenuEnd
 add l0,c3 ; get message number offset for this entry
 V1=MenuTable(l0)
 l1=500 ; base of messages ;100
 add l1,V1
 wielded=0 ;*****
 magic=0 ;*****
 gosub @PrintMenuLineL1 ; handles highlighted line etc., increments Line.
 add l0,c1 ; on to next entry
 goto DM1

.DisplayMenuEnd
 NumEntries=Line
 SUB NumEntries,c1
;>>code +
 return

;---
.GetObject
; display inventory/whatever, using linked list starting with LL(L2)
 HighlightedLine=1

.GetObjectLoop
 gosub @PrintInv
 gosub @DisplayTextLine
 gosub @DisplayFrame
 gosub @MCHeroInput
;>>code -
 gosub MakeMenuSelection
;>>code +
 gosub @WaitForFrame
 gosub @LimitFrameRate
; v1=MenuDelay
; gosub @Delay1

 if SelectedLine=0 then GetObjectLoop
 HighLightedLine=1 ; reset for higher menu level
 return
;---
;>>code -
.MakeMenuSelection
; called from interpreted mode
 SelectedLine=0
 V1=ByteWS(ByteJoystickStatus)
 if V1<>1 then NotUp
 if HighlightedLine=1 then NotUp
 if RepeatCount>0 then @JoystickDelay
 RepeatCount=1
 sub HighLightedLine,c1
 goto @MMSEnd

.NotUp
 if V1<>2 then NotDown
 if HighlightedLine=NumEntries then NotDown
 if RepeatCount>0 then @JoystickDelay
 RepeatCount=1
 add HighLightedLine,c1
 goto @MMSEnd

.NotDown
 if v1<>8 then NotRight
 if RepeatCount>0 then @JoystickDelay
 RepeatCount=1
 x1=5
 add HighlightedLine,x1
 if HighLightedLine<NumEntries then NoLimitRight
 HighlightedLine=NumEntries
.NoLimitRight
 goto MMSEnd

.NotRight
 if v1<>4 then NotLeft
 if RepeatCount>0 then @JoystickDelay
 RepeatCount=1
 x1=5
 sub HighLightedLine,x1
 if highlightedLine>32000 then LimitLeft
 if HighLightedLine<>0 then NoLimitLeft
.LimitLeft
 HighlightedLine=1
.NoLimitLeft
.MMSEnd
; check if we need to scroll the window
 if HighlightedLine>FirstLine then MMSTopOk
; if HighlightedLine=FirstLine then MMSTopOk
 sub FirstLine,c1
 goto @MMSEnd ; check again for large movements up or down

.MMSTopOk
 x1=MenuHeight
 add x1,FirstLine ; first line NOT displayed
 if HighlightedLine<x1 then MMSBottomOk
 add FirstLine,c1
 goto MMSTopOk

.MMSBottomOk
 return

.NotLeft
 if V1<>128 then NotButton
 SelectedLine=HighLightedLine
;>>code +
  gosub @WaitForJoystick ;  return
;>>code -
 goto JDRet

.NotButton
; no joystick input, so clear delay flag
 RepeatCount=0

.NotJoystick
 goto JdRet
;-
.JoystickDelay
; stop joystick movements being too rapid
 add RepeatCount,c1
 if RepeatCount<5 then JDRet
 RepeatCount=0
.JDRet
 return
;---
 ;>>code +

.RemoveFromLL
; remove Entry LL(ObjectInfo)
; (Previous entry in chain was LL(PreviousObjectInfo))
 &x7=LL(ObjectInfo)
 &LL(PreviousObjectInfo)=x7
; and add to the start of the free space list.
 &LL(ObjectInfo)=LLFree
 &LLFree=ObjectInfo
 return
;---
.InitRangedWeapons
; set up names of ranged weapons
;*****
; initial "free gift" weapon is a bow...
;
; add to player inventory
 l0=InvNameOffset
 add L0,LLFree
 x1=35 ; bow
 &LL(L0)=x1
 gosub @AddToPlayerInv
;
; now add to range weapons list
 GOSUB @AddRangedWeapon
 v1=RWWieldedOffset
 &v2=ll(LLRangedWeapons)
 add v1,v2
 wielded=5
 LL(V1)=wielded				; set (wielded) extension message
 ByteWs(ByteCurrentWeapon)=c0		; set up missile type
 ByteWs(ByteSourceWeapon)=x1		; set up source weapon
;; return ;********************
;
; Add Ranged Weapons For Testing...
;
 x1=60
 gosub @AddRangedWeapon
 x1=61
 gosub @AddRangedWeapon
 x1=62
 gosub @AddRangedWeapon
 x1=63
 gosub @AddRangedWeapon
 x1=64
 gosub @AddRangedWeapon
 x1=65
 gosub @AddRangedWeapon
 x1=66
 gosub @AddRangedWeapon
 x1=67
 gosub @AddRangedWeapon
 x1=68
 gosub @AddRangedWeapon
 x1=69
 gosub @AddRangedWeapon
 x1=70
 gosub @AddRangedWeapon
 x1=71
 gosub @AddRangedWeapon
 x1=72
 gosub @AddRangedWeapon
 x1=73
 gosub @AddRangedWeapon
 x1=74
; fall through...
;---
.AddRangedWeapon
; add ranged weapon with name x1
 L0=LLRangedWeapons
 v1=RWNameOffset
 add v1,LLFree
 &LL(V1)=x1				; set name of weapon (for menu)
;
; find type of sprite to be used by missile
 v1=x1
 add v1,v1
 add v1,v1				; table of 4-byte entries
 x2=statisticoffset
 add v1,x2
 add v1,c3
 x2=list7(v1)				; x2=missile sprite type
 v1=RWTypeOffset
 add v1,LLFree
 LL(V1)=x2				; set type of weapon (for sprite)
;
 v1=RWWieldedOffset
 add v1,LLFree
 LL(v1)=c0				; make sure it's not wielded yet
;
 v1=InvCursedOffset
 add v1,LLFree
 LL(v1)=c0				; DO NOT curse ranged weapons
;
 v1=InvMagicOffset
 add v1,LLFree
 LL(v1)=c0				; range weapons are not magic
;
 goto addtoll
;*****
;
.AddToPlayerInv
; Add LL(LLFree) to the inventory chain: LL(PlayerInv)
 L0=LLPlayerInv
; drop through to AddToLL
;
.AddToLL
; add LL(LLFree) to LL(L0)
 &l1=LL(L0)
 &l2=LL(LLFree)
; save next item in free space chain
 if l2=0 then NoLLSpace
 &LL(LLFree)=l1 ; insert entry in LL chain
 &LL(L0)=LLFree
 LLFree=L2 ; remove entry from free space chain
 return
;---
.NoLLSpace
;*****
; ;>>code -
;  prs " No LL Space. "
; ;>>code +
; gosub @DisplayFrame
; gosub @LongDelay
; goto @RestartHero
 m1=757					; "can't carry any more"
 goto @AddMessageToOutputBuffer
;---
.InitLL
; clear flags in LL table such as wielded/cursed items etc.
 l0=0
.clearLL
 &LL(l0)=c0
 add l0,c2
 if l0<LLTableSize then ClearLL
;*****
;
 L2=LLEntrySize
 L0=0 ; first entry pointer
 L1=LLEntrySize ; second entry pointer
.InitLL1
 &LL(L0)=L1
 add L0,L2
 add L1,L2
 if L1<LLTableSize then InitLL1

; the initial pointers for the LL occupy the first
; few bytes of the LL (and therefore overlap with what would
; otherwise by the first entry). Therefore make free space
; point after this point:
 &LLFree=LL(LLPlayerInv)
 &LL(LLPlayerInv)=c0
 &LL(LLRangedWeapons)=c0 ; no ranged weapons yet
 goto @InitRangedWeapons
;----
.PrintInv
; print contents of Linked list which starts with LL(L2)
 gosub @DoFirstMenuLine
;>>code -
 L1=499 ; verbs-1
 add l1,Verb
 wielded=0 ;*****
 magic=0 ;*****
 gosub @PrintMenuLineL1
 ObjectInfo=L2
;>>code +
 &L0=LL(L2)
;>>code -
; PreviousObjectInfo will be overwritten before it may be needed 
; FirstLine is the first line currently displayed in menu
; scan through objects till we reach it...
.PrintInvScan1
 if l0=0 then @PrintInvEnd
 if Line>FirstLine then PrintInv1
 L1=InvNameOffset
 add L1,L0
;>>code +
 &L1=LL(L1) ; get object type
 &L0=LL(L0)
;>>code -
 add Line,c1
 goto PrintInvScan1
;
; now display the objects...
.PrintInv1
 if L0=0 then @PrintInvEnd
 x1=MenuHeight
 add x1,FirstLine ; first line NOT displayed
 L1=InvNameOffset
 add L1,L0
;>>code +
 &L1=LL(L1) ; get object type
;*****
 wielded=InvWieldedOffset
 add wielded,l0
 wielded=LL(wielded) ; get extended message (i.e. wielded etc.)
 magic=InvMagicOffset
 add magic,l0
 x8=x1
 x1=LL(magic)
 gosub @SignExtendX1
 magic=x1
 x1=x8
;*****
;>>code -
;*****
 if Line<>HighlightedLine then PrintInv2
 PreviousObjectInfo=ObjectInfo
.PrintInv2
 if Line>HighlightedLine then PrintInv20
 ObjectInfo=L0 ; preserve the object the user MAY select
.PrintInv20
;*****
 if FirstLine=0 then PrintInv1a
 if Line=x1 then PrintInv3
.PrintInv1a
 if Line>x1 then PrintInv3
 gosub @PrintMenuLineL1
 sub line,c1
;
.PrintInv3
 add Line,c1
;>>code +
 &L0=LL(L0)
;>>code -
 goto @PrintInv1
;
.PrintInvEnd
;>>code +
 NumEntries=Line
 SUB NumEntries,c1
 return
;>>code -
;---
.PrintMenuLineL1
;*****
 ;>>code +
 m1=l1
 gosub @ism1discovered ; show extended name if object use is known
 l1=m1
 ;>>code -
;*****
 ByteWS(ByteInvertFlag)=c0
 if Line<>HighLightedLine then PML1
 ByteWS(ByteInvertFlag)=c1 ; set up mc to print inverted text

.PML1
code -
 message l1
code +
;*****
 m1=735
 add m1,magic
code -
 message m1 ; extended message for magic offset
code +
 m1=720
 add m1,wielded
code -
 message m1 ; extended message for worn/wielded
;*****
 message 598 ; cr
code +
;>>code +
 gosub @DoCr
;>>code -
 add line,c1
 ByteWS(ByteInvertFlag)=c0
 return
;---
 ;>>code +
; for wands and scrolls etc, show their full name if their use 
; has been discovered. m1=object/message number
.ism1discovered
 if m1<minring then imdret
 if m1>maxpotion then imdret
 x2=discoveryoffsetminus40	; start of table-minring
 add x2,m1
 x2=list3(x2)		; x2=0 if object use is known
 if x2=0 then imdret
 m1=x2			; change to dummy name
.imdret
 return
;---
.CursorTopLeft
 LeftMargin=8 ;*****32
 TopMargin=32 ;*****64
 &WordWs(WordCursorXPos)=LeftMargin
 &WordWs(WordCursorYPos)=TopMargin
 return
;---
.DoCr
 &V1=WordWs(WordCursorYPos)
 V2=8
 add V1,V2
 &WordWs(WordCursorYPos)=V1
 &WordWs(WordCursorXPos)=LeftMargin
 return
;---
.DoFirstMenuLine
;; gosub @MCClearScreen
 gosub @CursorTopLeft
 v1=MenuPixelWidth ; x size
 v2=MenuPixelHeight ; y size
 gosub @MCClearRectangle

;; gosub @CursorTopLeft
 Line=1 ; Back is first line, 2 is first generated one.
 return
;---
.HandleSelection
 &HS0=MenuTable(CurrentMenu)
;>>code -
; given SelectedLine, CurrentMenu, take the appropriate action
 HS1=SelectedLine
 sub HS1,c1 ; give offset within menu
; multiply by 4 and add (size of each entry in MenuTable)
; to give position of the selection in MenuTable

 add HS1,HS1
 add HS1,HS1
 add HS0,HS1
; MenuTable(HS0) tells us what to do
 V1=MenuTable(HS0)
 if V1=0 then DoJump

 if V1<>2 then NotChangeMenu
 HighlightedLine=1
 V1=1
 add V1,HS0
 CurrentMenu=MenuTable(V1)
 goto @HandleSelectionEnd

.NotChangeMenu
 if V1<>1 then NotGetObject
; get object/other item from linked list (e.g. spell) first
 v1=2
 add v1,HS0
 L2=MenuTable(V1) ; get LL number to use in selection

;>>code +
  Verb=HighlightedLine
  gosub @GetObject
;>>code -
 if SelectedLine=1 then @HandleSelectionEnd ; "BACK" instead of object
; LL(ObjectInfo) is object to act upon

.NotGetObject
.DoJump
 V1=1 ; extract which jump entry to use from MenuTable.
 add V1,HS0
 V1=MenuTable(V1)
code -
 jump @JumpTable V1 ; dummy comment!

.JumpTable
 data @Null,@Quit,@Examine,@Drop,@Wield,@Wear ;
 data @Range,@Eat,@Drink,@System,@DisplayMap ;
 data @Restart ;

.Null
code +
 goto @HandleSelectionEnd
;-----
code -
.Restart
code +
  goto @NewLevel ;*****RestartGame
code -

.Quit
code +
  goto @MCCloseDown
code -

;------
.Examine
code +
 m1=InvNameOffset
 add m1,ObjectInfo
 &m1=LL(m1) ; name of object from inventory
;
;*****
; once scrolls have been read, their use is known to the player...
 if m1<minscroll then notexamscroll
 if m1>maxscroll then notexamscroll
; lose the scroll from the inventory
 gosub @RemoveFromLL
 x1=m1
 gosub @discoveruse			; use of scroll is now known
 x2=minscroll
 sub x1,x2
 m1=800
 add m1,x1				; default examine message
code -
 jump @ScrollJump x1			; do the specific wand routine
;
.ScrollJump
 data @wishing		; 80
 data @enchantarmour	; 81
 data @destroyarmour	; 82
 data @enchantweapon	; 83
 data @destroyweapon	; 84
 data @removecurse	; 85
 data @teleportme	; 86
 data @identify		; 87
 data @firescroll	; 88
 data @blankscroll	; 89
 data @dispelmagic	; 90
 data @blackhand	; 91
.blankscroll
code +
;
; return here from scroll routines, preferably with message m1
.doneexaminescroll
 gosub @AddMessageToOutputBuffer
 goto examineend
;
; not examine scroll, so just display object name for now
.NotExamScroll
 Gosub @PrintLLObject
 x1=InvCursedOffset
 add x1,ObjectInfo
 x1=LL(x1)
 x2=cursemask
 and x1,x2
 if x1=0 then examineend
 m1=759
 gosub @AddMessageToOutputBuffer	; "It looks cursed"
;
.examineend
 ;>>code -
 goto @HandleSelectionEnd
;---
; special scroll code. on entry, m1 contains default "examine scroll" 
; message. modify this if neccessary.
;---
code -
.wishing	; 80
code +
 goto @doneexaminescroll
;---
; enchant any armour worn
code -
.enchantarmour	; 81
code +
 x7=1					; wield body armour type
 gosub @enchantx7			; enchant body armour?
 if x6=true then enchantedarmour
 x7=2					; wield accessory armour type
 gosub @enchantx7			; enchant accessory armour?
 if x6=true then enchantedarmour
 m1=820					; "no wielded armour"
.enchantedarmour
 gosub @CalcAcWc			; recalc ac & wc
 goto @doneexaminescroll
;---
; destroy any armour worn
code -
.destroyarmour	; 82
code +
 x8=false				; even destroy cursed items
 gosub destroyarmour1
 goto @doneexaminescroll
;---
; used as a subroutine, because it is used by Nymph.
; on entry: x8=true if we should check if cursed before destroying
.destroyarmour1
 x7=1					; wield body armour type
 gosub @destroyx7			; destroy body armour?
 if x6=true then destroyedarmour
 x7=2					; wield accessory armour type
 gosub @destroyx7			; destroy accessory armour?
 if x6=true then destroyedarmour
 m1=820					; "no wielded armour"
.destroyedarmour
 gosub @CalcAcWc			; recalc ac & wc
 return
;---
code -
.enchantweapon	; 83
code +
 x7=3					; wield weapon type
 gosub enchantx7			; enchant first weapon wielded
 if x6=true then enchantedweapon
 m1=820					; "no wielded weapon"
.enchantedweapon
 gosub @CalcAcWc			; recalc ac & wc
 goto @doneexaminescroll
;---
code -
.destroyweapon	; 84
code +
 x8=false				; even destroy cursed items
 x7=3					; wield body weapon type
 gosub @destroyx7			; destroy weapon?
 if x6=true then destroyedweapon
 m1=820					; "no wielded weapon"
.destroyedweapon
 gosub @CalcAcWc			; recalc ac & wc
 goto @doneexaminescroll
;---
; enchant first item with wield byte x7
; x6 true if all went well
.enchantx7
 x6=false
 x3=LLPlayerInv
.enchant1
 &x4=LL(x3)
 if x4=0 then @enchantend
 x1=InvWieldedOffset
 add x1,x4
 x1=LL(x1)				; get wielded status
 if x1<>x7 then notenchant		; wrong wield type
;
; increase magic adjustment
 x1=InvMagicOffset
 add x1,x4
 x2=LL(x1)
 add x2,c1
 if x2<256 then newmagicoffset
 x5=256
 sub x2,x5				; handle magic gone +ve
 if x2<6 then newmagicoffset
 x2=5					; max +5
.newmagicoffset
 LL(x1)=x2
 x6=true				; weapon enchanted
 goto enchantend
;
.notenchant
 x3=x4 					; previous entry
 goto @enchant1				; not last entry
.enchantend
 return
;---
; destroy first item with wield byte x7
; on entry: set x8=true if we should check if cursed before destroying
; on exit: x6 true if all went well
.destroyx7
 x6=false
 x3=LLPlayerInv
.destroy1
 &x4=LL(x3)
 if x4=0 then @destroyend
 x1=InvWieldedOffset
 add x1,x4
 x1=LL(x1)				; get wielded status
 if x1<>x7 then notdestroy		; wrong wield type
;
 if x8=false then donttestcursed
;
; Get cursed status
 x1=InvCursedOffset
 add x1,x4
 x1=LL(x1)
 x2=cursemask
 and x1,x2
 if x1<>0 then notdestroy		; don't destroy - it's cursed!
;
; destroy object
.donttestcursed
 ObjectInfo=x4				; current pointer
 PreviousObjectInfo=x3			; last pointer
 gosub @RemoveFromLL
 x6=true				; weapon destroyed
 goto destroyend
;
.notdestroy
 x3=x4 					; previous entry
 goto @destroy1				; not last entry
.destroyend
 return
;---
; NB: Remove Curse ALSO Dispels Magic!
code -
.removecurse	; 85
code +
 x1=InvCursedOffset
 x3=LLEntrySize
.removec1
 x2=ll(x1)
 x4=uncursemask
 and x2,x4				; mask off cursed bit
 ll(x1)=x2
.dontrc
 add x1,x3
 if x1<LLTableSize then removec1
; Fall through...
;---
code -
.dispelmagic	; 90
code +
 x1=InvMagicOffset
 x3=LLEntrySize
.dispm1
 x2=ll(x1)
 if x2=0 then dontdm
 ll(x1)=c0
.dontdm
 add x1,x3
 if x1<LLTableSize then dispm1
 gosub @CalcAcWc			; recalc ac & wc
 goto @doneexaminescroll
;---
code -
.teleportme	; 86
code +
 gosub teleportme1
 goto @doneexaminescroll
;---
; subroutine because also called by teleportation ring
.teleportme1
 gosub @getrandompos			; v1,v2=random sprite pos
 x1=xposoffset
 add x1,PlayerSpriteOffset
 &SpriteTable(x1)=v1			; set new x pos
 playerx=v1
 &WordWS(WordScreenXPos)=v1
 x1=yposoffset
 add x1,PlayerSpriteOffset
 &SpriteTable(x1)=v2			; set new y pos
 playery=v2
 &WordWS(WordScreenYPos)=v2
 goto @MCPreScrollMap			; scroll to new map pos
;---
code -
.identify	; 87
code +
 x1=discoveryoffset
.ScrollDiscoverLoop
 list3(x1)=c0
 add x1,c1
 if x1<DiscoveryEnd then ScrollDiscoverLoop
 goto @doneexaminescroll
;---
code -
.firescroll	; 88
code +
 firescrollflag=true			; set on fire when return 
 goto @doneexaminescroll		; from menu
;---
code -
.blackhand	; 91
code +
 blackhandflag=true
 goto @doneexaminescroll
;---
; object x1 has just been used, and will now be referred to by its 
; true name (i.e. "wand of fire" instead of "runed wand")
; x1 is preserved. x2 and x3 are corrupted.
.discoveruse
 if x1<minring then duret
 if x1>maxpotion then duret
 x2=discoveryoffsetminus40	; start of table-minring
 add x2,x1
 list3(x2)=c0		; set flag for object use discovered
.duret
 return
code -
;*****

.Drop
code +
;
;*****
 v5=InvWieldedOffset
 add v5,ObjectInfo
 v5=LL(V5)				; wielded?
 if v5=0 then dropnotcursed
;
; if wielded, make sure it's not cursed before dropping
 v5=InvCursedOffset
 add v5,ObjectInfo
 v5=LL(V5)				; cursed?
 x1=cursemask
 and v5,x1				; test curse bit
 if v5=0 then dropnotcursed
 m1=754
 goto @AddMessageToOutputBuffer		; "cursed!"
;
.dropnotcursed
 x8=InvNameOffset
 add x8,ObjectInfo
 &x8=LL(x8)				; name of object from inventory
;
; convert object name into sprite number
.freespritefordrop
 x1=rangeoffset
 x2=0					; x2 is category counter
.convertobjecttosprite
 x3=list7(x1)				; x3 is beginning of category range
 add x1,c1
 x4=list7(x1)				; x4 is number in this range
 add x1,c1
 if x8<x3 then objectnotincategory	; object is below this category
 add x3,x4
 if x8<x3 then foundspriteforobject	; object is in this category
.objectnotincategory
 add x2,c1				; try next category
 if x2<23 then convertobjecttosprite
code -
 prs " can't find sprite "
code +
 gosub @displayframe
 gosub @longdelay
 return
.foundspriteforobject
;
; set up args: v1=xpos, v2=ypos, v3=xspeed, v4=yspeed, v5=sprite num
 v1=playerx
 v2=playery
 v3=0 ; xspeed
 v4=0 ; yspeed
 v5=x2					; v5 is sprite number
;
 x1=16
 add v1,x1				; starting at right of player...
 gosub @findvacantsquare		; ...find nearest vacant square
 if x1=false then @dropret		; tough cookie!
 gosub @MCSetUpNewSprite		; display the sprite
 x1=nameoffset
 add x1,v6				; find name offset of sprite.
 &SpriteTable(x1)=x8			; reset true name of object.
;
 v5=InvCursedOffset
 add v5,ObjectInfo
 v5=LL(v5)
 x1=CursedOffset
 add x1,v6				; reset curse adjustment
 SpriteTable(x1)=v5
;
 v5=InvMagicOffset
 add v5,ObjectInfo
 v5=LL(v5)
 x1=MagicOffset
 add x1,v6				; reset magic adjustment
 SpriteTable(x1)=v5
;
 m1=750					; "you have just dropped"
 gosub @AddMessageToOutputBuffer	; <object name>
 Gosub @printllObject
;
; was sprite really created? (i.e. enough free sprites)
 if v7<65000 then okspritedropped
 m1=758					; "turns to dust"
 gosub @AddMessageToOutputBuffer
.okspritedropped
;
; ring removed and dropped?
 if x8<minring then notdropring
 if x8>maxring then notdropring
 v5=InvWieldedOffset
 add v5,ObjectInfo
 x1=LL(v5)
 if x1=0 then notdropring		; was not wearing ring
 x2=ringtableminus40
 add x2,x8
 list3(x2)=c0				; clear flag for ring removed
.notdropring
;
.removefromlists
 gosub @RemoveFromLL			; lose entry from inventory
 ObjectInfo=LLRangedWeapons
 x1=x8
 gosub @DestroyEntry			; and maybe from ranged list
;
; if object destroyed was wielded, make sure we can't fire
 if x2<>5 then dropret			; range wield type is 5
 ByteWs(ByteSourceWeapon)=c0
;
.dropret
 gosub @CalcAcWc			; recalc ac & wc
 ;>>code -
 goto @HandleSelectionEnd
 ;>>code +
;---
; Add object at LL(ObjectInfo) to the textline in the form: 
; NAME, +/- MAGIC , DOT
.PrintLLObject
 v5=InvNameOffset
 add v5,ObjectInfo
 &m1=LL(v5)
 gosub @AddMessageToOutputBuffer	; <object name>
 v5=InvMagicOffset
 add v5,ObjectInfo
 x1=LL(v5)
 gosub @SignExtendX1
 m1=735
 add m1,x1				; <magic offset>
 gosub @AddMessageToOutputBUffer
 m1=599					; .
 goto @AddMessageToOutputBuffer
;---
code -
.Wear
.Wield
code +
 x1=InvNameOffset
 add x1,ObjectInfo
 &x1=LL(x1)			; x1 = name of object from inventory
 x3=LLPlayerInv
 gosub @removealreadywielded	; remove same objects already wielded
 if m1>750 then @wieldretm1	; object of same type is cursed
;
 x3=LLPlayerInv			; used by @unwield
;
; wear body armour ?
 if x1>maxarmour then notbodyarmour
 wielded=1			; wield body armour type
 gosub @unwield			; can only wear one item at a time
 goto wieldok
;
; wear accessory armour ?
.notbodyarmour
 if x1>maxarmourA then notaccarmour
 m1=702				; ok to wield
 wielded=2			; wield accessory armour type
 goto wieldok			; can wear many items
;
; wield hand weapon ?
.notaccarmour
 if x1>maxhand then nothandweapon
 wielded=3			; wield hand weapon type
 gosub @unwield			; can only wear one item at a time
 goto wieldok
;
.nothandweapon
; wear ring ?
.noaccarmour
 if x1<minring then notwearring
 if x1>maxring then notwearring
 x2=ringtableminus40
 add x2,x1
 list3(x2)=c1			; set flag for ring worn
 gosub @discoveruse		; identified when worn
 m1=704				; ok to wield
 wielded=4			; wield ring type
 goto wieldok			; can wear many rings
;
.notwearring
 m1=751				; "can't wield that"
;
.wieldok
; scroll message m1
 gosub @AddMessageToOutputBuffer
 if m1>750 then @wieldret	; message was error - don't wield
;
; scroll object name
 Gosub @printllObject
;
; now add extended message for wielded/worn items
.wieldnewitem
 v1=InvWieldedOffset
 add v1,ObjectInfo
 LL(V1)=wielded				; set (worn/wielded) status
;
; is it cursed?
 v1=InvCursedOffset
 add v1,ObjectInfo
 v1=LL(v1)
 x1=cursemask
 and v1,x1				; test curse bit
 if v1=0 then wieldret			; not cursed
 m1=753
;
.wieldretm1
 gosub @AddMessageToOutputBuffer	; cursed!
; 
.wieldret
 gosub @CalcAcWc			; recalc ac & wc
 ;>>code -
 goto @HandleSelectionEnd
 ;>>code +
;---
; a new item is about to be wielded, so "unwield" the old one.
; on entry, x3 contains linked list type (e.g. LLPlayerInv)
; on exit if the old item is cursed, then m1=760+wield. 
; otherwise, m1 contains 700+wield ("you are now wielding..." etc.)
.unwield
 &x1=LL(x3)
 if x1=0 then @unwieldend
 x7=InvWieldedOffset
 add x7,x1
 x2=ll(x7)
 if x2<>wielded then dontunwield
;
; found item wielded, but is it cursed?
 x4=InvCursedOffset
 add x4,x1
 x2=ll(x4)
 x4=cursemask
 and x2,x4				; test curse bit
 if x2=0 then wieldednotcursed
; can't remove other item wielded because it's cursed!
 m1=760
 add m1,wielded
 return
;
; not cursed, so "unwield" item
.wieldednotcursed
 ll(x7)=c0
.dontunwield
 x3=x1 					; previous entry
 goto @unwield
.unwieldend
 m1=700
 add m1,wielded				; "you are now wielding..."
 return
;---
; test if an object of same name x1 is already wielded. this is used to 
; avoid >1 of each item being worn (i.e. two helmets is rather silly!).
; however, to allow for weapons of same type but different magic 
; adjustments to be wielded, the weapon already wielded is "unwielded"
; to make way for the new one.
; on entry, x3 contains linked list type (e.g. LLPlayerInv)
; on exit, m1 contains 752 if couldn't "unwield" existing weapon
; (e.g. cursed), or 0 if all went well
.removealreadywielded
 m1=0
.raw1
 &x2=LL(x3)
 if x2=0 then @notawend
 x4=InvNameOffset
 add x4,x2
 &x4=LL(x4)				; get name
 if x4<>x1 then notaw			; different name
;
; found item of same name. is it wielded?
 x7=InvWieldedOffset
 add x7,x2
 x4=LL(x7)
 if x4=0 then notaw			; not wielded
;
; item of same name is wielded. is it cursed?
 x4=InvCursedOffset
 add x4,x2
 x4=ll(x4)
 x5=cursemask
 and x4,x5				; test curse bit
 if x4=0 then rawnotcursed
; can't remove other item wielded because it's cursed!
 m1=752					; existing one is cursed
 goto notaw
;
.rawnotcursed
 LL(x7)=c0				; unwield item
 return
.notaw
 x3=x2 					; previous entry
 goto @raw1				; not last entry
.notawend
 return
;---
; DESTROY the first item in LL with name x1.
; this is normally used to destroy items in the ranged weapons list 
; when they are removed from the inventory.
; note that the routine to remove the item from the inventory must
; test for curses etc., because this routine doesn't!
; on entry, ObjectInfo contains linked list type (e.g. LLPlayerInv)
.DestroyEntry
 PreviousObjectInfo=ObjectInfo
 &ObjectInfo=LL(PreviousObjectInfo)
 if ObjectInfo=0 then @DestroyEntryEnd
 x2=InvNameOffset
 add x2,ObjectInfo
 &x2=LL(x2)				; get name
 if x2<>x1 then NotDestroyEntry		; different name
;
 x2=InvWieldedOffset
 add x2,ObjectInfo
 x2=LL(x2)				; get wielded stat (for use
; Remove the entry...			; in .drop)
 Goto @RemoveFromLL
;
.NotDestroyEntry
 Goto @DestroyEntry			; not last entry
.DestroyEntryEnd
 x2=0					; clear "wielded" flag
 return
code -
;*****

.Range
code +
 v5=RWTypeOffset
 add v5,ObjectInfo
 v5=LL(V5)
 ByteWS(ByteCurrentWeapon)=v5
;*****
; the source of the weapon is now used to determine the effect on 
; collision (the sprite number returned from M/C was not versatile 
; enough).
; the M/C concerning missiles has been modified to set the sprite's 
; SourceWeaponOffset to the source weapon.
 ;>>code +
 v5=RWNameOffset
 add v5,ObjectInfo
 &v5=LL(V5)
 ByteWS(ByteSourceWeapon)=v5
;
; add extended (wielded) message to menu line
 wielded=5
 x3=LLRangedWeapons
 gosub @unwield				; "unwield" previous ranged weapon
 v5=RWWieldedOffset
 add v5,ObjectInfo
 LL(V5)=wielded
;
 m1=705
 gosub @AddMessageToOutputBuffer	; "your range weapon is"
 m1=ByteWS(ByteSourceWeapon)
 gosub @AddMessageToOutputBuffer	; <range weapon>
 m1=599 ; dot
 gosub @AddMessageToOutputBuffer
;
 ;>>code -
;*****
 goto @HandleSelectionEnd

;---
code -
.DisplayMap
code +
 gosub @EqualiseFrames
.DisplayMap1
; gosub @CyclicSpecials
 gosub @MCMapBuildBackground
;>>code -
;>>code +

 gosub @DisplayFrame
.DisplayMap2
 gosub @MCHeroInput
 x1=ByteWS(ByteLastKeyPressed)
 if x1=32 then @HeroLoop
 goto @DisplayMap2
code -
;---
.Drink
.Eat
code +
 v5=InvNameOffset
 add v5,ObjectInfo
;>>code +
 &v5=LL(v5) ; name of object from inventory
 gosub @RemoveFromLL
 x2=HitPointOffset
 add x2,PlayerSpriteOffset
 &x1=SpriteTable(x2)
 x3=500 ; more hit-points
 add x1,x3
 &SpriteTable(x2)=x1
 m1=604 ; you now feel much better
 gosub @AddMessageToOutputBuffer
;>>code -
 goto HandleSelectionEnd
;----
code -
.system
code +
.HandleSelectionEnd
; NB: If we came here from DROP, please note that ObjectInfo and 
; PreviousObjectInfo will have been corrupted!
;>>code +
 return
;---
