REM Text Blitz for ST
REM
REM Also designed to allow wide characters etc. to simulate
REM a 40 column mode on an 80 column screen
REM
REM opt d+
 Z=ALERT("[2][Do you want to write out a new font?][Yes|No]",2)
 IF Z=1 THEN PROCWriteOutFont

 PROCAssemble

 ?Resolution=SCREENMODE
 IF ?Resolution=2 THEN ?BytesPerScreenLine=80 ELSE ?BytesPerScreenLine=160
 PROCLoadFont
REM !FontAddress=FontSpace+16
 CALL InitScreenMode
 CALL GInpt
 STOP

\ CALL SpeedTest

 REPEAT :UNTIL INKEY$=" "


 STOP

\----------

\----------
 DEF PROCAssemble
crlf=13
cr=13
lf=10
bs=8
eof=26
cursorleft=2 :REM  ^B - Perfect Writer type control KEYs
cursorright=6 :REM ^F - used as VALues generated by cursor KEYs
cursorup=16 :REM ^P
cursordown=14 :REM ^N
pageoff=15
hlpkey=21
quitkey=17 :REM also = control-Q
autrunkey=18
lkey=19
undokey=20
c_rawcin=7
c_conis=11
 Start%=$70000
 FOR X=0 TO 2 STEP 2
 Ot$="L-"
[
 OPT X,Ot$
 ORG Start%
\--------
\ character constants

CharFromBdos
\ GET character from KEYboard in D0
\ without WAITing OR echo (NOT easy in Gem !)
 MOVE.W #c_conis,-(SP)\ CALL_bdos c_conis ; check IF KEY pending
 TRAP #1
 ADDQ.L #2,SP
 TST.L D0
 BMI.S osrdchgetkey
\ no KEY WAITing, so RETURN 0
 MOVE.B #0,D0
 RTS
osrdchgetkey
 MOVE.W #c_rawcin,-(SP) \ CALL_bdos c_rawcin ; GET KEY from buffer without echo
 TRAP #1
 ADDQ.L #2,SP
\
\ IF D0.B=0, the lower byte of the upper word may
\ contain a keyboard code for the cursor keys etc.
 TST.B D0
 BNE.S ogkret
 LSR.L #8,D0
 LSR.L #8,D0
 CMP.B #$48,D0
 BNE.S ogk1
 MOVE.B #cursorup,D0
 RTS
ogk1
 CMP.B #$4B,D0
 BNE.S ogk2
 MOVE.B #cursorleft,D0
 RTS
ogk2
 CMP.B #$4D,D0
 BNE.S ogk3
 MOVE.B #cursorright,D0
 RTS
ogk3
 CMP.B #$50,D0
 BNE.S ogk4
 MOVE.B #cursordown,D0
 RTS
ogk4
 CMP.B #$62,D0
 BNE.S ogk5
 MOVE.B #hlpkey,D0
 RTS
ogk5
 CMP.B #$61,D0
 BNE.S ogk6 ; undo KEY
 MOVE.B #undokey,D0
 RTS
ogk6
 CMP.B #$10,D0
 BNE.S ogk7 ; ALT-Q
 MOVE.B #quitkey,D0
 RTS
ogk7
 CMP.B #$13,D0
 BNE.S ogk8 ; ALT-R
 MOVE.B #autrunkey,D0
 RTS

ogk8
 CMP.B #$26,D0
 BNE.S ogk9 ; ALT-L
 MOVE.B #lkey,D0
 RTS

ogk9
\ $3B = f1
\ $3C = f2
\ $3d - f3 ... etc
 CLR.B D0
ogkret
 RTS

\--------------
Osrdch
\ ++ Cursor ON Phase
\ Add a cursor
 BSR InvertCursor
 MOVE.W #1000,D1
Osrdch1
 MOVE.W D1,-(SP)
 BSR CharFromBdos
 MOVE.W (SP)+,D1
 TST.B D0
 BNE.S InvertCursor \ turn off,ret
 DBRA D1,Osrdch1


\ ++ Cursor OFF Phase
\ Remove a cursor
 BSR InvertCursor
 MOVE.W #1000,D1
Osrdch2
 MOVE.W D1,-(SP)
 BSR CharFromBdos
 MOVE.W (SP)+,D1
 TST.B D0
 BNE.S OsrdchRet
 DBRA D1,Osrdch2
 BRA.S Osrdch

OsrdchRet
 RTS
\-------------
InvertCursor
\ preserves d0.b!
 MOVE.W D0,-(SP)
 BSR CalcCurrentCharAddress
 CLR.W D0
 MOVE.B CharHeight(PC),D0
 CLR.L D1
 MOVE.B BytesPerScreenLine(PC),D1
InvertCursor1
 EOR.B #$FF,(A0)
 ADD.L D1,A0
 DBRA D0,InvertCursor1
 MOVE.W (SP)+,D0
 RTS
\-----------

GInpt
 LEA GInptDriverBuffer(PC),A6
 MOVE.L A6,A5
 ADD.L #8,A5
 MOVE.L A5,A4 \ a4 stays as base

GInpt1
 MOVEM.L A0-A6,-(SP)
 BSR Osrdch
 MOVEM.L (SP)+,A0-A6
 CMP.B #quitkey,D0
 BEQ.S GInptRet \*********

 CMP.B #8,D0
 BNE.S GInptNotBS
\ Backspace.
\ Anything in buffer?
 CMP.L A4,A5
 BEQ.S GInpt1 \ no - ignore
\ yes - delete char from buffer
 SUBQ.L #1,A5
\ and echo BS
 BSR OswrchD0
 BRA GInpt1

GInptNotBS
 CMP.B #cursorleft,D0
 BNE.S GInptNotLeft
\ Anything in buffer?
 CMP.L A4,A5
 BEQ.S GInpt1 \ no - ignore
\ yes - move cursor to left
 BSR RetreatCursor
 BRA GInpt1

GInptNotLeft
 CMP.B #cursorright,D0
 BNE.S GInptNotRight
\ At end of buffer yet?
 BSR AdvanceCursor
 BRA GInpt1

GInptNotRight
\ And things which advance the
\ cursor...check for buffer full
 MOVE.L A5,A3
 SUB.L A4,A3
 CMP.W #500,A3
 BHI.S GInpt1

\ other control codes are ignored
 CMP.B #31,D0
 BLS.S GInpt1
\ as are >127
 CMP.B #127
 BGT.S GInpt1

\ Seems valid, write it to buffer.
 MOVE.B D0,(A5)+
 BSR OswrchD0
 BRA GInpt1

GInptRet
 RTS
\--------------
SpeedTest EVEN
\ MOVE.W #20,D2

SpeedTest0
 BSR InitScreenMode
 MOVE.W #100,D1
SpeedTest1 EVEN
 MOVE.B #65,D0

\ And offset alternate frames
 BTST.B #0,D2
 BEQ.S SpeedTest2
 ADDQ.B #1,D0
SpeedTest2 EVEN
 MOVEM.W D0-D2,-(SP)
 BSR OswrchD0
 MOVEM.W (SP)+,D0-D2
 ADDQ.B #1,D0
 CMP.B #128,D0
 BLS.S SpeedTest2
 DBRA D1,SpeedTest1
\ DBRA D2,SpeedTest0
 RTS
\-------
Oswrch
 MOVE.B CharToDraw(PC),D0
OswrchD0
 CMP.B #13,D0
 BNE.S OswrchNotCR
 LEA XCursorPos(PC),A0
 CLR.W (A0)
 RTS

OswrchNotCR EVEN
 CMP.B #10,D0
 BEQ ScrollScreen

OswrchNotLF EVEN
 CMP.B #8,D0
 BNE.S OswrchNotBS
 BSR RetreatCursor
 MOVE.B #32,D0
 BRA DrawCharD0

OswrchNotBS EVEN
 CMP.B #32,D0
 BLT.S OswrchRet
 BSR DrawCharD0
 BSR AdvanceCursor
OswrchRet EVEN
 RTS
\--------
CalcCurrentCharAddress EVEN
\ calculate the memory address of the current cursor position
 MOVE.L #$F8000,A0
 CLR.L D0
 CLR.L D1
 MOVE.W YScreenSize(PC),D0
 SUB.W YCursorPos(PC),D0
\ each LINE is 80 pels
 MOVE.W #80,D1
 MULU D0,D1
 ADD.L D1,A0
 CLR.L D0
 MOVE.W XCursorPos(PC),D0
 LSR.W #3,D0 \ 8 pixels per byte

\ AND.W #$FE,D0
\ ASL.W #2,D0

 ADD.L D0,A0

\ MOVE.W XScreenSize(PC),D0
\ TST.W #0,D0
\ BEQ.S DC1
\ ADDQ.L #1,A0
\
\DC1
 RTS
\---------
DrawChar EVEN
 MOVE.B CharToDraw(PC),D0

DrawCharD0 EVEN
\Calculate the address of the font for this char
 CLR.L D1
 MOVE.B D0,D1
 SUB.W #32,D1 \ min. char in font
 ASL.W #3,D1 \ times 8
 LEA FontSpace(PC),A2
 ADD.L D1,A2
\
 BSR CalcCurrentCharAddress
\ Now A0.l is address of top left of char.
\ and A2.l is address of character pattern

 MOVE.W #7,D1
DrawCharLoop EVEN
 MOVE.B (A2)+,(A0)
 ADD.L #80,A0
 DBRA D1,DrawCharLoop
 RTS

\---------
AdvanceCursor
 LEA XCursorPos(PC),A0
 ADDQ.W #8,(A0)
 MOVE.W (A0),D0
 CMP.W XScreenSize(PC),D0
 BLT.S AdvanceRet
 CLR.W (A0)
 LEA YCursorPos(PC),A0
 CMP.W #8,(A0)
 BLS.S ScrollScreen
 SUB.W #8,(A0)

AdvanceRet
 RTS
\-------
RetreatCursor
 LEA XCursorPos(PC),A0
 SUBQ.W #8,(A0)
 MOVE.W (A0),D0
 BPL.S RetreatRet
 MOVE.W XScreenSize(PC),(A0)
 SUBQ.W #8,(A0)
 LEA YCursorPos(PC),A0
 ADD.W #8,(A0)

RetreatRet
 RTS
\----------

ScrollScreen
\ And scroll screen...
 MOVE.L #$F8000,A0
 MOVE.L A0,A1
 ADD.L #640,A1

 MOVE.W #392,D0 \ lines to scroll

ScrollScreen1 EVEN
]
 FOR R=1 TO 20
[OPT X: MOVE.L (A1)+,(A0)+]
 NEXT
[OPT X
 DBRA D0,ScrollScreen1

 MOVE.W #640,D1
ScrollScreen2
 MOVE.L #0,(A0)+
 DBRA D1,ScrollScreen2
 RTS

\-----------
InitScreenMode
 MOVE.L #$F8000,A0
 MOVE.W #400,D0 \ lines to clear

InitScreen1 EVEN
]
 FOR R=1 TO 20
[OPT X: MOVE.L #0,(A0)+]
 NEXT
[OPT X
 DBRA D0,InitScreen1

 LEA XCursorPos(PC),A0
 MOVE.W #0,(A0)
 LEA YCursorPos(PC),A0
 MOVE.W #8,(A0)
 LEA XScreenSize(PC),A0
 MOVE.W #640,(A0)
 LEA YScreenSize(PC),A0
 MOVE.W #400,(A0) \ whole physical screen, regardless of split etc.
 RTS

XCursorPos DS.W 1 \ gives x cursor pos. 0 is leftmost column
YCursorPos DS.W 1 \ gives y cursor pos. 0 is bottom row
XScreenSize DS.W 1
YScreenSize DS.W 1 \ whole physical screen, regardless of split etc.
 EVEN

CharToDraw DS.W 1
Resolution DS.B 1
BytesPerScreenLine DS.B 1
CharHeight DS.B 1
BytesPerLine DS.B 1
MinChar DS.B 1
MaxChar DS.B 1
NumChars DS.B 1

 EVEN
Debug1 DS.L 1
Debug2 DS.L 1
Debug3 DS.L 1
FontAddress DS.L 1
 BSS

 EVEN

FontSpace
 DS.B 92*8

GInptDriverBuffer DS.B 512
]
 NEXT
 ENDPROC
REM --------
 DEF PROCWriteOutFont
 Name$=FNAskFileName+".FNT"
 F=OPENIN(Name$)
 CLOSE#F
 IF F>0 THEN Z=ALERT("[1][The Font File already exists][Abort]",1):ENDPROC

 C=32
 VDU 12
 PRINT "T"CHR$(255)
 PRINT "Position cursor at top of character"

 X=$F8C04
 REPEAT
  C=?X
  ?X=0
  FOR d=1 TO 10:NEXT
  ?X=255
  FOR d=1 TO 10:NEXT
  ?X=C
  C$=INKEY$
  IF C$="Z" THEN X=X-1
  IF C$="X" THEN X=X+1
  IF C$=";" THEN X=X-80
  IF C$="." THEN X=X+80
 UNTIL C$=CHR$(13)

REM Now write font out to file

 FO=OPENOUT(Name$)
 ?CharHeight=8
 ?BytesPerLine=1
 ?MinChar=32
 ?MaxChar=127
 NumChars=?MaxChar-?MinChar
REM L is length of actual font data - i.e. excluding header
 L=?CharHeight*?BytesPerLine*NumChars
 BPUT#FO,L DIV 256
 BPUT#FO,L MOD 256
 BPUT#FO,?CharHeight
 BPUT#FO,?BytesPerLine
 BPUT#FO,?MinChar
 BPUT#FO,?MaxChar
 PRINT#FO,Name$

 C=32
 Size=0
 REPEAT
  VDU 12
  PRINT CHR$(C)
  PROCWriteChar(X,FO)
  C=C+1
 UNTIL C=128
 CLOSE#FO
 PRINT "Size was "Size
 ENDPROC

DEF PROCWriteChar(X,FO)
 LOCAL C
 FOR Z=1 TO ?CharHeight
  C=?X
  BPUT#FO,C
  Size=Size+1
  X=X+80
 NEXT
ENDPROC

REM ---------
DEF PROCLoadFont
 Name$=FNAskFileName+".FNT"
 FI=OPENIN(Name$)
 L=(BGET#FI) * 256
 L=L+BGET#FI
 ?CharHeight=BGET#FI
 ?BytesPerLine=BGET#FI
 ?MinChar=BGET#FI
 ?MaxChar=BGET#FI
 INPUT#FI,Name$
 PRINT "Name read was "Name$

 FOR X%=FontSpace TO FontSpace+L
  ?X%=BGET#FI
 NEXT
ENDPROC

REM --------
DEF FNAskFileName
AskFileName1:
 PRINT "What is the name of this font (no extension)";
 INPUT Name$
 IF LEN(Name$)>8 THEN PRINT "Too long. Please Try Again. ":GOTO AskFileName1
=Name$
REM ----------