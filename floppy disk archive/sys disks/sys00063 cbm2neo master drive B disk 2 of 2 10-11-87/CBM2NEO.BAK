/* Picture format converter.

   CBM picture file to ST neochrome format.

   Nick Austin, 14-11-87
   Modified 25-11-87 for 160-wide option.
   Modified  7-12-87 for luminance-order output
   Copyright (C) 1987 Level 9 Computing.

*/

#include <stdio.h>
#include <fcntl.h>

/* Global variables: */

int _fmode = 0x8000 ;

int screenmap [1000] ;   /* Colour values for colours 1,2 */
int colourmap [1000] ;   /* Colour values for colour 3 */
int background ;         /* Colour value for colour 0 */

char inputname[80] ;     /* File name/type for CBM file */
char outputname[80] ;    /* File name/type for NEO file */

int inputformat ;        /* Non-zero if 128 byte AMSDOS header */
int contenttype ;        /* Non-zero if full-screen */
int widthtype ;          /* Non-zero for 320-wide output */
/* ********** int colourorder ;        /* Non-zero for CBM colour order */

int plane0 ;             /* Bit planes for last eight pixels */
int plane1 ;
int plane2 ;
int plane3 ;
int eightcount ;         /* Number of pixels (zero thru seven) */

int written ;            /* info only. number of file-write operations */

/* ----- */

prs(string)
char *string ;
{ for ( ; *string != '\0' ; )
  { putch ( *string ) ;
    string ++ ;
  }
}

newline()
{ prs("\n") ;
}

anykey()
{ newline() ;
  prs("Finished. Press any key to continue:");
  getch() ;
}

/* ----- */

getfilename(name)
char * name [80] ;
{ for ( name[0] = '\0' ; name[0] == '\0' ; ) gets(name) ;
}

displaydecimal(number)
int number ;
{ int digit ;
  int index ;
  if ( number == 0 )
       prs ("0") ;
  else { for ( index = 1 ; (index*10) <= number ; index *= 10 ) ;
         for ( ; index != 0 ; )
           { digit = (int) ( number / index ) ;
             putch ( (char) (48 + digit) ) ;
             number = number - ( digit * index ) ;
             index = (int) (index / 10) ;
           }
       }
}

/* ----- */

copyright()
{ newline() ;
  prs("CBM 64 picture to ST/NEO format. 7-12-87") ;
  newline() ;
  newline() ;
  prs("Copyright (C) 1987 Level 9 Computing") ;
  newline() ;
}

int _iomode = 0X8000 ; /* DOESN'T WORK FOR OUTPUT FILES */

askfilenames()
{ int exists ;
  int fp ;
  for ( exists=0 ; exists == 0 ; )
    { newline() ;
      prs ("Input file (CBM 64/CBM Art Studio format) ?") ;
      getfilename(&inputname) ;
      newline() ;
      fp = open ( &inputname , (int) (O_RDONLY) ) ;
      if ( fp == -1 )
           { prs ("File not found") ;
             newline() ;
           }
      else { exists = 1 ;
             close ( fp ) ;
           }  
    }
  prs ("Output file (NEO format) ? ") ;
  getfilename(&outputname) ;
}

/* ----- */

selectcontent()
{ char input[80] ;
  int index ;
  for ( contenttype=2 ; ( contenttype == 2 ) || ( contenttype == 3 ) ; )
    { newline() ;
      prs ("Select (A) CBM Art Studio format.") ;
      newline() ;
      prs ("Or     (S) CBM smallpic   format.") ;
      newline() ;
      newline() ;
      prs ("Choose (A/S) ?") ;
      gets(input) ;
      contenttype=2 ;
      for ( index=0 ; (index == 79) || (contenttype == 2) ; )
        { contenttype = 3 ;
          if ( input[index] == 'a' ) contenttype = 1 ;
          if ( input[index] == 'A' ) contenttype = 1 ;
          if ( input[index] == 's' ) contenttype = 0 ;
          if ( input[index] == 'S' ) contenttype = 0 ;
          if ( input[index] == ' ' ) contenttype = 2 ;
          index++ ;
        }
    }
}

selectformat()
{ char input[80] ;
  int index ;
  for ( inputformat = 2 ; ( inputformat == 2 ) || ( inputformat == 3 ) ; )
    { newline() ;
      prs ("Remove AMSDOS header (Y/N) ? ");
      gets(input) ;
      inputformat = 2 ;
      for ( index=0 ; (index == 79) || (inputformat == 2) ; )
         { inputformat = 3 ;
           if ( input[index] == 'y' ) inputformat = 1 ;
           if ( input[index] == 'Y' ) inputformat = 1 ;
           if ( input[index] == 'n' ) inputformat = 0 ;
           if ( input[index] == 'N' ) inputformat = 0 ;
           if ( input[index] == ' ' ) inputformat = 2 ;
           index ++ ;
         }
    }
}

selectwidth()
{ char input[80] ;
  int index ;
  for ( widthtype = 2 ; ( widthtype == 2 ) || ( widthtype == 3 ) ; )
    { newline() ;
      prs ("Double width (N=160, Y=320)? ") ;
      gets(input) ;
      widthtype = 2 ;
      for ( index=0 ; (index == 79) || ( widthtype == 2) ; )
         { widthtype = 3 ;
           if ( input[index] == 'y' ) widthtype = 1 ;
           if ( input[index] == 'Y' ) widthtype = 1 ;
           if ( input[index] == 'n' ) widthtype = 0 ;
           if ( input[index] == 'N' ) widthtype = 0 ;
           if ( input[index] == ' ' ) widthtype = 2 ;
         }
    }
}

/* ********** selectorder()
{ char input[80] ;
  int index ;
  for ( colourorder = 2 ; ( colourorder == 2 ) || ( colourorder == 3 ) ; )
    { newline() ;
      prs ("Colour order (n=sorted, y=CBM order) (Y/N)? ") ;
      gets(input) ;
      colourorder = 2 ;
      for ( index=0 ; (index == 79) || ( colourorder == 2) ; )
         { colourorder = 3 ;
           if ( input[index] == 'y' ) colourorder = 1 ;
           if ( input[index] == 'Y' ) colourorder = 1 ;
           if ( input[index] == 'n' ) colourorder = 0 ;
           if ( input[index] == 'N' ) colourorder = 0 ;
           if ( input[index] == ' ' ) colourorder = 2 ;
         }
    }
} */

/* ----- */

/* Remove sign-extension associated with 'char' and 'short int' */

int positive ( ch )
char ch ;
{ int byte ;
  byte = (int) ch ;
  if ( byte < 0 ) byte = 256 + byte ;
  return ( byte ) ;
}

/* ----- */

/* Uncompress the CBM 64 colour map (originally stored at D800)
   compressed by the SMALLPIC bit-map program */

unpackcolourmap()
{ int indexfrom ;
  int indexto ;
  int temphi ;
  int templo ;
  if ( contenttype == 0 )
    { indexfrom = 340 ;
      indexto = 680-1 ;
      for ( ; indexfrom != 0 ; )
        { templo = positive ( colourmap [ indexfrom-1 ] ) ;
          temphi = (int) ( templo / 16 ) ;
          templo = templo - ( 16 * temphi ) ;
          colourmap [ indexto ] = templo ;
          indexto-- ;
          colourmap [ indexto ] = temphi ;
          indexto -- ;
          indexfrom -- ;
        }
    }
  else for ( indexto=0 ; indexto != 1000 ; indexto++ )
         { templo = positive ( colourmap [indexto] ) ;
           templo = templo - ( 16 * ( (int) ( templo / 16 ) ) ) ;
           colourmap [indexto] = templo ;
         }
}

/* ----- */

unexpectedeof( string )
char * string ;
{ newline() ;
  prs ("***** ERROR: Unexpected EOF (") ;
  prs ( string ) ;
  prs (")") ;
  newline() ;
  exit ( 1 ) ;
}

/* Seek to (current position + length) on file */

junk ( fp , length )
int fp ;
int length ;
{ char buffer ;
  int count ;
  for ( count=0 ; count != length; count ++ )
    if ( 1 == read ( fp , &buffer , 1 ) ) ;
    else unexpectedeof ("skip") ;
}

/* Before processing pixels, load and un-compress colour/screen-map info */

readattributes()
{ int fp ;
  char ch ;
  int index ;
  fp = open ( &inputname , (int) (O_RDONLY) ) ;
  if ( fp == -1 )
     { prs ("***** ERROR: can't re-open input *****") ;
       exit ( 2 ) ;
     }
  if ( inputformat == 1 )
    junk ( fp , 128 ) ;
  if ( contenttype == 0 )
       { junk ( fp , 5440 ) ;
         for ( index=0 ; index != 680 ; index++ )
            if ( read ( fp , &ch , 1 ) == 1 )
                 screenmap [ index ] = positive ( ch ) ;
            else unexpectedeof ( "screen map") ;
         for ( index=0 ; index != 340 ; index++ )
           if ( read ( fp , &ch , 1 ) == 1 )
                colourmap [ index ] = positive ( ch ) ;
           else unexpectedeof( "colour map") ;
         unpackcolourmap() ;
         if ( read ( fp , &ch , 1 ) == 1 )
              background = positive ( ch ) ;
         else unexpectedeof("background") ;
       }
  else { junk ( fp , 8000 ) ;
         for ( index = 0 ; index != 1000 ; index++ )
            if ( read ( fp , &ch , 1 ) == 1 )
                 screenmap [ index ] = positive ( ch ) ;
            else unexpectedeof ( "screen map") ;
         junk ( fp , 1 ) ; /* Border colour */
         if ( read ( fp , &ch , 1 ) == 1 )
              background = positive ( ch ) ;
         else unexpectedeof("background") ;
         junk ( fp , 14 ) ;
         for ( index = 0 ; index != 1000 ; index++ )
            if ( read ( fp , &ch , 1 ) == 1 )
                 colourmap [ index ] = positive ( ch ) ;
            else unexpectedeof ("colour map") ;
       }
  close(fp) ;
}

/* ----- */

writebyte ( file , byte )
int file ;
int byte ;
{ char ch ;
  written++ ;
  if ( byte == 10 ) byte = 0 ; /* Get around bug in output raw-mode */
  ch = (char) byte ;
  if ( 1 == write ( file , &ch , 1 ) ) ;
  else { prs ("***** ERROR: can't write output") ;
         exit ( 1 ) ;
       }
}

writetwobytes ( file , word )
int file ;
int word ;
{ int lobyte ;
  int hibyte ;
  hibyte = (int) ( word / 256 ) ;
  writebyte ( file , hibyte ) ;
  lobyte = word - ( 256 * hibyte ) ;
  writebyte ( file , lobyte ) ;
}

writeheader( fp )
int fp ;
{ int index ;
  writetwobytes ( fp , 0 ) ;      /* Unused */
  writetwobytes ( fp , 0 ) ;      /* Unused */

/* **********  if ( colourorder == 1 )
/*       { writetwobytes ( fp , 0 ) ;      /* Colour 0 Black  */
/*         writetwobytes ( fp , 0x0777 ) ; /* Colour 1 White  */
/*         writetwobytes ( fp , 0x0500 ) ; /* Colour 2 Red    */
/*         writetwobytes ( fp , 0x0066 ) ; /* Colour 3 Cyan   */
/*         writetwobytes ( fp , 0x0506 ) ; /* Colour 4 Purple */
/*         writetwobytes ( fp , 0x0050 ) ; /* Colour 5 Green  */
/*         writetwobytes ( fp , 0x0115 ) ; /* Colour 6 Blue   */
/*         writetwobytes ( fp , 0x0772 ) ; /* Colour 7 Yellow */
/*         writetwobytes ( fp , 0x0522 ) ; /* Colour 8 Orange */
/*         writetwobytes ( fp , 0x0311 ) ; /* Colour 9 Brown  */
/*         writetwobytes ( fp , 0x0733 ) ; /* Colour 10 Lt. Red   */
/*         writetwobytes ( fp , 0x0222 ) ; /* Colour 11 Dark Grey */
/*         writetwobytes ( fp , 0x0444 ) ; /* Colour 12 Med. Grey */
/*         writetwobytes ( fp , 0x0474 ) ; /* Colour 13 Lt. Green */
/*         writetwobytes ( fp , 0x0337 ) ; /* Colour 14 Lt. Blue  */
/*         writetwobytes ( fp , 0x0555 ) ; /* Colour 15 Lt. Grey  */
/*       }
/*  else { ********** */
         writetwobytes ( fp , 0 ) ;      /* Black */
         writetwobytes ( fp , 0x0777 ) ; /* Colour 1,  white */
         writetwobytes ( fp , 0x0311 ) ; /* Colour 9,  Brown */
         writetwobytes ( fp , 0x0500 ) ; /* Colour 2,  Red */
         writetwobytes ( fp , 0x0115 ) ; /* Colour 6,  Blue */
         writetwobytes ( fp , 0x0222 ) ; /* Colour 11, Dark Grey */
         writetwobytes ( fp , 0x0506 ) ; /* Colour 4,  Purple */
         writetwobytes ( fp , 0x0050 ) ; /* Colour 5,  Green */
         writetwobytes ( fp , 0x0522 ) ; /* Colour 8,  Orange */
         writetwobytes ( fp , 0x0337 ) ; /* Colour 14, Lt. Blue */
         writetwobytes ( fp , 0x0733 ) ; /* Colour 10, Lt. Red */
         writetwobytes ( fp , 0x0066 ) ; /* Colour 3,  Cyan */
         writetwobytes ( fp , 0x0474 ) ; /* Colour 13, Lt. Green */
         writetwobytes ( fp , 0x0772 ) ; /* Colour 7,  Yellow */
         writetwobytes ( fp , 0x0444 ) ; /* Colour 12, Med. Grey */
         writetwobytes ( fp , 0x0555 ) ; /* Colour 15, Lt. Grey */
    /* **********   } */

  for ( index=0 ; index != 46 ; index++ )
     writetwobytes ( fp , 0 ) ;
}

/* ----- */

/* Treat bitplane as a shift register, shift in one bit taken from
   the low-order of (byte / range) */

int setbit( bitplane , byte , range )
int bitplane ;
int byte ;
int range ;
{ int bit ;
  byte = (int) ( byte / range ) ;
  bit = byte - 2 * ( (int) ( byte / 2 ) ) ;
  if (widthtype != 0 )
       return ( (bitplane * 4) + (bit * 3) ) ; /* Double resolution */
  else return ( (bitplane * 2) + bit ) ;       /* Normal resolution */
}

/* Given a CBM pixel (0-4) do the colour look-up and add the pixel to
   the ST bitplane */

outpixel( fp , value , row , column )
  int fp ;
  int value ;
  int row ;
  int column ;
{ int index ;
  int byte ;
  int newbyte ;
  index = ( ( (int) (row / 8) ) * 40 ) + ( (int) (column / 4) ) ;
  if ( value == 0 )
       byte = background ;
  else if ( value == 1 )
       byte = (int) ( screenmap [index] / 16 ) ;
  else if ( value == 2 )
       byte = (int) screenmap [index] ;
  else if ( value == 3 )
       byte = (int) colourmap [index] ;
  else { prs ("*****ERROR: internal expansion") ;
         exit ( 2 ) ;
       } ;
  byte = positive ( byte ) ;

  /* Sort the colours into intensity-order */
  byte = byte - 16 * ( (int) (byte/16) ) ;
/* **********  if (colourorder == 0) */
     { newbyte = 16 ;
       if (byte == 0) newbyte = 0 ;
       if (byte == 1) newbyte = 1 ;
       if (byte == 2) newbyte = 3 ;
       if (byte == 3) newbyte = 11 ;
       if (byte == 4) newbyte = 6 ;
       if (byte == 5) newbyte = 7 ;
       if (byte == 6) newbyte = 4 ;
       if (byte == 7) newbyte = 13 ;
       if (byte == 8) newbyte = 8 ;
       if (byte == 9) newbyte = 2 ;
       if (byte == 10) newbyte = 10 ;
       if (byte == 11) newbyte = 5 ;
       if (byte == 12) newbyte = 14 ;
       if (byte == 13) newbyte = 12 ;
       if (byte == 14) newbyte = 9 ;
       if (byte == 15) newbyte = 15 ;
       if (newbyte == 16)
          { prs ("***** ERROR: Invalid 0-15 value: ") ;
            displaydecimal( byte ) ;
            exit (3) ;
          }
       byte = newbyte ;
/*  switch (byte)
     { case 0 : byte = 0 ;  break ;
       case 1 : byte = 1 ;  break ;
       case 2 : byte = 3 ;  break ;
       case 3 : byte = 11 ; break ;
       case 4 : byte = 6 ;  break ;
       case 5 : byte = 7 ;  break ;
       case 6 : byte = 4 ;  break ;
       case 7 : byte = 13 ; break ;
       case 8 : byte = 8 ;  break ;
       case 9 : byte = 2 ;  break ;
       case 10 : byte = 10 ; break ;
       case 11 : byte = 5  ; break ;
       case 12 : byte = 14 ; break ;
       case 13 : byte = 12 ; break ;
       case 14 : byte = 9 ;  break ;
       case 15 : byte = 15 ; */
     }
  plane0 = setbit ( plane0 , byte , 1 ) ;
  plane1 = setbit ( plane1 , byte , 2 ) ;
  plane2 = setbit ( plane2 , byte , 4 ) ;
  plane3 = setbit ( plane3 , byte , 8 ) ;
  eightcount ++ ;
  if ( ( (eightcount == 8)  && (widthtype != 0) ) ||
       ( (eightcount == 16) && (widthtype == 0) ) )
     { eightcount = 0 ;
       writetwobytes ( fp , plane0 ) ; /* Lowest colour bit first */
       writetwobytes ( fp , plane1 ) ;
       writetwobytes ( fp , plane2 ) ;
       writetwobytes ( fp , plane3 ) ;
       plane0 = 0 ;
       plane1 = 0 ;
       plane2 = 0 ;
       plane3 = 0 ;
     }
}

int processrow( fin , fout , row )
int fin ;
int fout ;
int row ;
{ int column ;
  int subrow ;
  int subcolumn ;
  int byte ;
  int value ;
  char characterrow[320] ;
  column = 0 ;
  if ( 320 == read ( fin , &characterrow , 320 ) )
      for ( subrow=0 ; subrow != 8 ; subrow++ )
        { for ( subcolumn=0 ; subcolumn != 320 ; subcolumn += 8 )
         { byte = positive ( characterrow [ subrow + subcolumn ] ) ;
           value = (int) (byte / 64) ;
           byte = byte - value * 64 ; /* Top two bits are left pixel */
           outpixel ( fout , value , row , column ) ;
           value = (int) (byte / 16) ;
           byte = byte - value * 16 ;
           outpixel ( fout , value , row , column ) ;
           value = (int) (byte / 4) ;
           byte = byte - value * 4 ;
           outpixel ( fout , value , row , column ) ;
           value = (int) (byte / 1);
           outpixel ( fout , value , row , column ) ;
           column += 4 ;
           if ( column == 160 )
              { column = 0 ;
                row++ ;
              }
         }
         if (widthtype == 0 ) /* Normal res, pad line length */
            for ( value=0 ; value != 160 ; value++ )
               outpixel ( fout , 0 , 0 , 0 ) ;
        }
  else unexpectedeof( "pixels" ) ;
  return ( row ) ;
}

transform()
{ int fin ;
  int fout ;
  int index ;
  int row ;
  newline() ;
  fout = creat ( &outputname , 0x8000 ) ;  /* Raw mode */
  writeheader ( fout ) ;
  fin = open ( &inputname , (int) O_RDONLY ) ;
  if ( fin == -1 )
       { prs ("ERROR: Can't re-open input:") ;
         prs ( inputname ) ;
         newline() ;
         exit ( 3 ) ;
       }
  else if ( inputformat == 1 )
         junk ( fin , 128 ) ;
  row = 0 ;
  plane0 = 0 ;
  plane1 = 0 ;
  plane2 = 0 ;
  plane3 = 0 ;
  if ( contenttype == 1 )
       for ( index=0 ; index != (8000/320) ; index++ )
          { prs ("pixels processed = ") ;
            displaydecimal ( index * 1280 ) ;
            newline() ;
            row = processrow ( fin , fout , row ) ;
          }
  else for ( index=0 ; index != (5440/320) ; index++ )
          { prs ("pixels processed = ") ;
            displaydecimal ( index * 1280 ) ;
            newline() ;
            row = processrow ( fin , fout , row ) ;
          }
  if ( contenttype == 0 )
    for ( index = 0 ; index != 10240 ; index ++ )
       writebyte ( fout , 0 ) ;
  close ( fin ) ;
  close ( fout ) ;
}

/* ----- */

reportwritten()
{ newline() ;
  prs ("bytes written = ") ;
  displaydecimal ( written ) ;
  newline() ;
}

/* ----- */

main()
{ copyright() ;
  written=0 ;
  askfilenames() ;
  selectcontent() ;
  selectformat() ;
  selectwidth() ;
  selectorder() ;
  readattributes() ;
  transform();
  reportwritten() ;
  anykey() ;
}
