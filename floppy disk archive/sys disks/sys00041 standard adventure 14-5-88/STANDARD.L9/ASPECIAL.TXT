; Lancelot 1 source, copyright (C) 1988 Level 9 Computing.
;
; ASPECIAL.TXT, special case handlers for the game. (In practice, 
; this means most of the code to handle puzzles etc.)
;
; Known bugs:
; The compiler is happier if all DATA statements are followed by 
; comments, otherwise line numbers for errors go wrong.
;
;
BEGIN
; now print any messages to be printed after certain movements
.AFTERMOVE
 if actor=user then amUser
; is ACTOR carrying USER?
 x1=hicurrentpos(user)
 if x1=0 then amUser
 x1=currentpos(user)
 if x1<>actor then amUser
; yes - so do description of the room we've arrived in.
 wanttoPrintAnd=0 ; bug fix
 actor=user ; force printing of desc etc.
 gosub @setuproom ; force first few words to be printed
 gosub @PrintRoom
 actor=currentpos(user) ; reset it

.amUser
; handle ECHO LOCATIONS
 if room<122 then amNotEcho
 if room>136 then amNotEcho
 currentpos(actor)=lastroom
 gosub SetUpRoom

.amNotEcho
; if actor<>user then AmNotUser
;.amNotUser
.amret
 RETURN
;---
;---
;.PRAY
; m1=2510 ; said a devout prayer
; goto ActorM1dot
;---
.SPECIALMOVES
;
; Given ROOM, HIDEST, DEST, ACTOR is to move that way
; and exit has been validated as possible (and hence described)
; in SPECIALEXITS. The purpose of code here is when something
; happens on moving. If exit is to be blocked, code here should
; print the appropriate message and set RESULT=FALSE.
;
 if hidest<>0 then smOk

.smok
 RESULT=TRUE
 RETURN
;
.smPreventActorM1Dot
 gosub ActorM1Dot
 goto smPrevent

.smpreventm1dot
 gosub @printm1dot
.smprevent
 FatalError=True
 result=FALSE
 commandfinished=TRUE
.garet
 return

.smokm1dot
 gosub @printM1dot
 goto smok
;---
.specialtakes
; is POS to be allowed to gain OBJECT?
; return result=FALSE to prevent action
 result=FALSE ; just do a return in any of the handlers to prevent
.stok
 result=TRUE ; allow actor to take object
.stret
 return

.stokm1dot
 result=true ; allow actor to take object
 goto @printm1dot
;---
.StPreventActorM1Dot
 gosub PrintActor

.stpreventm1dot
 result=FALSE ; prevent taking
 goto @printM1dot
;--------
.specialaftermoveobj
; OBJECT has just been moved from HIFROM, FROM to POS, HIPOS
; do anything you want, then return
; no values to return
;
; if hipos=0 then samoNotToObject
.samoNotFromObject
 return
;---
.specialaftergive
; NOUN1 has just been given to the npc NOUN2
; giving glass of wine to damosel?
.saythankyou
 object=noun2
 gosub @printTheobject
 m1=2204 ; said "thankyou"
 goto @printM1Dot
;---
.TIMEDEPENDENTCODE
; called for every minute that goes past
 actor=user ; just in case there is any doubt!
 return
;---
;---
;---
.OBJECTTRIGGER
; Trigger on OBJECT
; set PROCESSED=TRUE if the command is completed
; by this routine (usually by the printing of an
; error message, or some other general response)

 processed=FALSE
 if object=nullobject then otok
 if verb=iexamine then otExamine
 gosub @checkifpresent
 if result=FALSE then otret ; not here, so do nothing
 OTPOS=CURRENTPOS(OBJECT) ; remain set throughout this routine
 OTHIPOS=HICURRENTPOS(OBJECT)
 processed=TRUE ; prevent processing unless cleared at end of routine
; special cases...

.otExamine
.OTOK
 processed=FALSE ; PROCESSING MAY CONTINUE
.otret
 RETURN

.otpreventm1dot
 gosub @printM1dot
.otprevent
 processed=TRUE
 return

.FUNNIES
; Value of word entered is in 'OBJECT' (relative to NOUNOFFSET)
; Also have 'VERB' and may have 'PREP' if one has been entered
; before this noun on the input line.
; Return processed=TRUE if a special message is printed in this routine
; which should prevent the printing of other messages
 if object=nullobject then funniesok
 processed=true ; prevent action unless drop through to end
; if verb<>iexamine then fnotexamine
; gosub isroomvandalised
; if result=false then fnotvandalised
; message 2213 ; vandals seem to have been at work here
; message dot
; if noun1<255 then fnotvandalised ; normal object, so also
;; print normal description
; return
;
;.fnotvandalised
; if object<600 then nothingspecial ;*needed?
; if object>699 then funniesok ;nothingspecial
;; examining tree/terrain
; verb=iam
; gosub @printOBJECTverb
; x1=object
; x2=340
; add x1,x2
; message x1 ; examine message for tree/terrain
; message dot
; return
;
.nothingspecial

; message 2112 ; it looks exactly as you would expect
; return

.fnotexamine
 if object<240 then notvandal
; if verb=iattack then vandal

.notvandal
.examnotscenery
.funniesok
 processed=FALSE
 RETURN
;---
;.vandal
;; vandalising scenery in ROOM
;; has it already been vandalised?
; if noun1<minsceneryobj then notvandal
; gosub isroomvandalised
; if result=true then alreadyvandalised
; if x2=vandalmax then cantaddentry ; off end of table
;
;; add entry
; message 2210 ; vandal!
; message dot
; vandaltable(x2)=room
; add vandalptr,c1
; return
;
;.cantaddentry
;; can't add any more vandalised locations, so be rude to player..
; message 2212 ; get knotted!
; message dot
; return
;
;.alreadyvandalised
; message 2211 ; don't bother.. you made a good job last time
; message dot
; return
;---
;.isroomvandalised
;; has room already been vandalised?
;; return result=true or false accordingly
; result=false
; x2=vandalbase ; pointer into table
;.vandal1
; x1=vandaltable(x2)
; if x2=vandalptr then irvret ; return false
; if x1=room then @returntrue
; add x2,c1
; if x2<vandalmax then vandal1
;.irvret
; return
;
;---
.SPECIALEXAMINE
; print any special examine messages which follow
; the basic message but are before any contents are printed
; set processed=TRUE if the contents should not be printed
; if object<>generaldoor then seNotDoor
;
;.seNotDoor
 RETURN
;---
.SPECIALPREEXAMINE
; before printing examine message / contents, check if
; anything should prevent this. Return TRUE if details should
; NOT be printed
; if object>MaxNpc then SPENotPerson
; gosub ReportHealth
; if x1=0 then returnTrue ; dead!
;
;.SPENotPerson
 RESULT=FALSE ; proceed normally
.speok
 RETURN

.returnTrueM1Dot
 result=true
 goto PrintM1Dot
;---
.CANTSEETHAT
 M1=2019 ; can't see that
 GOTO @errorm1
;---
.mighthurtyourself
 m1=2401 ; you might hurt yourself
 goto @errorm1dot
;----
;---
.StopObject
 actorsave=actor
 actor=object
 gosub @stop
 actor=actorsave
 goto resetactor
;---
.resetactor
 gosub @setACTORATTRIBUTES
 goto @initfifo
;---
;---
.MAKEENEMIES
; make TARGET and ACTOR be enemies
 OBJECT=TARGET
 GOSUB @setX4toOBJECTATTRIBUTES
;;; and set up attacker and target to be enemies...
 NPCCURRENT(X4)=ACTOR
 NPCCURRENT(ACTORATTRIBUTES)=TARGET
 return
;---
; Routines to return pointer to character 'OBJECT' data. Note that they 
; rely on npcentrysize=16, so beware if you change this.
.setACTORATTRIBUTES
 ACTORATTRIBUTES=ACTOR
 ADD ACTORATTRIBUTES,ACTORATTRIBUTES
 ADD ACTORATTRIBUTES,ACTORATTRIBUTES
 ADD ACTORATTRIBUTES,ACTORATTRIBUTES
; ADD ACTORATTRIBUTES,ACTORATTRIBUTES
 RETURN
;
.setX4toOBJECTATTRIBUTES
; return pointer in X4. (Modify .notifynpc if you change this routine)
 X4=0
 if object>maxNpc then sxtnnotalive
 X4=OBJECT
 ADD X4,X4
 ADD X4,X4
 ADD X4,X4
; ADD X4,X4
.sxtnnotalive
 return
;---
.SILLY
; prs "[actor who is being silly is: "
; x1=actor
; gosub printTHEobjectx1
; prs "]"
; message cr
 gosub @AbsCancelInput
 M1=3100
 GOTO @VARYERRORM1DOT
;---
;-------------------
.SPECIALDESC
; come here after all objects and exits printed
; no return necessary
.sdret
 RETURN
;---
.SPECIALEXITS
; Given 'FROM' 'DIR' 'DEST'
; Modify if an exit is blocked for some reason
 HIDEST=0 ; normally can't move onto a container through an exit
 X1=HICURRENTPOS(ACTOR)
 IF X1=0 THEN SEORDINARY
; ACTOR is on something - so exits may be different
; Standing on something, but can take as being an
; ordinary exit from the room in which the container is ('ROOM')
.SEORDINARY
; now check any other modified exits
; if dest<minsynthroomminus1 then senotsynth
; x1=dest
; gosub @GetTerrainType
; if x1<minsynthroomminus1 then seprevent ; should be going to a fixed room
; if x1=112 then seprevent ; unavailable room
;
; If you want to prevent movement onto a particular class
; of terrain, add the line:
;
; IF x1<116 (say) then seprevent
;
; then terrain types MINSYNTHROOM to 115 will be impossible to move onto.
; (You may need to remove the range check on DEST above, as well)
.senotsynth
; if from<>116 then seNotBridge
; if dir<>4 then seNotBridge
; dest=28
;
;.seNotBridge
.specialexitsok
 RETURN

.seprevent
.SEFALSE
; Exit is not present
 DEST=0
 EXITVISIBLE=FALSE
 RETURN
;---
.SPECIALDROPS
; trying to drop 'OBJECT' to position HIPOS, POS
; Print appropriate message if desired
; and return RESULT=FALSE if ACTOR is to be prevented from dropping it
; if hipos=0 then sdnotputonobject
;.sdnotputonobject ; not going to a container
 RESULT=TRUE ; allow it to be dropped
 RETURN
;---
.SPECIALACTOR
; print ACTOR

 cif AllowBoat
  x1=hicurrentpos(actor)
  if x1=0 then specialActor1
  x1=currentpos(actor)
  if x1<>boat then specialActor1
.sa1
; print "the container was..."
  object=x1
  verb=iam
  goto PrintObjectVerb

.specialActor1
 cend

 lastwordprinted=actor ; force it to print the article - 'you'
 verb=iam
 goto @printACTORverb
;---
.specialcheckifaccessible
; if no special code is needed, LEAVE RESULT UNCHANGED
; otherwise return RESULT=TRUE if OBJECT is accessible to VERB
; or RESULT=FALSE if not accessible.
 if processingsay=TRUE then sciatrue
.sciaNotAutomatic
 if verb=isetupgo then conditionaltrue ; sciatrue
 if verb=igdgo then conditionaltrue ; sciatrue
 if verb=isetupfind then conditionaltrue ; sciatrue
 if verb=igdfind then conditionaltrue ; sciatrue
 if verb=igetme then sciatrue
 if verb=iwaitforperson then conditionaltrue ; sciatrue ; wait for ...
 if verb=iwaitforperiod then conditionaltrue ; sciatrue ; wait for ...
 if verb=iwaituntiltime then conditionaltrue ; sciatrue ; wait until ...
 if object<>generaldoor then scianotdoor
 gosub @setupdoor
 if door=TRUE then sciatrue
 goto @returnfalse

.scianotdoor
 return
;
.conditionaltrue
; only true if OBJECT exists in the game
 x1=currentpos(object)
 if x1=0 then @returnfalse
.sciatrue
 result=TRUE
 return
;---
.isobjectalive
; return result=TRUE if it is
 if object>maxnpc then @returnfalse
 gosub SetX4ToObjectAttributes
 x1=hitpointOffset
 add x1,x4
 x1=npcCurrent(x1)
 if x1>0 then sciatrue
 result=FALSE
.ioaret
 return
;---
;
.specialdescbeforeexits
; printed immediately after short+long room descs.
; no return needed

.printdistantfeatures ;*
; what is the height of the current location?
; what is the special feature at the current location?
;
 return
;---
.calcheight
; return x1 = height of ROOM with scenery object x4
; x4=1..25 corresponding to room if special feature
 return
;---
.CalcTerrainAndTree
; return x1=tree type and x2+x3=terrain type
; for ROOM.
 return
;---
.GetXY
; return X=x co-ordinate on grid
; Y=y co-ordinate on grid
 if room>minsynthroomminus1 then getxysynth
; fixed room
 x=0
 y=0
 return

.getxysynth
 x1=room
.getxyx1
 x2=minsynthroomminus1
 sub x1,x2
 sub x1,c1
 x2=xmaxplus1
 gosub @x1divx2
 y=x1 ; y:=room div xmax = y co-ordinate
 add x2,x3
 x=x2 ; x:=room mod xmax = x co-ordinate
 return
;---
.convertroom
; return x1 as the room number for the description
; printed by a room object being here.
; descriptions are in table with offsets 240..255
; exits are stored in table from room 10..30
 x1=minsceneryobjtimes2minus1 ; double to give index into initial pos
.cr1
 x2=objectstart(x1)
 if x2=room then crfound
 add x1,c2
 if x1<maxsceneryobjtimes2plus2 then cr1
 x1=0
 return
.crfound
; objects have numbers minsceneryobj..maxsceneryobj
; we want offset in objects 1..25
;; so subtract minsceneryobjminus1
 x2=2
 gosub @x1divx2 ; get object number
 x2=minsceneryobjminus1
 sub x1,x2
 return
;---
.GetUserHitPoints
 object=user
 gosub SetX4toObjectAttributes
 x1=hitpointoffset
 add x1,x4
 x1=npccurrent(x1)
 return
;---
.specialactivatenpc
; We are activating npc ACTOR
; Put special code handlers for them HERE.
; Set processed=TRUE if they have already done
; everything they are going to this turn.
; return verb<>0 to do that action
.sanOK
 processed=false ; no special code - so allow npc to activate
.sanRet
 return

.saPreventActorM1Dot
 gosub PrintActor

.setProcessedM1Dot
.saPreventM1Dot
; print m1, do nothing else this turn
 gosub PrintM1Dot

.saPrevent
 processed=true
 return
;---
.isobjectalert
; return result=TRUE if OBJECT is awake
 gosub @isobjectalive
;; if result=FALSE then ioalertret
.ioalertret
 return
;---
.canactormove
; return result=FALSE if ACTOR is prevented from moving
 result=TRUE
.camret
 return
;---
.canactorrandommove
; return result=TRUE if actor can make random moves
 result=false ; no-one moves at random in this part. TRUE
.carmret
 return
;---
.handleinterruption
; ACTOR has been interrupted in the middle of something
; Do whatever you see fit, then return
; No values need be returned
 return
;---
.specialrtmessage
; actor is just about to print M1 as part of a racetrack
; instruction. Use this hook to intercept particular things
; which may happen in the message which cannot be easily
; coded elsewhere.
 return
;---
.newracetrackforobject
; start racetrack x6 for actor OBJECT
 actorsave=actor
 actor=object ; replace its racetrack with a new one...
 gosub @setACTORATTRIBUTES
 gosub @stop ; kill existing racetrack
 x1=x6 ; race track number to execute
 gosub @initracetrackx1
 actor=actorsave
 goto @resetactor ; from actorsave
;---
.checknullaction
; ACTOR has no stack actions to do, so we may want to start up a new 
; one. This is used for people such as the valkyrie in Knight Orc, 
; for whom it is VITAL that they should not become 'unhooked'. Set 
; ORDERWAITING to the first command to  execute, if you want ACTOR 
; to obey it immediately.
; if actor=* then RestartRacetrack
 return

.RestartRacetrack
; restart the original racetrack
 x6=actor
 object=actor
 goto NewRaceTrackForObject
;---
.specialcheckifpresent
; have just checked if object is present
; Add special modifiers here.
; return RESULT=TRUE if object here.
 return
;---
.specialinitnpcs
 return
;---
.destroyobject
; object gets destroyed, and replaced in a location as appropriate
 currentpos(object)=c0
 hicurrentpos(object)=c0
 return
;---
.createobject ;** used now?
; OBJECT gets created in current room
 currentpos(object)=room
 hicurrentpos(object)=c0
 return
;---
.createobjectpos ;** used now?
; create OBJECT at position HIPOS, POS
 currentpos(object)=pos
 hicurrentpos(object)=hipos
 return
;---
.TRIGGERWORDS
; check current word to see if it is a trigger word
; ACTOR is the target of conversation
 SEARCHTYPE=NOUNTYPE
 GOSUB @CHECKTYPE
; see if there is any action to take on VALUE
 if value=nullvalue then tgret
 gosub @checknoun
 if processed=TRUE then tgret

; OBJECT is a word spoken TO actor
 if twNoun<>0 then tw2 ; verb seems to be cleared before subsequent words.
 if verb<>itell then tgret
.tw2
 if object<>user then tellNotUser
 if twNoun=object then TellNotUser ; "tell me about me"
 twNoun=object ; "tell me about.. "
 return

.tellNotUser
 result=false
 gosub doquestion
 if result=true then @realsayend ; clear stack, terminates if processed
.TGRET
 return


; if verb=itell then tgret ; process as parsed sentence
;; OBJECT is a word spoken TO actor
; result=false
; gosub doquestion
; if result=true then @realsayend ; clear stack, terminates if processed
;.TGRET
; RETURN
;---
.tell
; tell me about NOUN2
 if actor=user then @ask
 result=false
 object=noun1
 if object<>nullobject then tell1
 object=noun2
.tell1
 gosub doquestion
 if result=false then @startorders
 return
;---
.doquestion
; rainbird prints examine messages for item OBJECT
; set result=true if processed
 if verb=itell then doquestion2
; if verb=iask then doquestion2
; if verb=isay then doquestion2
 if verb=0 then doquestion2
 return ; result=false, so not processed

.doquestion2
 if object=nullobject then rainbirdret
 gosub @PrintActor
 m1=3612 ; clears its throat and says "
 gosub @Printm1
 m1=3611 ; ..you, dummy!
 if object=user then twprint
 m1=3610 ; me!
 if object=actor then twprint
 if object=iyou then twprint
;
; objects which the rainbird won't describe because
; their examine messages contain spell names...
 m1=2112 ; nothing special
 if object>maxobject then twprint

 gosub @printTheObject
; do "it is/they are" in PRESENT TENSE
 x1=object
 gosub @conjugatex1
 m1=135 ; are (present tense)
 if result=pluralsome then dor1
 m1=136 ; is (present tense)
.dor1
 gosub @printm1

;; verb=iam
;; gosub @printobjectverb ; that is..
 m1=examinemessages ; base of examine messages
 add m1,object
.twprint
 gosub @printm1 ;dot
 m1=dotquote
 gosub @printm1

 result=true ; processed
.rainbirdret
 return
;---
;---
.isactorflying
; return RESULT=TRUE if ACTOR is flying
 result=FALSE
.iafret
 return
;----------------
.specialconversation
; USER is saying 'verb prep noun1 noun2' to ACTOR
; make any intercepts you fancy.
; If the command is not to be stored, set PROCESSED=TRUE
; and SAYRESPONSE=TRUE
;
; see also TRIGGERWORDS
 if verb=ihello then npchello

 if verb=itell then @tell

; m1=3270 ; won't give anything away
; if verb=igive then scprint
 if verb<211 then scnonotquestion
 m1=3250 ; won't answer that
 if verb<217 then scprint
.scnonotquestion
 m1=3620 ; seemed very offended
 if verb=217 then scprint
 m1=3640 ; won't help
 m1=2038 ; said "that was a rhetorical question"
 if verb=200 then scPreventActorM1Dot
 if verb=201 then scPreventActorM1Dot
 if verb=207 then scprint
 m1=3660 ; echo verb - can't do it etc.
 if verb>199 then scprint
 if verb<20 then scNotSystem
 if verb<32 then scPrint ; system verbs - SAVE, RESTORE etc.
.scNotSystem
 return ; nothing unusual - probably an order, so pass back
; for normal handling code to cope with it.

.scprint
 goto scpreventVaryM1Dot

;---
.scPreventActorM1Dot
 gosub ActorM1Dot
 goto scPrevent
;
.NPCHELLO
; ACTOR is the person the user is trying to talk to, who is here
 m1=3170 ; hello

.scPreventVaryM1Dot
 LASTWORDPRINTED=0 ; prevent use of IT
 gosub @varysaym1dot
.scprevent
 SAYRESPONSE=TRUE
 processed=TRUE
.NPCHELLOret
.knockret
.scNoPrint
 RETURN
;
.scpreventm1dot
 gosub @printm1dot
 goto scprevent
;---
.empty ;** remove verbs?
.pour
 goto @silly
;---
.knock
 goto NothingHappens

.WaterSomething
.checkForWater
 goto @noverb
;---
.hold ;** remove verb?
 goto @take
;----
.win
; gamefinished=40 ; score for finishing game
 message blankline
 gosub @score
 gosub @restartorrestore
 goto @startgame
;---
.SpecialConjugate
; return x1 as type for noun x2 (if different to that in the table)
; if x2=guenever then scProperFemale
.scNotPF
 return
.scProperFemale
 x1=ProperFemale
 return
;---
.SpecialEchoVerb
; trap any unusual responses, then set result=true to prevent
; printing the standard reply
 result=true
 result=false ; do standard reply
 return
;---
;---
.specialEssentialInit
; DEFINE disabled as npc's which are temporarily inactive - 
; i.e. npc's which are in a different part to the user.
; disable/re-enable npcs as appropriate - just
; swap over bit 6 of the "enemy" flag
 return
;---
;.SwapDisabledFlags
; object=2
;.seiLoop1
; gosub SwapDisabledFlag
; add object,c1
; if object<maxNpc then seiLoop1
;; and do MaxNpc by dropping through...
;;
;.SwapDisabledFlag
; gosub SetX4ToObjectAttributes
; x1=npccurrent(x4)
; x2=64
; if x1>191 then seiEnable
; if x1>127 then seiDisable
; if x1>63 then seiEnable
;.seiDisable
; add x1,x2
; goto seiLoop2
;
;.seiEnable
; sub x1,x2
;
;.seiLoop2
; npcCurrent(x4)=x1
; return
;---
